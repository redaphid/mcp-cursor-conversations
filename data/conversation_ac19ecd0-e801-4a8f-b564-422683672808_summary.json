{
  "composer_id": "ac19ecd0-e801-4a8f-b564-422683672808",
  "conversation_length": 3,
  "status": "completed",
  "messages": [
    {
      "type": "user",
      "text": "use signals instead of hooks where possible. Make lots of small functions and keep testability in mind",
      "bubble_id": "a37eda56-0aeb-4509-86f3-56b16495ce61"
    },
    {
      "type": "assistant",
      "text": "",
      "bubble_id": "4fee0965-5a5e-473c-b14d-d6ba231ed165"
    },
    {
      "type": "assistant",
      "text": "Okay, I can help with that. Refactoring to use Signals and breaking down the logic into smaller, testable functions is a good approach for maintainability and clarity.\n\nHere's the plan:\n\n1.  **Introduce Signals:** Replace `useRef` hooks used for managing component state (like `frameNumber`, `resolutionRatio`, shader code, etc.) with `signal` from `@preact/signals-core`. We'll keep `useRef` for the `canvasRef` as it directly interacts with the DOM element.\n2.  **Refactor `useEffect`:** Convert the main `useEffect` hook responsible for WebGL initialization, render loop setup, and cleanup into an `effect` from `@preact/signals-core`. This effect will reactively run based on the signals it depends on (e.g., `initialImageUrl`, `fullscreen`).\n3.  **Extract Helper Functions:** Break down the monolithic `initialize` and `renderLoop` functions into smaller, more focused units like `initializeWebGL`, `compileShader`, `drawScene`, `updateResolution`, `cleanupWebGLResources`, etc. These functions will receive necessary state (often signal values) as arguments, improving testability.\n4.  **Update Logic:** Modify the component logic to read from and write to signals using `.value`.\n\nLet's start by modifying `src/PaperCrane.tsx`. I'll add the necessary imports, replace the refs with signals, and start restructuring the initialization and render loop logic.\n\n```typescript\nimport { effect, signal } from \"@preact/signals-core\" // Use signals\nimport { useRef } from \"preact/hooks\" // Keep useRef for DOM elements\nimport { RefObject } from \"preact\"\n// @ts-ignore - No readily available types for htm/preact\nimport { html } from \"htm/preact\"\nimport * as twgl from \"twgl.js\"\nimport { shaderWrapper } from \"./shader-wrapper.js\"\n\n// --- Helper Functions (To be potentially extracted further) ---\n\n// Simple full-screen quad\nconst positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]\n\nconst getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {\n    return new Promise((resolve) => {\n        if (!gl) {\n            console.error(\"WebGL context not available for texture loading.\")\n            resolve(null)\n            return\n        }\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)\n        const texture = twgl.createTexture(\n            gl,\n            {\n                src: url,\n                crossOrigin: \"anonymous\",\n                min: gl.NEAREST,\n                mag: gl.NEAREST,\n                wrap: gl.REPEAT\n            },\n            () => {\n                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)\n                resolve(texture)\n            }\n        )\n    })\n}\n\ninterface ShaderError {\n    lineNumber: number\n    message: string\n}\n\n// Function to compile shader and handle errors\nconst compileShaderAndHandleError = (\n    gl: WebGL2RenderingContext,\n    vertexSource: string,\n    fragmentSource: string,\n    onError: (error: ShaderError | null) => void\n): twgl.ProgramInfo | null => {\n    const wrappedFragmentShader = shaderWrapper(fragmentSource)\n    try {\n        // Try creating the program\n        const programInfo = twgl.createProgramInfo(gl, [vertexSource, wrappedFragmentShader])\n        if (!programInfo?.program) {\n            // This path might be redundant if createProgramInfo throws on shader compile error,\n            // but kept for safety. TWGL might handle linking errors here.\n            handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n            return null\n        }\n        onError(null) // Clear error on success\n        return programInfo\n    } catch (error) {\n        // Catch errors thrown by twgl during shader compilation\n        handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n        return null\n    }\n}\n\nconst handleShaderError = (\n    gl: WebGL2RenderingContext,\n    wrappedFragmentShader: string,\n    onError: ((error: ShaderError | null) => void) | undefined\n) => {\n    // We need to manually compile to get the detailed error log\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n    if (!fragmentShader) {\n        onError?.({ lineNumber: 0, message: \"Failed to create fragment shader object.\" })\n        return\n    }\n    gl.shaderSource(fragmentShader, wrappedFragmentShader)\n    gl.compileShader(fragmentShader)\n\n    let log = gl.getShaderInfoLog(fragmentShader)\n    if (typeof log !== \"string\" || log.length === 0) {\n        log = \"Unknown shader compilation error\" // Fallback message\n    }\n    gl.deleteShader(fragmentShader) // Clean up the shader object\n\n    // --- Error Parsing Logic (mostly unchanged) ---\n    const wrappedLines = wrappedFragmentShader.split(\"\\n\")\n    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))\n\n    let message = \"Shader compilation failed.\"\n    let lineNumber = 0\n    const errorMatch = log.match(/ERROR: \\d+:(\\d+): (.*)/)\n    if (errorMatch) {\n        lineNumber = parseInt(errorMatch[1]) - headerLines - 1\n        message = errorMatch[2].trim()\n    } else {\n        const fallbackMatch = log.match(/ERROR: \\d+:(\\d+):/)\n        if (fallbackMatch) {\n            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1\n        }\n        // Adjust message parsing to handle potential multiline logs or different formats\n        const errorParts = log.split(\":\")\n        message = errorParts.length > 3 ? errorParts.slice(3).join(\":\").trim() : log\n    }\n\n    const errorDetails = { lineNumber, message }\n    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)\n    onError?.(errorDetails) // Call the onError prop\n}\n\nconst calculateResolutionRatio = (frameTime: number, renderTimes: number[], currentRatio: number): number => {\n    const newRenderTimes = [...renderTimes, frameTime]\n    if (newRenderTimes.length > 20) newRenderTimes.shift()\n    if (newRenderTimes.length < 20) return currentRatio // Not enough data yet\n\n    const avgFrameTime = newRenderTimes.reduce((a, b) => a + b) / newRenderTimes.length\n\n    let nextRatio = currentRatio\n    if (avgFrameTime > 50) nextRatio = Math.max(0.5, currentRatio - 0.5)\n    else if (avgFrameTime < 20 && currentRatio < 1) nextRatio = Math.min(1, currentRatio + 0.1)\n\n    // Return the times array as well if we need to update it outside\n    return nextRatio\n}\n\n// Wrapper for render times update logic\nconst updateRenderTimes = (frameTime: number, renderTimesSignal: { value: number[] }): void => {\n    const currentTimes = renderTimesSignal.value\n    currentTimes.push(frameTime)\n    if (currentTimes.length > 20) {\n        currentTimes.shift()\n    }\n    // No need to assign back to signal.value if modifying the array in place\n    // renderTimesSignal.value = currentTimes; // This would create a new array and trigger effects unnecessarily\n}\n\nconst askForWakeLock = async (): Promise<WakeLockSentinel | null> => {\n    if (!navigator.wakeLock) return null\n    try {\n        return await navigator.wakeLock.request(\"screen\")\n    } catch (e) {\n        console.warn(\"Could not acquire wake lock:\", e)\n        return null\n    }\n}\n\nconst defaultVertexShader = `#version 300 es\nin vec4 position;\nvoid main() {\n    gl_Position = position;\n}`\n\nconst resolveUniformReferences = (uniforms: Record<string, any>): Record<string, any> => {\n    const resolvedUniforms = { ...uniforms }\n    for (const [key, value] of Object.entries(resolvedUniforms)) {\n        if (typeof value !== \"string\") continue\n\n        const referencedValue = resolvedUniforms[value]\n        if (referencedValue !== undefined && key !== value) {\n            resolvedUniforms[key] = referencedValue\n        } else if (referencedValue === undefined && key !== value) {\n            // console.warn(`Unresolved uniform reference: ${key} -> ${value}`);\n            // Decide how to handle: remove, set to default, etc.\n            // For now, let's remove it to avoid potential WebGL errors\n            delete resolvedUniforms[key]\n        }\n    }\n    return resolvedUniforms\n}\n\nconst filterInvalidUniforms = (uniforms: Record<string, any>): Record<string, any> => {\n    return Object.fromEntries(\n        Object.entries(uniforms).filter(\n            ([, value]) =>\n                value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))\n        )\n    )\n}\n\nconst createAndConfigureFramebuffers = (gl: WebGL2RenderingContext): twgl.FramebufferInfo[] => {\n    const framebuffers = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]\n    framebuffers.forEach((fb) => {\n        if (fb) {\n            const texture = fb.attachments[0]\n            gl.bindTexture(gl.TEXTURE_2D, texture)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)\n        } else {\n            console.error(\"Failed to create framebuffer.\")\n            // Handle error appropriately, maybe return empty array or throw\n        }\n    })\n    gl.bindTexture(gl.TEXTURE_2D, null) // Unbind texture\n    return framebuffers.filter((fb): fb is twgl.FramebufferInfo => fb !== null) // Filter out potential nulls\n}\n\nconst resizeCanvas = (\n    canvas: HTMLCanvasElement,\n    gl: WebGL2RenderingContext,\n    ratio: number,\n    isFullscreen: boolean\n) => {\n    let width = canvas.clientWidth\n    let height = canvas.clientHeight\n    if (isFullscreen) {\n        width = window.innerWidth\n        height = window.innerHeight\n    }\n\n    const newWidth = width * ratio\n    const newHeight = height * ratio\n\n    if (canvas.width !== newWidth || canvas.height !== newHeight) {\n        canvas.width = newWidth\n        canvas.height = newHeight\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)\n\n        if (isFullscreen) {\n            canvas.style.width = `${window.innerWidth}px`\n            canvas.style.height = `${window.innerHeight}px`\n        } else {\n            // For non-fullscreen, twgl.resizeCanvasToDisplaySize might be simpler\n            // twgl.resizeCanvasToDisplaySize(canvas, ratio); // Reconsider this based on exact needs\n        }\n        return true // Indicates resize happened\n    }\n    return false // No resize needed\n}\n\n// Define props for the component\ninterface PaperCraneProps {\n    initialImageUrl: string\n    fullscreen?: boolean\n    features?: Record<string, any>\n    fragmentShader: string\n    onError?: (error: ShaderError | null) => void\n}\n\n// Define WakeLockSentinel type\ninterface WakeLockSentinel extends EventTarget {\n    readonly released: boolean\n    readonly type: string\n    release(): Promise<void>\n    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null\n}\n\n// --- Component Implementation ---\n\nexport const PaperCrane = ({\n    initialImageUrl: initialImageUrlProp,\n    fullscreen: fullscreenProp = false,\n    features: featuresProp,\n    fragmentShader: fragmentShaderProp,\n    onError: onErrorProp\n}: PaperCraneProps) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n\n    // --- Signals for State ---\n    const glSignal = signal<WebGL2RenderingContext | null>(null)\n    const programInfoSignal = signal<twgl.ProgramInfo | null>(null)\n    const frameBuffersSignal = signal<twgl.FramebufferInfo[]>([])\n    const bufferInfoSignal = signal<twgl.BufferInfo | null>(null)\n    const frameNumberSignal = signal(0)\n    const lastRenderSignal = signal(performance.now())\n    const renderTimesSignal = signal<number[]>([])\n    const resolutionRatioSignal = signal(1)\n    const lastFragmentShaderSignal = signal<string | null>(null)\n    const initialTextureSignal = signal<WebGLTexture | null>(null)\n    const animationFrameIdSignal = signal<number | null>(null)\n    const wakeLockSignal = signal<WakeLockSentinel | null>(null)\n\n    // Signals for props to easily react to changes\n    const initialImageUrl = signal(initialImageUrlProp)\n    const fullscreen = signal(fullscreenProp)\n    const features = signal(featuresProp || {})\n    const fragmentShader = signal(fragmentShaderProp)\n    const onError = signal(onErrorProp)\n\n    // Update signals when props change\n    // Note: In strict signal usage, you might pass signals down directly,\n    // but this pattern is common for interfacing with prop-based systems.\n    effect(() => {\n        initialImageUrl.value = initialImageUrlProp\n    })\n    effect(() => {\n        fullscreen.value = fullscreenProp\n    })\n    effect(() => {\n        features.value = featuresProp || {}\n    })\n    effect(() => {\n        fragmentShader.value = fragmentShaderProp\n    })\n    effect(() => {\n        onError.value = onErrorProp\n    })\n\n    // Main setup and render loop effect\n    effect(() => {\n        const canvas = canvasRef.current\n        const currentInitialImageUrl = initialImageUrl.value\n        const currentFullscreen = fullscreen.value\n        const currentOnError = onError.value\n\n        if (!canvas) return\n\n        let handleResize: (() => void) | null = null\n        let isActive = true // Flag to prevent cleanup races\n\n        const initialize = async () => {\n            wakeLockSignal.value = await askForWakeLock()\n\n            const gl = canvas.getContext(\"webgl2\", {\n                antialias: false,\n                powerPreference: \"high-performance\",\n                preserveDrawingBuffer: false,\n                alpha: false,\n                depth: false,\n                stencil: false\n            })\n\n            if (!gl) {\n                console.error(\"WebGL2 not supported or context creation failed.\")\n                // Consider calling onError here\n                currentOnError?.({ lineNumber: 0, message: \"WebGL2 not supported\" })\n                return\n            }\n            glSignal.value = gl\n\n            // --- Buffer Setup ---\n            bufferInfoSignal.value = twgl.createBufferInfoFromArrays(gl, {\n                position: { data: positions, numComponents: 3 }\n            })\n\n            // --- Texture Loading ---\n            const tex = await getTexture(gl, currentInitialImageUrl)\n            if (!tex) {\n                console.error(\"Failed to load initial texture.\")\n                currentOnError?.({ lineNumber: 0, message: `Failed to load texture: ${currentInitialImageUrl}` })\n                // Clean up already created resources if texture fails\n                if (bufferInfoSignal.value) twgl.deleteBufferInfo(gl, bufferInfoSignal.value)\n                glSignal.value = null\n                return\n            }\n            initialTextureSignal.value = tex\n\n            // --- Resize Handling ---\n            handleResize = () => {\n                const currentGl = glSignal.value\n                const currentRatio = resolutionRatioSignal.value\n                const isFs = fullscreen.value // Read current fullscreen value\n                if (!currentGl || !canvas) return\n\n                const didResize = resizeCanvas(canvas, currentGl, currentRatio, isFs)\n\n                if (didResize) {\n                    // Recreate framebuffers on resize\n                    // Clean up old ones first\n                    frameBuffersSignal.value.forEach((fb) => gl.deleteFramebuffer(fb.framebuffer))\n                    frameBuffersSignal.value = createAndConfigureFramebuffers(currentGl)\n                }\n            }\n\n            if (currentFullscreen) {\n                canvas.classList.add(\"fullscreen\")\n                window.addEventListener(\"resize\", handleResize)\n            } else {\n                canvas.classList.remove(\"fullscreen\")\n                // Initial resize for non-fullscreen might need clientWidth/Height\n                canvas.style.width = '' // Reset styles if switching from fullscreen\n                canvas.style.height = ''\n            }\n            handleResize() // Initial size setting and framebuffer creation\n\n            // --- Initial Framebuffer Creation (if not done by resize) ---\n            if (frameBuffersSignal.value.length === 0) {\n                frameBuffersSignal.value = createAndConfigureFramebuffers(gl)\n            }\n            if (frameBuffersSignal.value.length < 2) {\n                 console.error(\"Failed to create sufficient framebuffers.\")\n                 currentOnError?.({ lineNumber: 0, message: \"Framebuffer creation failed\" })\n                 // Perform cleanup before returning\n                 cleanupWebGLResources()\n                 return\n            }\n\n\n            // --- Render Loop ---\n            lastRenderSignal.value = performance.now() // Reset timer\n            renderTimesSignal.value = [] // Reset render times\n\n            const renderLoop = (time: number) => {\n                if (!isActive) return // Stop loop if effect cleaned up\n\n                const gl = glSignal.value\n                const currentFragmentShader = fragmentShader.value // Read signal\n                const currentFeatures = features.value // Read signal\n                const currentOnErrorCallback = onError.value // Read signal\n\n                if (!gl || !bufferInfoSignal.value || !currentFragmentShader) {\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n                    return\n                }\n\n                // --- Shader Compilation ---\n                if (currentFragmentShader !== lastFragmentShaderSignal.value) {\n                    // Clean up old program *before* creating new one\n                    if (programInfoSignal.value) {\n                        gl.deleteProgram(programInfoSignal.value.program)\n                    }\n\n                    const newProgramInfo = compileShaderAndHandleError(\n                        gl,\n                        defaultVertexShader,\n                        currentFragmentShader,\n                        currentOnErrorCallback || (() => {}) // Provide a dummy callback if none exists\n                    )\n                    programInfoSignal.value = newProgramInfo // Update signal, even if null\n                    lastFragmentShaderSignal.value = currentFragmentShader // Update even on failure\n\n                    if (newProgramInfo) {\n                         gl.useProgram(newProgramInfo.program) // Use new program immediately\n                    }\n                }\n\n\n                // --- Early exit if shader failed ---\n                 if (!programInfoSignal.value) {\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return; // Skip rendering if program is invalid\n                 }\n\n                // --- Performance / Resolution Adjustment ---\n                const currentTime = performance.now()\n                const frameTime = currentTime - lastRenderSignal.value\n                updateRenderTimes(frameTime, renderTimesSignal) // Update times using helper\n                const newResolutionRatio = calculateResolutionRatio(\n                    frameTime,\n                    renderTimesSignal.value, // Pass current times array\n                    resolutionRatioSignal.value\n                )\n\n                if (newResolutionRatio !== resolutionRatioSignal.value) {\n                    resolutionRatioSignal.value = newResolutionRatio\n                    renderTimesSignal.value = [] // Reset times after ratio change\n\n                    // Trigger resize logic (which recreates framebuffers if needed)\n                    if (handleResize) handleResize()\n                }\n                lastRenderSignal.value = currentTime\n\n                // --- Drawing Logic ---\n                const frameNumber = frameNumberSignal.value\n                const framebuffers = frameBuffersSignal.value\n                // Ensure framebuffers are valid before proceeding\n                 if (framebuffers.length < 2 || !framebuffers[0] || !framebuffers[1]) {\n                    console.warn(\"Framebuffers not ready, skipping frame.\");\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                    return;\n                 }\n\n                const frame = framebuffers[frameNumber % 2]\n                const prevFrame = framebuffers[(frameNumber + 1) % 2]\n\n\n                // Check attachments explicitly\n                 if (!frame?.framebuffer || !prevFrame?.attachments?.[0]) {\n                     console.warn(\"Framebuffer attachments not ready, skipping frame.\");\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return;\n                 }\n\n\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)\n                gl.viewport(0, 0, frame.width, frame.height)\n\n                let uniforms = {\n                    iTime: time / 1000,\n                    iFrame: frameNumber,\n                    prevFrame: frameNumber === 0 ? initialTextureSignal.value : prevFrame.attachments[0],\n                    initialFrame: initialTextureSignal.value,\n                    iResolution: [frame.width, frame.height, 1],\n                    iMouse: [currentFeatures.touchX || 0, currentFeatures.touchY || 0, currentFeatures.touched ? 1 : 0, 0],\n                    iChannel0: initialTextureSignal.value,\n                    iChannel1: prevFrame.attachments[0],\n                    iChannel2: initialTextureSignal.value,\n                    iChannel3: prevFrame.attachments[0],\n                    ...currentFeatures\n                }\n\n                let processedUniforms = filterInvalidUniforms(uniforms)\n                processedUniforms = resolveUniformReferences(processedUniforms)\n\n\n                 gl.useProgram(programInfoSignal.value.program); // Ensure program is set (might have changed)\n                twgl.setBuffersAndAttributes(gl, programInfoSignal.value, bufferInfoSignal.value)\n                twgl.setUniforms(programInfoSignal.value, processedUniforms)\n                twgl.drawBufferInfo(gl, bufferInfoSignal.value)\n\n                // --- Blit to Canvas ---\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n                gl.blitFramebuffer(\n                    0, 0, frame.width, frame.height, // Source\n                    0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, // Destination\n                    gl.COLOR_BUFFER_BIT, gl.NEAREST\n                )\n\n                frameNumberSignal.value++ // Increment frame number\n                animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n            }\n\n            // Start the loop\n            animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n        }\n\n        // Function to clean up all resources\n        const cleanupWebGLResources = () => {\n             isActive = false // Signal render loop to stop\n            if (animationFrameIdSignal.value) {\n                cancelAnimationFrame(animationFrameIdSignal.value)\n                animationFrameIdSignal.value = null\n            }\n            if (wakeLockSignal.value) {\n                wakeLockSignal.value.release().catch((e) => console.warn(\"Could not release wake lock:\", e))\n                wakeLockSignal.value = null\n            }\n\n            const gl = glSignal.value\n            if (gl) {\n                 // Unbind everything\n                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                 gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n                 gl.bindTexture(gl.TEXTURE_2D, null);\n                 gl.useProgram(null);\n\n\n                // Delete resources using signals\n                if (programInfoSignal.value) gl.deleteProgram(programInfoSignal.value.program)\n                 if (bufferInfoSignal.value) {\n                     // Use TWGL helper for buffer cleanup if available and safe\n                     // twgl.deleteBufferInfo(gl, bufferInfoSignal.value); // Might be simpler? Check TWGL docs.\n                     // Manual cleanup:\n                     if (bufferInfoSignal.value.indices) gl.deleteBuffer(bufferInfoSignal.value.indices)\n                     Object.values(bufferInfoSignal.value.attribs || {}).forEach(attr => {\n                         if (attr.buffer) gl.deleteBuffer(attr.buffer);\n                     });\n                 }\n                frameBuffersSignal.value.forEach(fb => {\n                    if (fb) {\n                        gl.deleteFramebuffer(fb.framebuffer);\n                        // TWGL FramebufferInfo might manage attachment deletion, check docs.\n                        // If not, manually delete textures:\n                        fb.attachments?.forEach(attachment => gl.deleteTexture(attachment));\n                    }\n                });\n                if (initialTextureSignal.value) gl.deleteTexture(initialTextureSignal.value)\n\n                 // Attempt to lose context - helps release GPU resources faster sometimes\n                 const loseContextExt = gl.getExtension('WEBGL_lose_context');\n                 if (loseContextExt) {\n                     loseContextExt.loseContext();\n                 }\n\n            }\n\n            // Reset signals\n            glSignal.value = null\n            programInfoSignal.value = null\n            bufferInfoSignal.value = null\n            frameBuffersSignal.value = []\n            initialTextureSignal.value = null\n            lastFragmentShaderSignal.value = null\n             frameNumberSignal.value = 0\n             resolutionRatioSignal.value = 1 // Reset to default\n\n\n            // Clean up DOM and listeners\n            if (currentFullscreen && handleResize) {\n                window.removeEventListener(\"resize\", handleResize)\n            }\n            if (canvasRef.current) {\n                canvasRef.current.classList.remove(\"fullscreen\")\n                canvasRef.current.width = 1 // Minimize memory usage\n                canvasRef.current.height = 1\n            }\n\n\n            console.log(\"Visualizer cleaned up.\")\n        }\n\n\n        initialize().catch(err => {\n             console.error(\"Initialization failed:\", err);\n             currentOnError?.({ lineNumber: 0, message: `Initialization failed: ${err.message}` });\n             cleanupWebGLResources(); // Ensure cleanup happens on init error too\n         });\n\n\n        // Return the cleanup function for the effect\n        return () => {\n            cleanupWebGLResources()\n            // Remove resize listener specifically here if it was added\n            if (handleResize && fullscreen.peek()) { // Use peek to avoid dependency\n                window.removeEventListener(\"resize\", handleResize)\n            }\n        }\n    }, [\n        // Dependencies for the effect: changes here will trigger re-initialization\n        // initialImageUrl, // Handled by signal update effect\n        // fullscreen, // Handled by signal update effect\n        // No explicit dependencies needed as signals handle reactivity.\n        // The effect runs once, and internal logic uses signal.value.\n        // If re-initialization *is* desired on prop change, add signals here:\n        // initialImageUrl, fullscreen\n    ]) // Effect dependencies - re-run if these signals change\n\n    // Render the canvas element\n    return html`<canvas ref=${canvasRef} />`\n}\n\n```\n\nI'll apply this refactoring to your `src/PaperCrane.tsx` file. This includes:\n*   Adding `@preact/signals-core` import.\n*   Replacing state `useRef` calls with `signal`.\n*   Creating signals for props (`initialImageUrl`, `fullscreen`, etc.) and effects to update them.\n*   Replacing the main `useEffect` with `effect`.\n*   Extracting several helper functions (`compileShaderAndHandleError`, `createAndConfigureFramebuffers`, `resizeCanvas`, `filterInvalidUniforms`, `resolveUniformReferences`, `updateRenderTimes`).\n*   Refactoring the initialization and render loop logic to use signals and helper functions.\n*   Improving the cleanup logic.\n*   Adding more robust error handling during initialization and framebuffer creation.\n*   Adding explicit checks for framebuffer/attachment readiness in the render loop.\n*   Ensuring the shader program is cleaned up *before* attempting recompilation.\n*   Ensuring WebGL state (bindings",
      "bubble_id": "f7d27faf-c17f-4002-8ae7-9e3288b5d34b",
      "code_blocks": [
        {
          "unregistered": true,
          "content": "import { effect, signal } from \"@preact/signals-core\" // Use signals\nimport { useRef } from \"preact/hooks\" // Keep useRef for DOM elements\nimport { RefObject } from \"preact\"\n// @ts-ignore - No readily available types for htm/preact\nimport { html } from \"htm/preact\"\nimport * as twgl from \"twgl.js\"\nimport { shaderWrapper } from \"./shader-wrapper.js\"\n\n// --- Helper Functions (To be potentially extracted further) ---\n\n// Simple full-screen quad\nconst positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]\n\nconst getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {\n    return new Promise((resolve) => {\n        if (!gl) {\n            console.error(\"WebGL context not available for texture loading.\")\n            resolve(null)\n            return\n        }\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)\n        const texture = twgl.createTexture(\n            gl,\n            {\n                src: url,\n                crossOrigin: \"anonymous\",\n                min: gl.NEAREST,\n                mag: gl.NEAREST,\n                wrap: gl.REPEAT\n            },\n            () => {\n                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)\n                resolve(texture)\n            }\n        )\n    })\n}\n\ninterface ShaderError {\n    lineNumber: number\n    message: string\n}\n\n// Function to compile shader and handle errors\nconst compileShaderAndHandleError = (\n    gl: WebGL2RenderingContext,\n    vertexSource: string,\n    fragmentSource: string,\n    onError: (error: ShaderError | null) => void\n): twgl.ProgramInfo | null => {\n    const wrappedFragmentShader = shaderWrapper(fragmentSource)\n    try {\n        // Try creating the program\n        const programInfo = twgl.createProgramInfo(gl, [vertexSource, wrappedFragmentShader])\n        if (!programInfo?.program) {\n            // This path might be redundant if createProgramInfo throws on shader compile error,\n            // but kept for safety. TWGL might handle linking errors here.\n            handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n            return null\n        }\n        onError(null) // Clear error on success\n        return programInfo\n    } catch (error) {\n        // Catch errors thrown by twgl during shader compilation\n        handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n        return null\n    }\n}\n\nconst handleShaderError = (\n    gl: WebGL2RenderingContext,\n    wrappedFragmentShader: string,\n    onError: ((error: ShaderError | null) => void) | undefined\n) => {\n    // We need to manually compile to get the detailed error log\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n    if (!fragmentShader) {\n        onError?.({ lineNumber: 0, message: \"Failed to create fragment shader object.\" })\n        return\n    }\n    gl.shaderSource(fragmentShader, wrappedFragmentShader)\n    gl.compileShader(fragmentShader)\n\n    let log = gl.getShaderInfoLog(fragmentShader)\n    if (typeof log !== \"string\" || log.length === 0) {\n        log = \"Unknown shader compilation error\" // Fallback message\n    }\n    gl.deleteShader(fragmentShader) // Clean up the shader object\n\n    // --- Error Parsing Logic (mostly unchanged) ---\n    const wrappedLines = wrappedFragmentShader.split(\"\\n\")\n    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))\n\n    let message = \"Shader compilation failed.\"\n    let lineNumber = 0\n    const errorMatch = log.match(/ERROR: \\d+:(\\d+): (.*)/)\n    if (errorMatch) {\n        lineNumber = parseInt(errorMatch[1]) - headerLines - 1\n        message = errorMatch[2].trim()\n    } else {\n        const fallbackMatch = log.match(/ERROR: \\d+:(\\d+):/)\n        if (fallbackMatch) {\n            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1\n        }\n        // Adjust message parsing to handle potential multiline logs or different formats\n        const errorParts = log.split(\":\")\n        message = errorParts.length > 3 ? errorParts.slice(3).join(\":\").trim() : log\n    }\n\n    const errorDetails = { lineNumber, message }\n    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)\n    onError?.(errorDetails) // Call the onError prop\n}\n\nconst calculateResolutionRatio = (frameTime: number, renderTimes: number[], currentRatio: number): number => {\n    const newRenderTimes = [...renderTimes, frameTime]\n    if (newRenderTimes.length > 20) newRenderTimes.shift()\n    if (newRenderTimes.length < 20) return currentRatio // Not enough data yet\n\n    const avgFrameTime = newRenderTimes.reduce((a, b) => a + b) / newRenderTimes.length\n\n    let nextRatio = currentRatio\n    if (avgFrameTime > 50) nextRatio = Math.max(0.5, currentRatio - 0.5)\n    else if (avgFrameTime < 20 && currentRatio < 1) nextRatio = Math.min(1, currentRatio + 0.1)\n\n    // Return the times array as well if we need to update it outside\n    return nextRatio\n}\n\n// Wrapper for render times update logic\nconst updateRenderTimes = (frameTime: number, renderTimesSignal: { value: number[] }): void => {\n    const currentTimes = renderTimesSignal.value\n    currentTimes.push(frameTime)\n    if (currentTimes.length > 20) {\n        currentTimes.shift()\n    }\n    // No need to assign back to signal.value if modifying the array in place\n    // renderTimesSignal.value = currentTimes; // This would create a new array and trigger effects unnecessarily\n}\n\nconst askForWakeLock = async (): Promise<WakeLockSentinel | null> => {\n    if (!navigator.wakeLock) return null\n    try {\n        return await navigator.wakeLock.request(\"screen\")\n    } catch (e) {\n        console.warn(\"Could not acquire wake lock:\", e)\n        return null\n    }\n}\n\nconst defaultVertexShader = `#version 300 es\nin vec4 position;\nvoid main() {\n    gl_Position = position;\n}`\n\nconst resolveUniformReferences = (uniforms: Record<string, any>): Record<string, any> => {\n    const resolvedUniforms = { ...uniforms }\n    for (const [key, value] of Object.entries(resolvedUniforms)) {\n        if (typeof value !== \"string\") continue\n\n        const referencedValue = resolvedUniforms[value]\n        if (referencedValue !== undefined && key !== value) {\n            resolvedUniforms[key] = referencedValue\n        } else if (referencedValue === undefined && key !== value) {\n            // console.warn(`Unresolved uniform reference: ${key} -> ${value}`);\n            // Decide how to handle: remove, set to default, etc.\n            // For now, let's remove it to avoid potential WebGL errors\n            delete resolvedUniforms[key]\n        }\n    }\n    return resolvedUniforms\n}\n\nconst filterInvalidUniforms = (uniforms: Record<string, any>): Record<string, any> => {\n    return Object.fromEntries(\n        Object.entries(uniforms).filter(\n            ([, value]) =>\n                value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))\n        )\n    )\n}\n\nconst createAndConfigureFramebuffers = (gl: WebGL2RenderingContext): twgl.FramebufferInfo[] => {\n    const framebuffers = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]\n    framebuffers.forEach((fb) => {\n        if (fb) {\n            const texture = fb.attachments[0]\n            gl.bindTexture(gl.TEXTURE_2D, texture)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)\n        } else {\n            console.error(\"Failed to create framebuffer.\")\n            // Handle error appropriately, maybe return empty array or throw\n        }\n    })\n    gl.bindTexture(gl.TEXTURE_2D, null) // Unbind texture\n    return framebuffers.filter((fb): fb is twgl.FramebufferInfo => fb !== null) // Filter out potential nulls\n}\n\nconst resizeCanvas = (\n    canvas: HTMLCanvasElement,\n    gl: WebGL2RenderingContext,\n    ratio: number,\n    isFullscreen: boolean\n) => {\n    let width = canvas.clientWidth\n    let height = canvas.clientHeight\n    if (isFullscreen) {\n        width = window.innerWidth\n        height = window.innerHeight\n    }\n\n    const newWidth = width * ratio\n    const newHeight = height * ratio\n\n    if (canvas.width !== newWidth || canvas.height !== newHeight) {\n        canvas.width = newWidth\n        canvas.height = newHeight\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)\n\n        if (isFullscreen) {\n            canvas.style.width = `${window.innerWidth}px`\n            canvas.style.height = `${window.innerHeight}px`\n        } else {\n            // For non-fullscreen, twgl.resizeCanvasToDisplaySize might be simpler\n            // twgl.resizeCanvasToDisplaySize(canvas, ratio); // Reconsider this based on exact needs\n        }\n        return true // Indicates resize happened\n    }\n    return false // No resize needed\n}\n\n// Define props for the component\ninterface PaperCraneProps {\n    initialImageUrl: string\n    fullscreen?: boolean\n    features?: Record<string, any>\n    fragmentShader: string\n    onError?: (error: ShaderError | null) => void\n}\n\n// Define WakeLockSentinel type\ninterface WakeLockSentinel extends EventTarget {\n    readonly released: boolean\n    readonly type: string\n    release(): Promise<void>\n    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null\n}\n\n// --- Component Implementation ---\n\nexport const PaperCrane = ({\n    initialImageUrl: initialImageUrlProp,\n    fullscreen: fullscreenProp = false,\n    features: featuresProp,\n    fragmentShader: fragmentShaderProp,\n    onError: onErrorProp\n}: PaperCraneProps) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n\n    // --- Signals for State ---\n    const glSignal = signal<WebGL2RenderingContext | null>(null)\n    const programInfoSignal = signal<twgl.ProgramInfo | null>(null)\n    const frameBuffersSignal = signal<twgl.FramebufferInfo[]>([])\n    const bufferInfoSignal = signal<twgl.BufferInfo | null>(null)\n    const frameNumberSignal = signal(0)\n    const lastRenderSignal = signal(performance.now())\n    const renderTimesSignal = signal<number[]>([])\n    const resolutionRatioSignal = signal(1)\n    const lastFragmentShaderSignal = signal<string | null>(null)\n    const initialTextureSignal = signal<WebGLTexture | null>(null)\n    const animationFrameIdSignal = signal<number | null>(null)\n    const wakeLockSignal = signal<WakeLockSentinel | null>(null)\n\n    // Signals for props to easily react to changes\n    const initialImageUrl = signal(initialImageUrlProp)\n    const fullscreen = signal(fullscreenProp)\n    const features = signal(featuresProp || {})\n    const fragmentShader = signal(fragmentShaderProp)\n    const onError = signal(onErrorProp)\n\n    // Update signals when props change\n    // Note: In strict signal usage, you might pass signals down directly,\n    // but this pattern is common for interfacing with prop-based systems.\n    effect(() => {\n        initialImageUrl.value = initialImageUrlProp\n    })\n    effect(() => {\n        fullscreen.value = fullscreenProp\n    })\n    effect(() => {\n        features.value = featuresProp || {}\n    })\n    effect(() => {\n        fragmentShader.value = fragmentShaderProp\n    })\n    effect(() => {\n        onError.value = onErrorProp\n    })\n\n    // Main setup and render loop effect\n    effect(() => {\n        const canvas = canvasRef.current\n        const currentInitialImageUrl = initialImageUrl.value\n        const currentFullscreen = fullscreen.value\n        const currentOnError = onError.value\n\n        if (!canvas) return\n\n        let handleResize: (() => void) | null = null\n        let isActive = true // Flag to prevent cleanup races\n\n        const initialize = async () => {\n            wakeLockSignal.value = await askForWakeLock()\n\n            const gl = canvas.getContext(\"webgl2\", {\n                antialias: false,\n                powerPreference: \"high-performance\",\n                preserveDrawingBuffer: false,\n                alpha: false,\n                depth: false,\n                stencil: false\n            })\n\n            if (!gl) {\n                console.error(\"WebGL2 not supported or context creation failed.\")\n                // Consider calling onError here\n                currentOnError?.({ lineNumber: 0, message: \"WebGL2 not supported\" })\n                return\n            }\n            glSignal.value = gl\n\n            // --- Buffer Setup ---\n            bufferInfoSignal.value = twgl.createBufferInfoFromArrays(gl, {\n                position: { data: positions, numComponents: 3 }\n            })\n\n            // --- Texture Loading ---\n            const tex = await getTexture(gl, currentInitialImageUrl)\n            if (!tex) {\n                console.error(\"Failed to load initial texture.\")\n                currentOnError?.({ lineNumber: 0, message: `Failed to load texture: ${currentInitialImageUrl}` })\n                // Clean up already created resources if texture fails\n                if (bufferInfoSignal.value) twgl.deleteBufferInfo(gl, bufferInfoSignal.value)\n                glSignal.value = null\n                return\n            }\n            initialTextureSignal.value = tex\n\n            // --- Resize Handling ---\n            handleResize = () => {\n                const currentGl = glSignal.value\n                const currentRatio = resolutionRatioSignal.value\n                const isFs = fullscreen.value // Read current fullscreen value\n                if (!currentGl || !canvas) return\n\n                const didResize = resizeCanvas(canvas, currentGl, currentRatio, isFs)\n\n                if (didResize) {\n                    // Recreate framebuffers on resize\n                    // Clean up old ones first\n                    frameBuffersSignal.value.forEach((fb) => gl.deleteFramebuffer(fb.framebuffer))\n                    frameBuffersSignal.value = createAndConfigureFramebuffers(currentGl)\n                }\n            }\n\n            if (currentFullscreen) {\n                canvas.classList.add(\"fullscreen\")\n                window.addEventListener(\"resize\", handleResize)\n            } else {\n                canvas.classList.remove(\"fullscreen\")\n                // Initial resize for non-fullscreen might need clientWidth/Height\n                canvas.style.width = '' // Reset styles if switching from fullscreen\n                canvas.style.height = ''\n            }\n            handleResize() // Initial size setting and framebuffer creation\n\n            // --- Initial Framebuffer Creation (if not done by resize) ---\n            if (frameBuffersSignal.value.length === 0) {\n                frameBuffersSignal.value = createAndConfigureFramebuffers(gl)\n            }\n            if (frameBuffersSignal.value.length < 2) {\n                 console.error(\"Failed to create sufficient framebuffers.\")\n                 currentOnError?.({ lineNumber: 0, message: \"Framebuffer creation failed\" })\n                 // Perform cleanup before returning\n                 cleanupWebGLResources()\n                 return\n            }\n\n\n            // --- Render Loop ---\n            lastRenderSignal.value = performance.now() // Reset timer\n            renderTimesSignal.value = [] // Reset render times\n\n            const renderLoop = (time: number) => {\n                if (!isActive) return // Stop loop if effect cleaned up\n\n                const gl = glSignal.value\n                const currentFragmentShader = fragmentShader.value // Read signal\n                const currentFeatures = features.value // Read signal\n                const currentOnErrorCallback = onError.value // Read signal\n\n                if (!gl || !bufferInfoSignal.value || !currentFragmentShader) {\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n                    return\n                }\n\n                // --- Shader Compilation ---\n                if (currentFragmentShader !== lastFragmentShaderSignal.value) {\n                    // Clean up old program *before* creating new one\n                    if (programInfoSignal.value) {\n                        gl.deleteProgram(programInfoSignal.value.program)\n                    }\n\n                    const newProgramInfo = compileShaderAndHandleError(\n                        gl,\n                        defaultVertexShader,\n                        currentFragmentShader,\n                        currentOnErrorCallback || (() => {}) // Provide a dummy callback if none exists\n                    )\n                    programInfoSignal.value = newProgramInfo // Update signal, even if null\n                    lastFragmentShaderSignal.value = currentFragmentShader // Update even on failure\n\n                    if (newProgramInfo) {\n                         gl.useProgram(newProgramInfo.program) // Use new program immediately\n                    }\n                }\n\n\n                // --- Early exit if shader failed ---\n                 if (!programInfoSignal.value) {\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return; // Skip rendering if program is invalid\n                 }\n\n                // --- Performance / Resolution Adjustment ---\n                const currentTime = performance.now()\n                const frameTime = currentTime - lastRenderSignal.value\n                updateRenderTimes(frameTime, renderTimesSignal) // Update times using helper\n                const newResolutionRatio = calculateResolutionRatio(\n                    frameTime,\n                    renderTimesSignal.value, // Pass current times array\n                    resolutionRatioSignal.value\n                )\n\n                if (newResolutionRatio !== resolutionRatioSignal.value) {\n                    resolutionRatioSignal.value = newResolutionRatio\n                    renderTimesSignal.value = [] // Reset times after ratio change\n\n                    // Trigger resize logic (which recreates framebuffers if needed)\n                    if (handleResize) handleResize()\n                }\n                lastRenderSignal.value = currentTime\n\n                // --- Drawing Logic ---\n                const frameNumber = frameNumberSignal.value\n                const framebuffers = frameBuffersSignal.value\n                // Ensure framebuffers are valid before proceeding\n                 if (framebuffers.length < 2 || !framebuffers[0] || !framebuffers[1]) {\n                    console.warn(\"Framebuffers not ready, skipping frame.\");\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                    return;\n                 }\n\n                const frame = framebuffers[frameNumber % 2]\n                const prevFrame = framebuffers[(frameNumber + 1) % 2]\n\n\n                // Check attachments explicitly\n                 if (!frame?.framebuffer || !prevFrame?.attachments?.[0]) {\n                     console.warn(\"Framebuffer attachments not ready, skipping frame.\");\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return;\n                 }\n\n\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)\n                gl.viewport(0, 0, frame.width, frame.height)\n\n                let uniforms = {\n                    iTime: time / 1000,\n                    iFrame: frameNumber,\n                    prevFrame: frameNumber === 0 ? initialTextureSignal.value : prevFrame.attachments[0],\n                    initialFrame: initialTextureSignal.value,\n                    iResolution: [frame.width, frame.height, 1],\n                    iMouse: [currentFeatures.touchX || 0, currentFeatures.touchY || 0, currentFeatures.touched ? 1 : 0, 0],\n                    iChannel0: initialTextureSignal.value,\n                    iChannel1: prevFrame.attachments[0],\n                    iChannel2: initialTextureSignal.value,\n                    iChannel3: prevFrame.attachments[0],\n                    ...currentFeatures\n                }\n\n                let processedUniforms = filterInvalidUniforms(uniforms)\n                processedUniforms = resolveUniformReferences(processedUniforms)\n\n\n                 gl.useProgram(programInfoSignal.value.program); // Ensure program is set (might have changed)\n                twgl.setBuffersAndAttributes(gl, programInfoSignal.value, bufferInfoSignal.value)\n                twgl.setUniforms(programInfoSignal.value, processedUniforms)\n                twgl.drawBufferInfo(gl, bufferInfoSignal.value)\n\n                // --- Blit to Canvas ---\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n                gl.blitFramebuffer(\n                    0, 0, frame.width, frame.height, // Source\n                    0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, // Destination\n                    gl.COLOR_BUFFER_BIT, gl.NEAREST\n                )\n\n                frameNumberSignal.value++ // Increment frame number\n                animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n            }\n\n            // Start the loop\n            animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n        }\n\n        // Function to clean up all resources\n        const cleanupWebGLResources = () => {\n             isActive = false // Signal render loop to stop\n            if (animationFrameIdSignal.value) {\n                cancelAnimationFrame(animationFrameIdSignal.value)\n                animationFrameIdSignal.value = null\n            }\n            if (wakeLockSignal.value) {\n                wakeLockSignal.value.release().catch((e) => console.warn(\"Could not release wake lock:\", e))\n                wakeLockSignal.value = null\n            }\n\n            const gl = glSignal.value\n            if (gl) {\n                 // Unbind everything\n                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                 gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n                 gl.bindTexture(gl.TEXTURE_2D, null);\n                 gl.useProgram(null);\n\n\n                // Delete resources using signals\n                if (programInfoSignal.value) gl.deleteProgram(programInfoSignal.value.program)\n                 if (bufferInfoSignal.value) {\n                     // Use TWGL helper for buffer cleanup if available and safe\n                     // twgl.deleteBufferInfo(gl, bufferInfoSignal.value); // Might be simpler? Check TWGL docs.\n                     // Manual cleanup:\n                     if (bufferInfoSignal.value.indices) gl.deleteBuffer(bufferInfoSignal.value.indices)\n                     Object.values(bufferInfoSignal.value.attribs || {}).forEach(attr => {\n                         if (attr.buffer) gl.deleteBuffer(attr.buffer);\n                     });\n                 }\n                frameBuffersSignal.value.forEach(fb => {\n                    if (fb) {\n                        gl.deleteFramebuffer(fb.framebuffer);\n                        // TWGL FramebufferInfo might manage attachment deletion, check docs.\n                        // If not, manually delete textures:\n                        fb.attachments?.forEach(attachment => gl.deleteTexture(attachment));\n                    }\n                });\n                if (initialTextureSignal.value) gl.deleteTexture(initialTextureSignal.value)\n\n                 // Attempt to lose context - helps release GPU resources faster sometimes\n                 const loseContextExt = gl.getExtension('WEBGL_lose_context');\n                 if (loseContextExt) {\n                     loseContextExt.loseContext();\n                 }\n\n            }\n\n            // Reset signals\n            glSignal.value = null\n            programInfoSignal.value = null\n            bufferInfoSignal.value = null\n            frameBuffersSignal.value = []\n            initialTextureSignal.value = null\n            lastFragmentShaderSignal.value = null\n             frameNumberSignal.value = 0\n             resolutionRatioSignal.value = 1 // Reset to default\n\n\n            // Clean up DOM and listeners\n            if (currentFullscreen && handleResize) {\n                window.removeEventListener(\"resize\", handleResize)\n            }\n            if (canvasRef.current) {\n                canvasRef.current.classList.remove(\"fullscreen\")\n                canvasRef.current.width = 1 // Minimize memory usage\n                canvasRef.current.height = 1\n            }\n\n\n            console.log(\"Visualizer cleaned up.\")\n        }\n\n\n        initialize().catch(err => {\n             console.error(\"Initialization failed:\", err);\n             currentOnError?.({ lineNumber: 0, message: `Initialization failed: ${err.message}` });\n             cleanupWebGLResources(); // Ensure cleanup happens on init error too\n         });\n\n\n        // Return the cleanup function for the effect\n        return () => {\n            cleanupWebGLResources()\n            // Remove resize listener specifically here if it was added\n            if (handleResize && fullscreen.peek()) { // Use peek to avoid dependency\n                window.removeEventListener(\"resize\", handleResize)\n            }\n        }\n    }, [\n        // Dependencies for the effect: changes here will trigger re-initialization\n        // initialImageUrl, // Handled by signal update effect\n        // fullscreen, // Handled by signal update effect\n        // No explicit dependencies needed as signals handle reactivity.\n        // The effect runs once, and internal logic uses signal.value.\n        // If re-initialization *is* desired on prop change, add signals here:\n        // initialImageUrl, fullscreen\n    ]) // Effect dependencies - re-run if these signals change\n\n    // Render the canvas element\n    return html`<canvas ref=${canvasRef} />`\n}\n",
          "languageId": "typescript",
          "isGenerating": false,
          "isClickable": false,
          "codeBlockIdx": 0
        }
      ]
    }
  ]
}