{
  "_v": 1,
  "composerId": "ac19ecd0-e801-4a8f-b564-422683672808",
  "richText": "{\"root\":{\"children\":[{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"move the functions that make sense outside of \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}",
  "hasLoaded": true,
  "text": "move the functions that make sense outside of ",
  "conversation": [
    {
      "_v": 1,
      "type": 1,
      "attachedFoldersNew": [],
      "bubbleId": "a37eda56-0aeb-4509-86f3-56b16495ce61",
      "suggestedCodeBlocks": [],
      "relevantFiles": [
        "src/PaperCrane.tsx",
        "src/PaperCranes.puppeteer.test.ts",
        "public/index.html",
        "index.html",
        "README.md",
        "package.json"
      ],
      "capabilitiesRan": {
        "mutate-request": [
          6
        ],
        "start-submit-chat": [],
        "before-submit-chat": [
          15,
          17
        ],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-codeblock": [],
        "process-stream": [
          15,
          14
        ]
      },
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [],
      "isAgentic": true,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "humanChanges": [
        {
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "renderedDiffs": [
            {
              "startLineNumber": 1,
              "endLineNumberExclusive": 3,
              "beforeContextLines": [],
              "removedLines": [
                "import { useEffect, useRef } from \"preact/hooks\";",
                "import { RefObject } from \"preact\";"
              ],
              "addedLines": [
                "import { useEffect, useRef } from \"preact/hooks\"",
                "import { RefObject } from \"preact\""
              ],
              "afterContextLines": [
                "// @ts-ignore - No readily available types for htm/preact",
                "import { html } from \"htm/preact\"",
                "import * as twgl from \"twgl.js\"",
                "import { shaderWrapper } from \"./shader-wrapper.js\"",
                ""
              ]
            },
            {
              "startLineNumber": 4,
              "endLineNumberExclusive": 7,
              "beforeContextLines": [
                "import { useEffect, useRef } from \"preact/hooks\"",
                "import { RefObject } from \"preact\"",
                "// @ts-ignore - No readily available types for htm/preact"
              ],
              "removedLines": [
                "import { html } from \"htm/preact\";",
                "import * as twgl from \"twgl.js\";",
                "import { shaderWrapper } from \"./shader-transformers/shader-wrapper.js\";"
              ],
              "addedLines": [
                "import { html } from \"htm/preact\"",
                "import * as twgl from \"twgl.js\"",
                "import { shaderWrapper } from \"./shader-wrapper.js\""
              ],
              "afterContextLines": [
                "",
                "// Simple full-screen quad",
                "const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]",
                "",
                "const getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {"
              ]
            },
            {
              "startLineNumber": 9,
              "endLineNumberExclusive": 10,
              "beforeContextLines": [
                "import { html } from \"htm/preact\"",
                "import * as twgl from \"twgl.js\"",
                "import { shaderWrapper } from \"./shader-wrapper.js\"",
                "",
                "// Simple full-screen quad"
              ],
              "removedLines": [
                "const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0];"
              ],
              "addedLines": [
                "const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]"
              ],
              "afterContextLines": [
                "",
                "const getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {",
                "    return new Promise((resolve) => {",
                "        if (!gl) {",
                "            console.error(\"WebGL context not available for texture loading.\")"
              ]
            },
            {
              "startLineNumber": 14,
              "endLineNumberExclusive": 17,
              "beforeContextLines": [
                "const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]",
                "",
                "const getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {",
                "    return new Promise((resolve) => {",
                "        if (!gl) {"
              ],
              "removedLines": [
                "      console.error(\"WebGL context not available for texture loading.\");",
                "      resolve(null); // Resolve with null or a default texture if appropriate",
                "      return;"
              ],
              "addedLines": [
                "            console.error(\"WebGL context not available for texture loading.\")",
                "            resolve(null) // Resolve with null or a default texture if appropriate",
                "            return"
              ],
              "afterContextLines": [
                "        }",
                "        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)",
                "        const texture = twgl.createTexture(",
                "            gl,",
                "            {"
              ]
            },
            {
              "startLineNumber": 18,
              "endLineNumberExclusive": 19,
              "beforeContextLines": [
                "        if (!gl) {",
                "            console.error(\"WebGL context not available for texture loading.\")",
                "            resolve(null) // Resolve with null or a default texture if appropriate",
                "            return",
                "        }"
              ],
              "removedLines": [
                "    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);"
              ],
              "addedLines": [
                "        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)"
              ],
              "afterContextLines": [
                "        const texture = twgl.createTexture(",
                "            gl,",
                "            {",
                "                src: url,",
                "                crossOrigin: \"anonymous\","
              ]
            },
            {
              "startLineNumber": 26,
              "endLineNumberExclusive": 27,
              "beforeContextLines": [
                "            {",
                "                src: url,",
                "                crossOrigin: \"anonymous\",",
                "                min: gl.NEAREST,",
                "                mag: gl.NEAREST,"
              ],
              "removedLines": [
                "        wrap: gl.REPEAT,"
              ],
              "addedLines": [
                "                wrap: gl.REPEAT"
              ],
              "afterContextLines": [
                "            },",
                "            () => {",
                "                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)",
                "                resolve(texture)",
                "            }"
              ]
            },
            {
              "startLineNumber": 29,
              "endLineNumberExclusive": 35,
              "beforeContextLines": [
                "                min: gl.NEAREST,",
                "                mag: gl.NEAREST,",
                "                wrap: gl.REPEAT",
                "            },",
                "            () => {"
              ],
              "removedLines": [
                "        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);",
                "        resolve(texture);",
                "      },",
                "    );",
                "  });",
                "};"
              ],
              "addedLines": [
                "                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)",
                "                resolve(texture)",
                "            }",
                "        )",
                "    })",
                "}"
              ],
              "afterContextLines": [
                "",
                "// Define the structure for shader errors",
                "interface ShaderError {",
                "    lineNumber: number",
                "    message: string"
              ]
            },
            {
              "startLineNumber": 38,
              "endLineNumberExclusive": 40,
              "beforeContextLines": [
                "    })",
                "}",
                "",
                "// Define the structure for shader errors",
                "interface ShaderError {"
              ],
              "removedLines": [
                "  lineNumber: number;",
                "  message: string;"
              ],
              "addedLines": [
                "    lineNumber: number",
                "    message: string"
              ],
              "afterContextLines": [
                "}",
                "",
                "const handleShaderError = (",
                "    gl: WebGL2RenderingContext,",
                "    wrappedFragmentShader: string,"
              ]
            },
            {
              "startLineNumber": 42,
              "endLineNumberExclusive": 50,
              "beforeContextLines": [
                "interface ShaderError {",
                "    lineNumber: number",
                "    message: string",
                "}",
                ""
              ],
              "removedLines": [
                "const handleShaderError = (gl: WebGL2RenderingContext, wrappedFragmentShader: string, onError: ((error: ShaderError | null) => void) | undefined) => {",
                "  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);",
                "  gl.shaderSource(fragmentShader, wrappedFragmentShader);",
                "  gl.compileShader(fragmentShader);"
              ],
              "addedLines": [
                "const handleShaderError = (",
                "    gl: WebGL2RenderingContext,",
                "    wrappedFragmentShader: string,",
                "    onError: ((error: ShaderError | null) => void) | undefined",
                ") => {",
                "    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)",
                "    gl.shaderSource(fragmentShader, wrappedFragmentShader)",
                "    gl.compileShader(fragmentShader)"
              ],
              "afterContextLines": [
                "",
                "    let error = gl.getShaderInfoLog(fragmentShader)",
                "    if (typeof error === \"string\" && error.length > 0) {",
                "        // Continue processing string error",
                "    } else {"
              ]
            },
            {
              "startLineNumber": 51,
              "endLineNumberExclusive": 52,
              "beforeContextLines": [
                ") => {",
                "    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)",
                "    gl.shaderSource(fragmentShader, wrappedFragmentShader)",
                "    gl.compileShader(fragmentShader)",
                ""
              ],
              "removedLines": [
                "  let error = gl.getShaderInfoLog(fragmentShader);"
              ],
              "addedLines": [
                "    let error = gl.getShaderInfoLog(fragmentShader)"
              ],
              "afterContextLines": [
                "    if (typeof error === \"string\" && error.length > 0) {",
                "        // Continue processing string error",
                "    } else {",
                "        // Handle non-string or empty errors if necessary, maybe default message",
                "        error = \"Unknown shader compilation error\""
              ]
            },
            {
              "startLineNumber": 56,
              "endLineNumberExclusive": 57,
              "beforeContextLines": [
                "    let error = gl.getShaderInfoLog(fragmentShader)",
                "    if (typeof error === \"string\" && error.length > 0) {",
                "        // Continue processing string error",
                "    } else {",
                "        // Handle non-string or empty errors if necessary, maybe default message"
              ],
              "removedLines": [
                "    error = \"Unknown shader compilation error\";"
              ],
              "addedLines": [
                "        error = \"Unknown shader compilation error\""
              ],
              "afterContextLines": [
                "    }",
                "",
                "    gl.deleteShader(fragmentShader)",
                "",
                "    const wrappedLines = wrappedFragmentShader.split(\"\\n\")"
              ]
            },
            {
              "startLineNumber": 59,
              "endLineNumberExclusive": 60,
              "beforeContextLines": [
                "    } else {",
                "        // Handle non-string or empty errors if necessary, maybe default message",
                "        error = \"Unknown shader compilation error\"",
                "    }",
                ""
              ],
              "removedLines": [
                "  gl.deleteShader(fragmentShader);"
              ],
              "addedLines": [
                "    gl.deleteShader(fragmentShader)"
              ],
              "afterContextLines": [
                "",
                "    const wrappedLines = wrappedFragmentShader.split(\"\\n\")",
                "    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))",
                "",
                "    let message = \"Shader compilation failed.\""
              ]
            },
            {
              "startLineNumber": 61,
              "endLineNumberExclusive": 63,
              "beforeContextLines": [
                "        error = \"Unknown shader compilation error\"",
                "    }",
                "",
                "    gl.deleteShader(fragmentShader)",
                ""
              ],
              "removedLines": [
                "  const wrappedLines = wrappedFragmentShader.split(\"\\n\");",
                "  const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"));"
              ],
              "addedLines": [
                "    const wrappedLines = wrappedFragmentShader.split(\"\\n\")",
                "    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))"
              ],
              "afterContextLines": [
                "",
                "    let message = \"Shader compilation failed.\"",
                "    let lineNumber = 0",
                "    const errorMatch = error.match(/ERROR: \\d+:(\\d+): (.*)/)",
                "    if (errorMatch) {"
              ]
            },
            {
              "startLineNumber": 64,
              "endLineNumberExclusive": 67,
              "beforeContextLines": [
                "    gl.deleteShader(fragmentShader)",
                "",
                "    const wrappedLines = wrappedFragmentShader.split(\"\\n\")",
                "    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))",
                ""
              ],
              "removedLines": [
                "  let message = \"Shader compilation failed.\";",
                "  let lineNumber = 0;",
                "  const errorMatch = error.match(/ERROR: \\d+:(\\d+): (.*)/);"
              ],
              "addedLines": [
                "    let message = \"Shader compilation failed.\"",
                "    let lineNumber = 0",
                "    const errorMatch = error.match(/ERROR: \\d+:(\\d+): (.*)/)"
              ],
              "afterContextLines": [
                "    if (errorMatch) {",
                "        lineNumber = parseInt(errorMatch[1]) - headerLines - 1",
                "        message = errorMatch[2].trim()",
                "    } else {",
                "        // Fallback parsing if the main regex fails"
              ]
            },
            {
              "startLineNumber": 68,
              "endLineNumberExclusive": 70,
              "beforeContextLines": [
                "",
                "    let message = \"Shader compilation failed.\"",
                "    let lineNumber = 0",
                "    const errorMatch = error.match(/ERROR: \\d+:(\\d+): (.*)/)",
                "    if (errorMatch) {"
              ],
              "removedLines": [
                "    lineNumber = parseInt(errorMatch[1]) - headerLines - 1;",
                "    message = errorMatch[2].trim();"
              ],
              "addedLines": [
                "        lineNumber = parseInt(errorMatch[1]) - headerLines - 1",
                "        message = errorMatch[2].trim()"
              ],
              "afterContextLines": [
                "    } else {",
                "        // Fallback parsing if the main regex fails",
                "        const fallbackMatch = error.match(/ERROR: \\d+:(\\d+):/)",
                "        if (fallbackMatch) {",
                "            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1"
              ]
            },
            {
              "startLineNumber": 72,
              "endLineNumberExclusive": 73,
              "beforeContextLines": [
                "    if (errorMatch) {",
                "        lineNumber = parseInt(errorMatch[1]) - headerLines - 1",
                "        message = errorMatch[2].trim()",
                "    } else {",
                "        // Fallback parsing if the main regex fails"
              ],
              "removedLines": [
                "    const fallbackMatch = error.match(/ERROR: \\d+:(\\d+):/);"
              ],
              "addedLines": [
                "        const fallbackMatch = error.match(/ERROR: \\d+:(\\d+):/)"
              ],
              "afterContextLines": [
                "        if (fallbackMatch) {",
                "            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1",
                "        }",
                "        message = error.split(\":\").slice(3).join(\":\").trim() || error // Use full error if split fails",
                "    }"
              ]
            },
            {
              "startLineNumber": 74,
              "endLineNumberExclusive": 75,
              "beforeContextLines": [
                "        message = errorMatch[2].trim()",
                "    } else {",
                "        // Fallback parsing if the main regex fails",
                "        const fallbackMatch = error.match(/ERROR: \\d+:(\\d+):/)",
                "        if (fallbackMatch) {"
              ],
              "removedLines": [
                "      lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1;"
              ],
              "addedLines": [
                "            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1"
              ],
              "afterContextLines": [
                "        }",
                "        message = error.split(\":\").slice(3).join(\":\").trim() || error // Use full error if split fails",
                "    }",
                "",
                "    const errorDetails = { lineNumber, message }"
              ]
            },
            {
              "startLineNumber": 76,
              "endLineNumberExclusive": 77,
              "beforeContextLines": [
                "        // Fallback parsing if the main regex fails",
                "        const fallbackMatch = error.match(/ERROR: \\d+:(\\d+):/)",
                "        if (fallbackMatch) {",
                "            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1",
                "        }"
              ],
              "removedLines": [
                "    message = error.split(\":\").slice(3).join(\":\").trim() || error; // Use full error if split fails"
              ],
              "addedLines": [
                "        message = error.split(\":\").slice(3).join(\":\").trim() || error // Use full error if split fails"
              ],
              "afterContextLines": [
                "    }",
                "",
                "    const errorDetails = { lineNumber, message }",
                "    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)",
                "    onError?.(errorDetails) // Call the onError prop"
              ]
            },
            {
              "startLineNumber": 79,
              "endLineNumberExclusive": 83,
              "beforeContextLines": [
                "            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1",
                "        }",
                "        message = error.split(\":\").slice(3).join(\":\").trim() || error // Use full error if split fails",
                "    }",
                ""
              ],
              "removedLines": [
                "  const errorDetails = { lineNumber, message };",
                "  console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails);",
                "  onError?.(errorDetails); // Call the onError prop",
                "};"
              ],
              "addedLines": [
                "    const errorDetails = { lineNumber, message }",
                "    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)",
                "    onError?.(errorDetails) // Call the onError prop",
                "}"
              ],
              "afterContextLines": [
                "",
                "const calculateResolutionRatio = (",
                "    frameTime: number,",
                "    renderTimes: RefObject<number[]>,",
                "    lastResolutionRatio: number"
              ]
            },
            {
              "startLineNumber": 84,
              "endLineNumberExclusive": 93,
              "beforeContextLines": [
                "    const errorDetails = { lineNumber, message }",
                "    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)",
                "    onError?.(errorDetails) // Call the onError prop",
                "}",
                ""
              ],
              "removedLines": [
                "const calculateResolutionRatio = (frameTime: number, renderTimes: RefObject<number[]>, lastResolutionRatio: number): number => {",
                "  if (!renderTimes.current) return lastResolutionRatio; // Guard against null ref",
                "  renderTimes.current.push(frameTime);",
                "  if (renderTimes.current.length > 20) renderTimes.current.shift();",
                "  if (renderTimes.current.length < 20) return lastResolutionRatio;"
              ],
              "addedLines": [
                "const calculateResolutionRatio = (",
                "    frameTime: number,",
                "    renderTimes: RefObject<number[]>,",
                "    lastResolutionRatio: number",
                "): number => {",
                "    if (!renderTimes.current) return lastResolutionRatio // Guard against null ref",
                "    renderTimes.current.push(frameTime)",
                "    if (renderTimes.current.length > 20) renderTimes.current.shift()",
                "    if (renderTimes.current.length < 20) return lastResolutionRatio"
              ],
              "afterContextLines": [
                "",
                "    const avgFrameTime = renderTimes.current.reduce((a, b) => a + b) / renderTimes.current.length",
                "",
                "    if (avgFrameTime > 50) return Math.max(0.5, lastResolutionRatio - 0.5)",
                "    if (avgFrameTime < 20 && lastResolutionRatio < 1) return Math.min(1, lastResolutionRatio + 0.1)"
              ]
            },
            {
              "startLineNumber": 94,
              "endLineNumberExclusive": 95,
              "beforeContextLines": [
                "    if (!renderTimes.current) return lastResolutionRatio // Guard against null ref",
                "    renderTimes.current.push(frameTime)",
                "    if (renderTimes.current.length > 20) renderTimes.current.shift()",
                "    if (renderTimes.current.length < 20) return lastResolutionRatio",
                ""
              ],
              "removedLines": [
                "  const avgFrameTime = renderTimes.current.reduce((a, b) => a + b) / renderTimes.current.length;"
              ],
              "addedLines": [
                "    const avgFrameTime = renderTimes.current.reduce((a, b) => a + b) / renderTimes.current.length"
              ],
              "afterContextLines": [
                "",
                "    if (avgFrameTime > 50) return Math.max(0.5, lastResolutionRatio - 0.5)",
                "    if (avgFrameTime < 20 && lastResolutionRatio < 1) return Math.min(1, lastResolutionRatio + 0.1)",
                "    return lastResolutionRatio",
                "}"
              ]
            },
            {
              "startLineNumber": 96,
              "endLineNumberExclusive": 100,
              "beforeContextLines": [
                "    if (renderTimes.current.length > 20) renderTimes.current.shift()",
                "    if (renderTimes.current.length < 20) return lastResolutionRatio",
                "",
                "    const avgFrameTime = renderTimes.current.reduce((a, b) => a + b) / renderTimes.current.length",
                ""
              ],
              "removedLines": [
                "  if (avgFrameTime > 50) return Math.max(0.5, lastResolutionRatio - 0.5);",
                "  if (avgFrameTime < 20 && lastResolutionRatio < 1) return Math.min(1, lastResolutionRatio + 0.1);",
                "  return lastResolutionRatio;",
                "};"
              ],
              "addedLines": [
                "    if (avgFrameTime > 50) return Math.max(0.5, lastResolutionRatio - 0.5)",
                "    if (avgFrameTime < 20 && lastResolutionRatio < 1) return Math.min(1, lastResolutionRatio + 0.1)",
                "    return lastResolutionRatio",
                "}"
              ],
              "afterContextLines": [
                "",
                "const askForWakeLock = async () => {",
                "    if (!navigator.wakeLock) return null",
                "    try {",
                "        return await navigator.wakeLock.request(\"screen\")"
              ]
            },
            {
              "startLineNumber": 102,
              "endLineNumberExclusive": 103,
              "beforeContextLines": [
                "    if (avgFrameTime < 20 && lastResolutionRatio < 1) return Math.min(1, lastResolutionRatio + 0.1)",
                "    return lastResolutionRatio",
                "}",
                "",
                "const askForWakeLock = async () => {"
              ],
              "removedLines": [
                "  if (!navigator.wakeLock) return null;"
              ],
              "addedLines": [
                "    if (!navigator.wakeLock) return null"
              ],
              "afterContextLines": [
                "    try {",
                "        return await navigator.wakeLock.request(\"screen\")",
                "    } catch (e) {",
                "        console.warn(\"Could not acquire wake lock:\", e)",
                "        return null"
              ]
            },
            {
              "startLineNumber": 104,
              "endLineNumberExclusive": 105,
              "beforeContextLines": [
                "}",
                "",
                "const askForWakeLock = async () => {",
                "    if (!navigator.wakeLock) return null",
                "    try {"
              ],
              "removedLines": [
                "    return await navigator.wakeLock.request(\"screen\");"
              ],
              "addedLines": [
                "        return await navigator.wakeLock.request(\"screen\")"
              ],
              "afterContextLines": [
                "    } catch (e) {",
                "        console.warn(\"Could not acquire wake lock:\", e)",
                "        return null",
                "    }",
                "}"
              ]
            },
            {
              "startLineNumber": 106,
              "endLineNumberExclusive": 109,
              "beforeContextLines": [
                "const askForWakeLock = async () => {",
                "    if (!navigator.wakeLock) return null",
                "    try {",
                "        return await navigator.wakeLock.request(\"screen\")",
                "    } catch (e) {"
              ],
              "removedLines": [
                "    console.warn(\"Could not acquire wake lock:\", e);",
                "    return null;"
              ],
              "addedLines": [
                "        console.warn(\"Could not acquire wake lock:\", e)",
                "        return null",
                "    }"
              ],
              "afterContextLines": [
                "}",
                "",
                "const defaultVertexShader = `#version 300 es",
                "in vec4 position;",
                "void main() {"
              ]
            },
            {
              "startLineNumber": 110,
              "endLineNumberExclusive": 110,
              "beforeContextLines": [
                "    } catch (e) {",
                "        console.warn(\"Could not acquire wake lock:\", e)",
                "        return null",
                "    }",
                "}"
              ],
              "removedLines": [
                "};"
              ],
              "addedLines": [],
              "afterContextLines": [
                "",
                "const defaultVertexShader = `#version 300 es",
                "in vec4 position;",
                "void main() {",
                "    gl_Position = position;"
              ]
            },
            {
              "startLineNumber": 115,
              "endLineNumberExclusive": 116,
              "beforeContextLines": [
                "",
                "const defaultVertexShader = `#version 300 es",
                "in vec4 position;",
                "void main() {",
                "    gl_Position = position;"
              ],
              "removedLines": [
                "}`;"
              ],
              "addedLines": [
                "}`"
              ],
              "afterContextLines": [
                "",
                "const resolveReferences = (uniforms) => {",
                "    const resolvedUniforms = { ...uniforms }",
                "    for (const [key, value] of Object.entries(resolvedUniforms)) {",
                "        if (typeof value !== \"string\") continue"
              ]
            },
            {
              "startLineNumber": 118,
              "endLineNumberExclusive": 119,
              "beforeContextLines": [
                "void main() {",
                "    gl_Position = position;",
                "}`",
                "",
                "const resolveReferences = (uniforms) => {"
              ],
              "removedLines": [
                "  const resolvedUniforms = { ...uniforms };"
              ],
              "addedLines": [
                "    const resolvedUniforms = { ...uniforms }"
              ],
              "afterContextLines": [
                "    for (const [key, value] of Object.entries(resolvedUniforms)) {",
                "        if (typeof value !== \"string\") continue",
                "",
                "        const resolvedValue = resolvedUniforms[value]",
                "        // Only resolve if the referenced key exists and is not the key itself"
              ]
            },
            {
              "startLineNumber": 120,
              "endLineNumberExclusive": 121,
              "beforeContextLines": [
                "}`",
                "",
                "const resolveReferences = (uniforms) => {",
                "    const resolvedUniforms = { ...uniforms }",
                "    for (const [key, value] of Object.entries(resolvedUniforms)) {"
              ],
              "removedLines": [
                "    if (typeof value !== \"string\") continue;"
              ],
              "addedLines": [
                "        if (typeof value !== \"string\") continue"
              ],
              "afterContextLines": [
                "",
                "        const resolvedValue = resolvedUniforms[value]",
                "        // Only resolve if the referenced key exists and is not the key itself",
                "        if (resolvedValue !== undefined && key !== value) {",
                "            resolvedUniforms[key] = resolvedValue"
              ]
            },
            {
              "startLineNumber": 122,
              "endLineNumberExclusive": 123,
              "beforeContextLines": [
                "const resolveReferences = (uniforms) => {",
                "    const resolvedUniforms = { ...uniforms }",
                "    for (const [key, value] of Object.entries(resolvedUniforms)) {",
                "        if (typeof value !== \"string\") continue",
                ""
              ],
              "removedLines": [
                "    const resolvedValue = resolvedUniforms[value];"
              ],
              "addedLines": [
                "        const resolvedValue = resolvedUniforms[value]"
              ],
              "afterContextLines": [
                "        // Only resolve if the referenced key exists and is not the key itself",
                "        if (resolvedValue !== undefined && key !== value) {",
                "            resolvedUniforms[key] = resolvedValue",
                "        } else if (resolvedValue === undefined) {",
                "            // Optional: Warn or handle unresolved references if necessary"
              ]
            },
            {
              "startLineNumber": 125,
              "endLineNumberExclusive": 126,
              "beforeContextLines": [
                "        if (typeof value !== \"string\") continue",
                "",
                "        const resolvedValue = resolvedUniforms[value]",
                "        // Only resolve if the referenced key exists and is not the key itself",
                "        if (resolvedValue !== undefined && key !== value) {"
              ],
              "removedLines": [
                "      resolvedUniforms[key] = resolvedValue;"
              ],
              "addedLines": [
                "            resolvedUniforms[key] = resolvedValue"
              ],
              "afterContextLines": [
                "        } else if (resolvedValue === undefined) {",
                "            // Optional: Warn or handle unresolved references if necessary",
                "            // console.warn(`Unresolved uniform reference: ${key} -> ${value}`);",
                "        }",
                "    }"
              ]
            },
            {
              "startLineNumber": 131,
              "endLineNumberExclusive": 133,
              "beforeContextLines": [
                "        } else if (resolvedValue === undefined) {",
                "            // Optional: Warn or handle unresolved references if necessary",
                "            // console.warn(`Unresolved uniform reference: ${key} -> ${value}`);",
                "        }",
                "    }"
              ],
              "removedLines": [
                "  return resolvedUniforms;",
                "};"
              ],
              "addedLines": [
                "    return resolvedUniforms",
                "}"
              ],
              "afterContextLines": [
                "",
                "// Define props for the component",
                "interface PaperCraneProps {",
                "    initialImageUrl: string",
                "    fullscreen?: boolean"
              ]
            },
            {
              "startLineNumber": 136,
              "endLineNumberExclusive": 141,
              "beforeContextLines": [
                "    return resolvedUniforms",
                "}",
                "",
                "// Define props for the component",
                "interface PaperCraneProps {"
              ],
              "removedLines": [
                "  initialImageUrl: string;",
                "  fullscreen?: boolean;",
                "  features?: Record<string, any>; // Keeping features flexible for now",
                "  fragmentShader: string;",
                "  onError?: (error: ShaderError | null) => void; // Add onError prop"
              ],
              "addedLines": [
                "    initialImageUrl: string",
                "    fullscreen?: boolean",
                "    features?: Record<string, any> // Keeping features flexible for now",
                "    fragmentShader: string",
                "    onError?: (error: ShaderError | null) => void // Add onError prop"
              ],
              "afterContextLines": [
                "}",
                "",
                "// Define WakeLockSentinel type if not globally available (or import if from lib)",
                "interface WakeLockSentinel extends EventTarget {",
                "    readonly released: boolean"
              ]
            },
            {
              "startLineNumber": 145,
              "endLineNumberExclusive": 149,
              "beforeContextLines": [
                "    onError?: (error: ShaderError | null) => void // Add onError prop",
                "}",
                "",
                "// Define WakeLockSentinel type if not globally available (or import if from lib)",
                "interface WakeLockSentinel extends EventTarget {"
              ],
              "removedLines": [
                "  readonly released: boolean;",
                "  readonly type: string;",
                "  release(): Promise<void>;",
                "  onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null;"
              ],
              "addedLines": [
                "    readonly released: boolean",
                "    readonly type: string",
                "    release(): Promise<void>",
                "    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null"
              ],
              "afterContextLines": [
                "}",
                "",
                "export const PaperCrane = ({",
                "    initialImageUrl,",
                "    fullscreen = false,"
              ]
            },
            {
              "startLineNumber": 151,
              "endLineNumberExclusive": 171,
              "beforeContextLines": [
                "    readonly type: string",
                "    release(): Promise<void>",
                "    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null",
                "}",
                ""
              ],
              "removedLines": [
                "export const PaperCrane = ({ initialImageUrl, fullscreen = false, features, fragmentShader, onError }: PaperCraneProps) => {",
                "  const canvasRef = useRef(null);",
                "  const glRef = useRef(null);",
                "  const programInfoRef = useRef(null);",
                "  const frameBuffersRef = useRef([]);",
                "  const bufferInfoRef = useRef(null);",
                "  const frameNumberRef = useRef(0);",
                "  const lastRenderRef = useRef(performance.now());",
                "  const renderTimesRef = useRef([]);",
                "  const resolutionRatioRef = useRef(1);",
                "  const lastFragmentShaderRef = useRef(null);",
                "  const initialTextureRef = useRef(null);",
                "  const animationFrameIdRef = useRef(null);",
                "  const wakeLockRef = useRef<WakeLockSentinel | null>(null);"
              ],
              "addedLines": [
                "export const PaperCrane = ({",
                "    initialImageUrl,",
                "    fullscreen = false,",
                "    features,",
                "    fragmentShader,",
                "    onError",
                "}: PaperCraneProps) => {",
                "    const canvasRef = useRef(null)",
                "    const glRef = useRef(null)",
                "    const programInfoRef = useRef(null)",
                "    const frameBuffersRef = useRef([])",
                "    const bufferInfoRef = useRef(null)",
                "    const frameNumberRef = useRef(0)",
                "    const lastRenderRef = useRef(performance.now())",
                "    const renderTimesRef = useRef([])",
                "    const resolutionRatioRef = useRef(1)",
                "    const lastFragmentShaderRef = useRef(null)",
                "    const initialTextureRef = useRef(null)",
                "    const animationFrameIdRef = useRef(null)",
                "    const wakeLockRef = useRef<WakeLockSentinel | null>(null)"
              ],
              "afterContextLines": [
                "",
                "    // Make props accessible in the raf loop without dependencies",
                "    const featuresRef = useRef(features)",
                "    const fragmentShaderRef = useRef(fragmentShader)",
                "    const onErrorRef = useRef(onError) // Ref for onError callback"
              ]
            },
            {
              "startLineNumber": 173,
              "endLineNumberExclusive": 176,
              "beforeContextLines": [
                "    const initialTextureRef = useRef(null)",
                "    const animationFrameIdRef = useRef(null)",
                "    const wakeLockRef = useRef<WakeLockSentinel | null>(null)",
                "",
                "    // Make props accessible in the raf loop without dependencies"
              ],
              "removedLines": [
                "  const featuresRef = useRef(features);",
                "  const fragmentShaderRef = useRef(fragmentShader);",
                "  const onErrorRef = useRef(onError); // Ref for onError callback"
              ],
              "addedLines": [
                "    const featuresRef = useRef(features)",
                "    const fragmentShaderRef = useRef(fragmentShader)",
                "    const onErrorRef = useRef(onError) // Ref for onError callback"
              ],
              "afterContextLines": [
                "",
                "    useEffect(() => {",
                "        featuresRef.current = features",
                "    }, [features])",
                "    useEffect(() => {"
              ]
            },
            {
              "startLineNumber": 178,
              "endLineNumberExclusive": 180,
              "beforeContextLines": [
                "    const featuresRef = useRef(features)",
                "    const fragmentShaderRef = useRef(fragmentShader)",
                "    const onErrorRef = useRef(onError) // Ref for onError callback",
                "",
                "    useEffect(() => {"
              ],
              "removedLines": [
                "    featuresRef.current = features;",
                "  }, [features]);"
              ],
              "addedLines": [
                "        featuresRef.current = features",
                "    }, [features])"
              ],
              "afterContextLines": [
                "    useEffect(() => {",
                "        fragmentShaderRef.current = fragmentShader",
                "    }, [fragmentShader])",
                "    useEffect(() => {",
                "        onErrorRef.current = onError // Update ref when onError prop changes"
              ]
            },
            {
              "startLineNumber": 181,
              "endLineNumberExclusive": 183,
              "beforeContextLines": [
                "",
                "    useEffect(() => {",
                "        featuresRef.current = features",
                "    }, [features])",
                "    useEffect(() => {"
              ],
              "removedLines": [
                "    fragmentShaderRef.current = fragmentShader;",
                "  }, [fragmentShader]);"
              ],
              "addedLines": [
                "        fragmentShaderRef.current = fragmentShader",
                "    }, [fragmentShader])"
              ],
              "afterContextLines": [
                "    useEffect(() => {",
                "        onErrorRef.current = onError // Update ref when onError prop changes",
                "    }, [onError])",
                "",
                "    useEffect(() => {"
              ]
            },
            {
              "startLineNumber": 184,
              "endLineNumberExclusive": 186,
              "beforeContextLines": [
                "    }, [features])",
                "    useEffect(() => {",
                "        fragmentShaderRef.current = fragmentShader",
                "    }, [fragmentShader])",
                "    useEffect(() => {"
              ],
              "removedLines": [
                "    onErrorRef.current = onError; // Update ref when onError prop changes",
                "  }, [onError]);"
              ],
              "addedLines": [
                "        onErrorRef.current = onError // Update ref when onError prop changes",
                "    }, [onError])"
              ],
              "afterContextLines": [
                "",
                "    useEffect(() => {",
                "        const canvas = canvasRef.current",
                "        if (!canvas) return",
                ""
              ]
            },
            {
              "startLineNumber": 188,
              "endLineNumberExclusive": 190,
              "beforeContextLines": [
                "    useEffect(() => {",
                "        onErrorRef.current = onError // Update ref when onError prop changes",
                "    }, [onError])",
                "",
                "    useEffect(() => {"
              ],
              "removedLines": [
                "    const canvas = canvasRef.current;",
                "    if (!canvas) return;"
              ],
              "addedLines": [
                "        const canvas = canvasRef.current",
                "        if (!canvas) return"
              ],
              "afterContextLines": [
                "",
                "        // Declare handleResize variable here",
                "        let handleResize: () => void",
                "",
                "        const initialize = async () => {"
              ]
            },
            {
              "startLineNumber": 192,
              "endLineNumberExclusive": 193,
              "beforeContextLines": [
                "    useEffect(() => {",
                "        const canvas = canvasRef.current",
                "        if (!canvas) return",
                "",
                "        // Declare handleResize variable here"
              ],
              "removedLines": [
                "    let handleResize: () => void;"
              ],
              "addedLines": [
                "        let handleResize: () => void"
              ],
              "afterContextLines": [
                "",
                "        const initialize = async () => {",
                "            wakeLockRef.current = await askForWakeLock()",
                "",
                "            const gl = canvas.getContext(\"webgl2\", {"
              ]
            },
            {
              "startLineNumber": 195,
              "endLineNumberExclusive": 196,
              "beforeContextLines": [
                "",
                "        // Declare handleResize variable here",
                "        let handleResize: () => void",
                "",
                "        const initialize = async () => {"
              ],
              "removedLines": [
                "      wakeLockRef.current = await askForWakeLock();"
              ],
              "addedLines": [
                "            wakeLockRef.current = await askForWakeLock()"
              ],
              "afterContextLines": [
                "",
                "            const gl = canvas.getContext(\"webgl2\", {",
                "                antialias: false,",
                "                powerPreference: \"high-performance\",",
                "                preserveDrawingBuffer: false, // Important for performance"
              ]
            },
            {
              "startLineNumber": 203,
              "endLineNumberExclusive": 205,
              "beforeContextLines": [
                "                antialias: false,",
                "                powerPreference: \"high-performance\",",
                "                preserveDrawingBuffer: false, // Important for performance",
                "                alpha: false,",
                "                depth: false,"
              ],
              "removedLines": [
                "        stencil: false,",
                "      });"
              ],
              "addedLines": [
                "                stencil: false",
                "            })"
              ],
              "afterContextLines": [
                "",
                "            if (!gl) {",
                "                console.error(\"WebGL2 not supported or context creation failed.\")",
                "                return",
                "            }"
              ]
            },
            {
              "startLineNumber": 207,
              "endLineNumberExclusive": 209,
              "beforeContextLines": [
                "                depth: false,",
                "                stencil: false",
                "            })",
                "",
                "            if (!gl) {"
              ],
              "removedLines": [
                "        console.error(\"WebGL2 not supported or context creation failed.\");",
                "        return;"
              ],
              "addedLines": [
                "                console.error(\"WebGL2 not supported or context creation failed.\")",
                "                return"
              ],
              "afterContextLines": [
                "            }",
                "            glRef.current = gl",
                "",
                "            // Define handleResize function INSIDE initialize (as before)",
                "            handleResize = () => {"
              ]
            },
            {
              "startLineNumber": 210,
              "endLineNumberExclusive": 211,
              "beforeContextLines": [
                "",
                "            if (!gl) {",
                "                console.error(\"WebGL2 not supported or context creation failed.\")",
                "                return",
                "            }"
              ],
              "removedLines": [
                "      glRef.current = gl;"
              ],
              "addedLines": [
                "            glRef.current = gl"
              ],
              "afterContextLines": [
                "",
                "            // Define handleResize function INSIDE initialize (as before)",
                "            handleResize = () => {",
                "                const currentGl = glRef.current",
                "                if (!currentGl) return"
              ]
            },
            {
              "startLineNumber": 214,
              "endLineNumberExclusive": 219,
              "beforeContextLines": [
                "            }",
                "            glRef.current = gl",
                "",
                "            // Define handleResize function INSIDE initialize (as before)",
                "            handleResize = () => {"
              ],
              "removedLines": [
                "        const currentGl = glRef.current;",
                "        if (!currentGl) return;",
                "        const width = window.innerWidth;",
                "        const height = window.innerHeight;",
                "        const currentResolutionRatio = resolutionRatioRef.current;"
              ],
              "addedLines": [
                "                const currentGl = glRef.current",
                "                if (!currentGl) return",
                "                const width = window.innerWidth",
                "                const height = window.innerHeight",
                "                const currentResolutionRatio = resolutionRatioRef.current"
              ],
              "afterContextLines": [
                "",
                "                const canvas = canvasRef.current // Get canvas ref",
                "                if (!canvas) return // Need canvas for resizing",
                "",
                "                canvas.width = width * currentResolutionRatio"
              ]
            },
            {
              "startLineNumber": 220,
              "endLineNumberExclusive": 222,
              "beforeContextLines": [
                "                if (!currentGl) return",
                "                const width = window.innerWidth",
                "                const height = window.innerHeight",
                "                const currentResolutionRatio = resolutionRatioRef.current",
                ""
              ],
              "removedLines": [
                "        const canvas = canvasRef.current; // Get canvas ref",
                "        if (!canvas) return; // Need canvas for resizing"
              ],
              "addedLines": [
                "                const canvas = canvasRef.current // Get canvas ref",
                "                if (!canvas) return // Need canvas for resizing"
              ],
              "afterContextLines": [
                "",
                "                canvas.width = width * currentResolutionRatio",
                "                canvas.height = height * currentResolutionRatio",
                "                currentGl.viewport(0, 0, currentGl.drawingBufferWidth, currentGl.drawingBufferHeight)",
                ""
              ]
            },
            {
              "startLineNumber": 223,
              "endLineNumberExclusive": 226,
              "beforeContextLines": [
                "                const currentResolutionRatio = resolutionRatioRef.current",
                "",
                "                const canvas = canvasRef.current // Get canvas ref",
                "                if (!canvas) return // Need canvas for resizing",
                ""
              ],
              "removedLines": [
                "        canvas.width = width * currentResolutionRatio;",
                "        canvas.height = height * currentResolutionRatio;",
                "        currentGl.viewport(0, 0, currentGl.drawingBufferWidth, currentGl.drawingBufferHeight);"
              ],
              "addedLines": [
                "                canvas.width = width * currentResolutionRatio",
                "                canvas.height = height * currentResolutionRatio",
                "                currentGl.viewport(0, 0, currentGl.drawingBufferWidth, currentGl.drawingBufferHeight)"
              ],
              "afterContextLines": [
                "",
                "                canvas.style.width = `${width}px`",
                "                canvas.style.height = `${height}px`",
                "",
                "                // Recreate framebuffers"
              ]
            },
            {
              "startLineNumber": 227,
              "endLineNumberExclusive": 229,
              "beforeContextLines": [
                "",
                "                canvas.width = width * currentResolutionRatio",
                "                canvas.height = height * currentResolutionRatio",
                "                currentGl.viewport(0, 0, currentGl.drawingBufferWidth, currentGl.drawingBufferHeight)",
                ""
              ],
              "removedLines": [
                "        canvas.style.width = `${width}px`;",
                "        canvas.style.height = `${height}px`;"
              ],
              "addedLines": [
                "                canvas.style.width = `${width}px`",
                "                canvas.style.height = `${height}px`"
              ],
              "afterContextLines": [
                "",
                "                // Recreate framebuffers",
                "                frameBuffersRef.current = [twgl.createFramebufferInfo(currentGl), twgl.createFramebufferInfo(currentGl)]",
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {"
              ]
            },
            {
              "startLineNumber": 231,
              "endLineNumberExclusive": 232,
              "beforeContextLines": [
                "",
                "                canvas.style.width = `${width}px`",
                "                canvas.style.height = `${height}px`",
                "",
                "                // Recreate framebuffers"
              ],
              "removedLines": [
                "        frameBuffersRef.current = [twgl.createFramebufferInfo(currentGl), twgl.createFramebufferInfo(currentGl)];"
              ],
              "addedLines": [
                "                frameBuffersRef.current = [twgl.createFramebufferInfo(currentGl), twgl.createFramebufferInfo(currentGl)]"
              ],
              "afterContextLines": [
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {",
                "                        const texture = fb.attachments[0]",
                "                        currentGl.bindTexture(currentGl.TEXTURE_2D, texture)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MIN_FILTER, currentGl.NEAREST)"
              ]
            },
            {
              "startLineNumber": 234,
              "endLineNumberExclusive": 240,
              "beforeContextLines": [
                "",
                "                // Recreate framebuffers",
                "                frameBuffersRef.current = [twgl.createFramebufferInfo(currentGl), twgl.createFramebufferInfo(currentGl)]",
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {"
              ],
              "removedLines": [
                "            const texture = fb.attachments[0];",
                "            currentGl.bindTexture(currentGl.TEXTURE_2D, texture);",
                "            currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MIN_FILTER, currentGl.NEAREST);",
                "            currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MAG_FILTER, currentGl.NEAREST);",
                "            currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_WRAP_S, currentGl.REPEAT);",
                "            currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_WRAP_T, currentGl.REPEAT);"
              ],
              "addedLines": [
                "                        const texture = fb.attachments[0]",
                "                        currentGl.bindTexture(currentGl.TEXTURE_2D, texture)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MIN_FILTER, currentGl.NEAREST)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MAG_FILTER, currentGl.NEAREST)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_WRAP_S, currentGl.REPEAT)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_WRAP_T, currentGl.REPEAT)"
              ],
              "afterContextLines": [
                "                    }",
                "                })",
                "            }",
                "",
                "            if (fullscreen) {"
              ]
            },
            {
              "startLineNumber": 241,
              "endLineNumberExclusive": 243,
              "beforeContextLines": [
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MIN_FILTER, currentGl.NEAREST)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_MAG_FILTER, currentGl.NEAREST)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_WRAP_S, currentGl.REPEAT)",
                "                        currentGl.texParameteri(currentGl.TEXTURE_2D, currentGl.TEXTURE_WRAP_T, currentGl.REPEAT)",
                "                    }"
              ],
              "removedLines": [
                "        });",
                "      };"
              ],
              "addedLines": [
                "                })",
                "            }"
              ],
              "afterContextLines": [
                "",
                "            if (fullscreen) {",
                "                window.addEventListener(\"resize\", handleResize)",
                "                handleResize() // Initial size setting",
                "                canvas.classList.add(\"fullscreen\")"
              ]
            },
            {
              "startLineNumber": 245,
              "endLineNumberExclusive": 248,
              "beforeContextLines": [
                "                    }",
                "                })",
                "            }",
                "",
                "            if (fullscreen) {"
              ],
              "removedLines": [
                "        window.addEventListener(\"resize\", handleResize);",
                "        handleResize(); // Initial size setting",
                "        canvas.classList.add(\"fullscreen\");"
              ],
              "addedLines": [
                "                window.addEventListener(\"resize\", handleResize)",
                "                handleResize() // Initial size setting",
                "                canvas.classList.add(\"fullscreen\")"
              ],
              "afterContextLines": [
                "            } else {",
                "                twgl.resizeCanvasToDisplaySize(canvas, resolutionRatioRef.current)",
                "                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)",
                "            }",
                ""
              ]
            },
            {
              "startLineNumber": 249,
              "endLineNumberExclusive": 251,
              "beforeContextLines": [
                "            if (fullscreen) {",
                "                window.addEventListener(\"resize\", handleResize)",
                "                handleResize() // Initial size setting",
                "                canvas.classList.add(\"fullscreen\")",
                "            } else {"
              ],
              "removedLines": [
                "        twgl.resizeCanvasToDisplaySize(canvas, resolutionRatioRef.current);",
                "        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);"
              ],
              "addedLines": [
                "                twgl.resizeCanvasToDisplaySize(canvas, resolutionRatioRef.current)",
                "                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)"
              ],
              "afterContextLines": [
                "            }",
                "",
                "            initialTextureRef.current = await getTexture(gl, initialImageUrl)",
                "            if (!initialTextureRef.current) {",
                "                console.error(\"Failed to load initial texture.\")"
              ]
            },
            {
              "startLineNumber": 253,
              "endLineNumberExclusive": 254,
              "beforeContextLines": [
                "            } else {",
                "                twgl.resizeCanvasToDisplaySize(canvas, resolutionRatioRef.current)",
                "                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)",
                "            }",
                ""
              ],
              "removedLines": [
                "      initialTextureRef.current = await getTexture(gl, initialImageUrl);"
              ],
              "addedLines": [
                "            initialTextureRef.current = await getTexture(gl, initialImageUrl)"
              ],
              "afterContextLines": [
                "            if (!initialTextureRef.current) {",
                "                console.error(\"Failed to load initial texture.\")",
                "                return // Stop initialization if texture failed",
                "            }",
                ""
              ]
            },
            {
              "startLineNumber": 255,
              "endLineNumberExclusive": 257,
              "beforeContextLines": [
                "                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)",
                "            }",
                "",
                "            initialTextureRef.current = await getTexture(gl, initialImageUrl)",
                "            if (!initialTextureRef.current) {"
              ],
              "removedLines": [
                "        console.error(\"Failed to load initial texture.\");",
                "        return; // Stop initialization if texture failed"
              ],
              "addedLines": [
                "                console.error(\"Failed to load initial texture.\")",
                "                return // Stop initialization if texture failed"
              ],
              "afterContextLines": [
                "            }",
                "",
                "            frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]",
                "            frameBuffersRef.current.forEach((fb) => {",
                "                if (fb) {"
              ]
            },
            {
              "startLineNumber": 259,
              "endLineNumberExclusive": 260,
              "beforeContextLines": [
                "            if (!initialTextureRef.current) {",
                "                console.error(\"Failed to load initial texture.\")",
                "                return // Stop initialization if texture failed",
                "            }",
                ""
              ],
              "removedLines": [
                "      frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)];"
              ],
              "addedLines": [
                "            frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]"
              ],
              "afterContextLines": [
                "            frameBuffersRef.current.forEach((fb) => {",
                "                if (fb) {",
                "                    // Check if framebuffer info was created successfully",
                "                    const texture = fb.attachments[0]",
                "                    gl.bindTexture(gl.TEXTURE_2D, texture)"
              ]
            },
            {
              "startLineNumber": 263,
              "endLineNumberExclusive": 269,
              "beforeContextLines": [
                "",
                "            frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]",
                "            frameBuffersRef.current.forEach((fb) => {",
                "                if (fb) {",
                "                    // Check if framebuffer info was created successfully"
              ],
              "removedLines": [
                "          const texture = fb.attachments[0];",
                "          gl.bindTexture(gl.TEXTURE_2D, texture);",
                "          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);",
                "          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);",
                "          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);",
                "          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);"
              ],
              "addedLines": [
                "                    const texture = fb.attachments[0]",
                "                    gl.bindTexture(gl.TEXTURE_2D, texture)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)"
              ],
              "afterContextLines": [
                "                }",
                "            })",
                "",
                "            bufferInfoRef.current = twgl.createBufferInfoFromArrays(gl, {",
                "                position: { data: positions, numComponents: 3 }"
              ]
            },
            {
              "startLineNumber": 270,
              "endLineNumberExclusive": 271,
              "beforeContextLines": [
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)",
                "                }"
              ],
              "removedLines": [
                "      });"
              ],
              "addedLines": [
                "            })"
              ],
              "afterContextLines": [
                "",
                "            bufferInfoRef.current = twgl.createBufferInfoFromArrays(gl, {",
                "                position: { data: positions, numComponents: 3 }",
                "            })",
                "            lastRenderRef.current = performance.now() // Reset timer just before starting loop"
              ]
            },
            {
              "startLineNumber": 272,
              "endLineNumberExclusive": 276,
              "beforeContextLines": [
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)",
                "                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)",
                "                }",
                "            })",
                ""
              ],
              "removedLines": [
                "      bufferInfoRef.current = twgl.createBufferInfoFromArrays(gl, { position: { data: positions, numComponents: 3 } });",
                "      lastRenderRef.current = performance.now(); // Reset timer just before starting loop"
              ],
              "addedLines": [
                "            bufferInfoRef.current = twgl.createBufferInfoFromArrays(gl, {",
                "                position: { data: positions, numComponents: 3 }",
                "            })",
                "            lastRenderRef.current = performance.now() // Reset timer just before starting loop"
              ],
              "afterContextLines": [
                "",
                "            const renderLoop = (time: number) => {",
                "                const gl = glRef.current",
                "                const currentFragmentShader = fragmentShaderRef.current",
                "                const currentFeatures = featuresRef.current"
              ]
            },
            {
              "startLineNumber": 278,
              "endLineNumberExclusive": 282,
              "beforeContextLines": [
                "                position: { data: positions, numComponents: 3 }",
                "            })",
                "            lastRenderRef.current = performance.now() // Reset timer just before starting loop",
                "",
                "            const renderLoop = (time: number) => {"
              ],
              "removedLines": [
                "        const gl = glRef.current;",
                "        const currentFragmentShader = fragmentShaderRef.current;",
                "        const currentFeatures = featuresRef.current;",
                "        const currentOnError = onErrorRef.current; // Get current onError from ref"
              ],
              "addedLines": [
                "                const gl = glRef.current",
                "                const currentFragmentShader = fragmentShaderRef.current",
                "                const currentFeatures = featuresRef.current",
                "                const currentOnError = onErrorRef.current // Get current onError from ref"
              ],
              "afterContextLines": [
                "",
                "                if (!gl || !bufferInfoRef.current || !currentFragmentShader) {",
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return // Skip frame if essential parts missing",
                "                }"
              ]
            },
            {
              "startLineNumber": 284,
              "endLineNumberExclusive": 286,
              "beforeContextLines": [
                "                const currentFragmentShader = fragmentShaderRef.current",
                "                const currentFeatures = featuresRef.current",
                "                const currentOnError = onErrorRef.current // Get current onError from ref",
                "",
                "                if (!gl || !bufferInfoRef.current || !currentFragmentShader) {"
              ],
              "removedLines": [
                "          animationFrameIdRef.current = requestAnimationFrame(renderLoop);",
                "          return; // Skip frame if essential parts missing"
              ],
              "addedLines": [
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return // Skip frame if essential parts missing"
              ],
              "afterContextLines": [
                "                }",
                "",
                "                // Shader Compilation / Update",
                "                if (currentFragmentShader !== lastFragmentShaderRef.current) {",
                "                    const wrappedFragmentShader = shaderWrapper(currentFragmentShader)"
              ]
            },
            {
              "startLineNumber": 290,
              "endLineNumberExclusive": 292,
              "beforeContextLines": [
                "                    return // Skip frame if essential parts missing",
                "                }",
                "",
                "                // Shader Compilation / Update",
                "                if (currentFragmentShader !== lastFragmentShaderRef.current) {"
              ],
              "removedLines": [
                "          const wrappedFragmentShader = shaderWrapper(currentFragmentShader);",
                "          const newProgramInfo = twgl.createProgramInfo(gl, [defaultVertexShader, wrappedFragmentShader]);"
              ],
              "addedLines": [
                "                    const wrappedFragmentShader = shaderWrapper(currentFragmentShader)",
                "                    const newProgramInfo = twgl.createProgramInfo(gl, [defaultVertexShader, wrappedFragmentShader])"
              ],
              "afterContextLines": [
                "",
                "                    if (!newProgramInfo?.program) {",
                "                        handleShaderError(gl, wrappedFragmentShader, currentOnError) // Pass onError callback",
                "                        programInfoRef.current = null // Invalidate current program",
                "                    } else {"
              ]
            },
            {
              "startLineNumber": 294,
              "endLineNumberExclusive": 296,
              "beforeContextLines": [
                "                if (currentFragmentShader !== lastFragmentShaderRef.current) {",
                "                    const wrappedFragmentShader = shaderWrapper(currentFragmentShader)",
                "                    const newProgramInfo = twgl.createProgramInfo(gl, [defaultVertexShader, wrappedFragmentShader])",
                "",
                "                    if (!newProgramInfo?.program) {"
              ],
              "removedLines": [
                "            handleShaderError(gl, wrappedFragmentShader, currentOnError); // Pass onError callback",
                "            programInfoRef.current = null; // Invalidate current program"
              ],
              "addedLines": [
                "                        handleShaderError(gl, wrappedFragmentShader, currentOnError) // Pass onError callback",
                "                        programInfoRef.current = null // Invalidate current program"
              ],
              "afterContextLines": [
                "                    } else {",
                "                        if (programInfoRef.current) {",
                "                            // Clean up old program resources AFTER new one is successfully compiled",
                "                            gl.deleteProgram(programInfoRef.current.program)",
                "                        }"
              ]
            },
            {
              "startLineNumber": 299,
              "endLineNumberExclusive": 300,
              "beforeContextLines": [
                "                        handleShaderError(gl, wrappedFragmentShader, currentOnError) // Pass onError callback",
                "                        programInfoRef.current = null // Invalidate current program",
                "                    } else {",
                "                        if (programInfoRef.current) {",
                "                            // Clean up old program resources AFTER new one is successfully compiled"
              ],
              "removedLines": [
                "              gl.deleteProgram(programInfoRef.current.program);"
              ],
              "addedLines": [
                "                            gl.deleteProgram(programInfoRef.current.program)"
              ],
              "afterContextLines": [
                "                        }",
                "                        programInfoRef.current = newProgramInfo",
                "                        gl.useProgram(newProgramInfo.program) // Use new program immediately",
                "                        currentOnError?.(null) // Clear error on success by calling with null",
                "                    }"
              ]
            },
            {
              "startLineNumber": 301,
              "endLineNumberExclusive": 304,
              "beforeContextLines": [
                "                    } else {",
                "                        if (programInfoRef.current) {",
                "                            // Clean up old program resources AFTER new one is successfully compiled",
                "                            gl.deleteProgram(programInfoRef.current.program)",
                "                        }"
              ],
              "removedLines": [
                "            programInfoRef.current = newProgramInfo;",
                "            gl.useProgram(newProgramInfo.program); // Use new program immediately",
                "            currentOnError?.(null); // Clear error on success by calling with null"
              ],
              "addedLines": [
                "                        programInfoRef.current = newProgramInfo",
                "                        gl.useProgram(newProgramInfo.program) // Use new program immediately",
                "                        currentOnError?.(null) // Clear error on success by calling with null"
              ],
              "afterContextLines": [
                "                    }",
                "                    lastFragmentShaderRef.current = currentFragmentShader // Update even on failure to prevent retrying same shader",
                "                }",
                "",
                "                if (!programInfoRef.current) {"
              ]
            },
            {
              "startLineNumber": 305,
              "endLineNumberExclusive": 306,
              "beforeContextLines": [
                "                        }",
                "                        programInfoRef.current = newProgramInfo",
                "                        gl.useProgram(newProgramInfo.program) // Use new program immediately",
                "                        currentOnError?.(null) // Clear error on success by calling with null",
                "                    }"
              ],
              "removedLines": [
                "          lastFragmentShaderRef.current = currentFragmentShader; // Update even on failure to prevent retrying same shader"
              ],
              "addedLines": [
                "                    lastFragmentShaderRef.current = currentFragmentShader // Update even on failure to prevent retrying same shader"
              ],
              "afterContextLines": [
                "                }",
                "",
                "                if (!programInfoRef.current) {",
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return // Skip rendering if program is invalid"
              ]
            },
            {
              "startLineNumber": 309,
              "endLineNumberExclusive": 311,
              "beforeContextLines": [
                "                    }",
                "                    lastFragmentShaderRef.current = currentFragmentShader // Update even on failure to prevent retrying same shader",
                "                }",
                "",
                "                if (!programInfoRef.current) {"
              ],
              "removedLines": [
                "          animationFrameIdRef.current = requestAnimationFrame(renderLoop);",
                "          return; // Skip rendering if program is invalid"
              ],
              "addedLines": [
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return // Skip rendering if program is invalid"
              ],
              "afterContextLines": [
                "                }",
                "",
                "                // Performance / Resolution Adjustment",
                "                const currentTime = performance.now()",
                "                const frameTime = currentTime - lastRenderRef.current"
              ]
            },
            {
              "startLineNumber": 314,
              "endLineNumberExclusive": 321,
              "beforeContextLines": [
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return // Skip rendering if program is invalid",
                "                }",
                "",
                "                // Performance / Resolution Adjustment"
              ],
              "removedLines": [
                "        const currentTime = performance.now();",
                "        const frameTime = currentTime - lastRenderRef.current;",
                "        const newResolutionRatio = calculateResolutionRatio(frameTime, renderTimesRef, resolutionRatioRef.current);"
              ],
              "addedLines": [
                "                const currentTime = performance.now()",
                "                const frameTime = currentTime - lastRenderRef.current",
                "                const newResolutionRatio = calculateResolutionRatio(",
                "                    frameTime,",
                "                    renderTimesRef,",
                "                    resolutionRatioRef.current",
                "                )"
              ],
              "afterContextLines": [
                "",
                "                if (newResolutionRatio !== resolutionRatioRef.current) {",
                "                    // Resize only if ratio changes and not fullscreen (fullscreen handles resize via event listener)",
                "                    if (!fullscreen) {",
                "                        twgl.resizeCanvasToDisplaySize(canvas, newResolutionRatio)"
              ]
            },
            {
              "startLineNumber": 325,
              "endLineNumberExclusive": 327,
              "beforeContextLines": [
                "                )",
                "",
                "                if (newResolutionRatio !== resolutionRatioRef.current) {",
                "                    // Resize only if ratio changes and not fullscreen (fullscreen handles resize via event listener)",
                "                    if (!fullscreen) {"
              ],
              "removedLines": [
                "            twgl.resizeCanvasToDisplaySize(canvas, newResolutionRatio);",
                "            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);"
              ],
              "addedLines": [
                "                        twgl.resizeCanvasToDisplaySize(canvas, newResolutionRatio)",
                "                        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)"
              ],
              "afterContextLines": [
                "                        // Need to recreate framebuffers if size changes",
                "                        frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]",
                "                        frameBuffersRef.current.forEach((fb) => {",
                "                            if (fb) {",
                "                                // Check if framebuffer info was created successfully"
              ]
            },
            {
              "startLineNumber": 328,
              "endLineNumberExclusive": 329,
              "beforeContextLines": [
                "                    // Resize only if ratio changes and not fullscreen (fullscreen handles resize via event listener)",
                "                    if (!fullscreen) {",
                "                        twgl.resizeCanvasToDisplaySize(canvas, newResolutionRatio)",
                "                        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)",
                "                        // Need to recreate framebuffers if size changes"
              ],
              "removedLines": [
                "            frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)];"
              ],
              "addedLines": [
                "                        frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]"
              ],
              "afterContextLines": [
                "                        frameBuffersRef.current.forEach((fb) => {",
                "                            if (fb) {",
                "                                // Check if framebuffer info was created successfully",
                "                                const texture = fb.attachments[0]",
                "                                gl.bindTexture(gl.TEXTURE_2D, texture)"
              ]
            },
            {
              "startLineNumber": 332,
              "endLineNumberExclusive": 338,
              "beforeContextLines": [
                "                        // Need to recreate framebuffers if size changes",
                "                        frameBuffersRef.current = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]",
                "                        frameBuffersRef.current.forEach((fb) => {",
                "                            if (fb) {",
                "                                // Check if framebuffer info was created successfully"
              ],
              "removedLines": [
                "                const texture = fb.attachments[0];",
                "                gl.bindTexture(gl.TEXTURE_2D, texture);",
                "                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);",
                "                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);",
                "                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);",
                "                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);"
              ],
              "addedLines": [
                "                                const texture = fb.attachments[0]",
                "                                gl.bindTexture(gl.TEXTURE_2D, texture)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)"
              ],
              "afterContextLines": [
                "                            }",
                "                        })",
                "                    }",
                "                    resolutionRatioRef.current = newResolutionRatio",
                "                    renderTimesRef.current = [] // Reset times after resize"
              ]
            },
            {
              "startLineNumber": 339,
              "endLineNumberExclusive": 340,
              "beforeContextLines": [
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)",
                "                            }"
              ],
              "removedLines": [
                "            });"
              ],
              "addedLines": [
                "                        })"
              ],
              "afterContextLines": [
                "                    }",
                "                    resolutionRatioRef.current = newResolutionRatio",
                "                    renderTimesRef.current = [] // Reset times after resize",
                "                }",
                "                lastRenderRef.current = currentTime"
              ]
            },
            {
              "startLineNumber": 341,
              "endLineNumberExclusive": 343,
              "beforeContextLines": [
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)",
                "                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)",
                "                            }",
                "                        })",
                "                    }"
              ],
              "removedLines": [
                "          resolutionRatioRef.current = newResolutionRatio;",
                "          renderTimesRef.current = []; // Reset times after resize"
              ],
              "addedLines": [
                "                    resolutionRatioRef.current = newResolutionRatio",
                "                    renderTimesRef.current = [] // Reset times after resize"
              ],
              "afterContextLines": [
                "                }",
                "                lastRenderRef.current = currentTime",
                "",
                "                // Drawing Logic",
                "                const frameNumber = frameNumberRef.current"
              ]
            },
            {
              "startLineNumber": 344,
              "endLineNumberExclusive": 345,
              "beforeContextLines": [
                "                        })",
                "                    }",
                "                    resolutionRatioRef.current = newResolutionRatio",
                "                    renderTimesRef.current = [] // Reset times after resize",
                "                }"
              ],
              "removedLines": [
                "        lastRenderRef.current = currentTime;"
              ],
              "addedLines": [
                "                lastRenderRef.current = currentTime"
              ],
              "afterContextLines": [
                "",
                "                // Drawing Logic",
                "                const frameNumber = frameNumberRef.current",
                "                const frame = frameBuffersRef.current[frameNumber % 2]",
                "                const prevFrame = frameBuffersRef.current[(frameNumber + 1) % 2]"
              ]
            },
            {
              "startLineNumber": 347,
              "endLineNumberExclusive": 350,
              "beforeContextLines": [
                "                    renderTimesRef.current = [] // Reset times after resize",
                "                }",
                "                lastRenderRef.current = currentTime",
                "",
                "                // Drawing Logic"
              ],
              "removedLines": [
                "        const frameNumber = frameNumberRef.current;",
                "        const frame = frameBuffersRef.current[frameNumber % 2];",
                "        const prevFrame = frameBuffersRef.current[(frameNumber + 1) % 2];"
              ],
              "addedLines": [
                "                const frameNumber = frameNumberRef.current",
                "                const frame = frameBuffersRef.current[frameNumber % 2]",
                "                const prevFrame = frameBuffersRef.current[(frameNumber + 1) % 2]"
              ],
              "afterContextLines": [
                "",
                "                // Ensure framebuffers are valid",
                "                if (!frame || !frame.framebuffer || !prevFrame || !prevFrame.attachments || !prevFrame.attachments[0]) {",
                "                    console.warn(\"Framebuffers not ready, skipping frame.\")",
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)"
              ]
            },
            {
              "startLineNumber": 353,
              "endLineNumberExclusive": 356,
              "beforeContextLines": [
                "                const frame = frameBuffersRef.current[frameNumber % 2]",
                "                const prevFrame = frameBuffersRef.current[(frameNumber + 1) % 2]",
                "",
                "                // Ensure framebuffers are valid",
                "                if (!frame || !frame.framebuffer || !prevFrame || !prevFrame.attachments || !prevFrame.attachments[0]) {"
              ],
              "removedLines": [
                "          console.warn(\"Framebuffers not ready, skipping frame.\");",
                "          animationFrameIdRef.current = requestAnimationFrame(renderLoop);",
                "          return;"
              ],
              "addedLines": [
                "                    console.warn(\"Framebuffers not ready, skipping frame.\")",
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return"
              ],
              "afterContextLines": [
                "                }",
                "",
                "                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)",
                "                gl.viewport(0, 0, frame.width, frame.height) // Set viewport to framebuffer size",
                ""
              ]
            },
            {
              "startLineNumber": 358,
              "endLineNumberExclusive": 360,
              "beforeContextLines": [
                "                    console.warn(\"Framebuffers not ready, skipping frame.\")",
                "                    animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "                    return",
                "                }",
                ""
              ],
              "removedLines": [
                "        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer);",
                "        gl.viewport(0, 0, frame.width, frame.height); // Set viewport to framebuffer size"
              ],
              "addedLines": [
                "                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)",
                "                gl.viewport(0, 0, frame.width, frame.height) // Set viewport to framebuffer size"
              ],
              "afterContextLines": [
                "",
                "                let uniforms = {",
                "                    iTime: time / 1000, // Convert ms to seconds",
                "                    iFrame: frameNumber,",
                "                    prevFrame: frameNumber === 0 ? initialTextureRef.current : prevFrame.attachments[0],"
              ]
            },
            {
              "startLineNumber": 367,
              "endLineNumberExclusive": 373,
              "beforeContextLines": [
                "                    iTime: time / 1000, // Convert ms to seconds",
                "                    iFrame: frameNumber,",
                "                    prevFrame: frameNumber === 0 ? initialTextureRef.current : prevFrame.attachments[0],",
                "                    initialFrame: initialTextureRef.current,",
                "                    iResolution: [frame.width, frame.height, 1], // z should be pixel aspect ratio, 1 is fine for now"
              ],
              "removedLines": [
                "          iMouse: [currentFeatures.touchX || 0, currentFeatures.touchY || 0, currentFeatures.touched ? 1 : 0, 0],"
              ],
              "addedLines": [
                "                    iMouse: [",
                "                        currentFeatures.touchX || 0,",
                "                        currentFeatures.touchY || 0,",
                "                        currentFeatures.touched ? 1 : 0,",
                "                        0",
                "                    ],"
              ],
              "afterContextLines": [
                "                    iChannel0: initialTextureRef.current,",
                "                    iChannel1: prevFrame.attachments[0],",
                "                    iChannel2: initialTextureRef.current, // Example: Reuse initial texture",
                "                    iChannel3: prevFrame.attachments[0], // Example: Reuse prev frame",
                "                    ...currentFeatures // Spread the latest features"
              ]
            },
            {
              "startLineNumber": 377,
              "endLineNumberExclusive": 379,
              "beforeContextLines": [
                "                    ],",
                "                    iChannel0: initialTextureRef.current,",
                "                    iChannel1: prevFrame.attachments[0],",
                "                    iChannel2: initialTextureRef.current, // Example: Reuse initial texture",
                "                    iChannel3: prevFrame.attachments[0], // Example: Reuse prev frame"
              ],
              "removedLines": [
                "          ...currentFeatures, // Spread the latest features",
                "        };"
              ],
              "addedLines": [
                "                    ...currentFeatures // Spread the latest features",
                "                }"
              ],
              "afterContextLines": [
                "                // Filter out null, undefined, and NaN values",
                "                let filteredUniforms: Record<string, any> = Object.fromEntries(",
                "                    Object.entries(uniforms).filter(",
                "                        ([, value]) =>",
                "                            value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))"
              ]
            },
            {
              "startLineNumber": 381,
              "endLineNumberExclusive": 386,
              "beforeContextLines": [
                "                    iChannel3: prevFrame.attachments[0], // Example: Reuse prev frame",
                "                    ...currentFeatures // Spread the latest features",
                "                }",
                "                // Filter out null, undefined, and NaN values",
                "                let filteredUniforms: Record<string, any> = Object.fromEntries("
              ],
              "removedLines": [
                "          Object.entries(uniforms).filter(([, value]) => value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))),",
                "        );"
              ],
              "addedLines": [
                "                    Object.entries(uniforms).filter(",
                "                        ([, value]) =>",
                "                            value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))",
                "                    )",
                "                )"
              ],
              "afterContextLines": [
                "                // Resolve uniform references (e.g., feature referencing another feature)",
                "                filteredUniforms = resolveReferences(filteredUniforms)",
                "",
                "                gl.useProgram(programInfoRef.current.program) // Ensure correct program is active",
                "                twgl.setBuffersAndAttributes(gl, programInfoRef.current, bufferInfoRef.current)"
              ]
            },
            {
              "startLineNumber": 387,
              "endLineNumberExclusive": 388,
              "beforeContextLines": [
                "                        ([, value]) =>",
                "                            value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))",
                "                    )",
                "                )",
                "                // Resolve uniform references (e.g., feature referencing another feature)"
              ],
              "removedLines": [
                "        filteredUniforms = resolveReferences(filteredUniforms);"
              ],
              "addedLines": [
                "                filteredUniforms = resolveReferences(filteredUniforms)"
              ],
              "afterContextLines": [
                "",
                "                gl.useProgram(programInfoRef.current.program) // Ensure correct program is active",
                "                twgl.setBuffersAndAttributes(gl, programInfoRef.current, bufferInfoRef.current)",
                "                // Pass the explicitly typed object to setUniforms",
                "                twgl.setUniforms(programInfoRef.current, filteredUniforms)"
              ]
            },
            {
              "startLineNumber": 389,
              "endLineNumberExclusive": 391,
              "beforeContextLines": [
                "                    )",
                "                )",
                "                // Resolve uniform references (e.g., feature referencing another feature)",
                "                filteredUniforms = resolveReferences(filteredUniforms)",
                ""
              ],
              "removedLines": [
                "        gl.useProgram(programInfoRef.current.program); // Ensure correct program is active",
                "        twgl.setBuffersAndAttributes(gl, programInfoRef.current, bufferInfoRef.current);"
              ],
              "addedLines": [
                "                gl.useProgram(programInfoRef.current.program) // Ensure correct program is active",
                "                twgl.setBuffersAndAttributes(gl, programInfoRef.current, bufferInfoRef.current)"
              ],
              "afterContextLines": [
                "                // Pass the explicitly typed object to setUniforms",
                "                twgl.setUniforms(programInfoRef.current, filteredUniforms)",
                "                twgl.drawBufferInfo(gl, bufferInfoRef.current)",
                "",
                "                // Blit to canvas"
              ]
            },
            {
              "startLineNumber": 392,
              "endLineNumberExclusive": 394,
              "beforeContextLines": [
                "                filteredUniforms = resolveReferences(filteredUniforms)",
                "",
                "                gl.useProgram(programInfoRef.current.program) // Ensure correct program is active",
                "                twgl.setBuffersAndAttributes(gl, programInfoRef.current, bufferInfoRef.current)",
                "                // Pass the explicitly typed object to setUniforms"
              ],
              "removedLines": [
                "        twgl.setUniforms(programInfoRef.current, filteredUniforms);",
                "        twgl.drawBufferInfo(gl, bufferInfoRef.current);"
              ],
              "addedLines": [
                "                twgl.setUniforms(programInfoRef.current, filteredUniforms)",
                "                twgl.drawBufferInfo(gl, bufferInfoRef.current)"
              ],
              "afterContextLines": [
                "",
                "                // Blit to canvas",
                "                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)",
                "                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null) // Bind default framebuffer",
                "                // Use drawingBufferWidth/Height for the destination size"
              ]
            },
            {
              "startLineNumber": 396,
              "endLineNumberExclusive": 398,
              "beforeContextLines": [
                "                // Pass the explicitly typed object to setUniforms",
                "                twgl.setUniforms(programInfoRef.current, filteredUniforms)",
                "                twgl.drawBufferInfo(gl, bufferInfoRef.current)",
                "",
                "                // Blit to canvas"
              ],
              "removedLines": [
                "        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer);",
                "        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null); // Bind default framebuffer"
              ],
              "addedLines": [
                "                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)",
                "                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null) // Bind default framebuffer"
              ],
              "afterContextLines": [
                "                // Use drawingBufferWidth/Height for the destination size",
                "                gl.blitFramebuffer(",
                "                    0,",
                "                    0,",
                "                    frame.width,"
              ]
            },
            {
              "startLineNumber": 409,
              "endLineNumberExclusive": 411,
              "beforeContextLines": [
                "                    0,",
                "                    0,",
                "                    gl.drawingBufferWidth,",
                "                    gl.drawingBufferHeight, // Destination rect",
                "                    gl.COLOR_BUFFER_BIT,"
              ],
              "removedLines": [
                "          gl.NEAREST,",
                "        );"
              ],
              "addedLines": [
                "                    gl.NEAREST",
                "                )"
              ],
              "afterContextLines": [
                "",
                "                frameNumberRef.current++",
                "                animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "            }",
                ""
              ]
            },
            {
              "startLineNumber": 412,
              "endLineNumberExclusive": 415,
              "beforeContextLines": [
                "                    gl.drawingBufferHeight, // Destination rect",
                "                    gl.COLOR_BUFFER_BIT,",
                "                    gl.NEAREST",
                "                )",
                ""
              ],
              "removedLines": [
                "        frameNumberRef.current++;",
                "        animationFrameIdRef.current = requestAnimationFrame(renderLoop);",
                "      };"
              ],
              "addedLines": [
                "                frameNumberRef.current++",
                "                animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "            }"
              ],
              "afterContextLines": [
                "",
                "            animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "        }",
                "",
                "        initialize().catch(console.error)"
              ]
            },
            {
              "startLineNumber": 416,
              "endLineNumberExclusive": 418,
              "beforeContextLines": [
                "",
                "                frameNumberRef.current++",
                "                animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "            }",
                ""
              ],
              "removedLines": [
                "      animationFrameIdRef.current = requestAnimationFrame(renderLoop);",
                "    };"
              ],
              "addedLines": [
                "            animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "        }"
              ],
              "afterContextLines": [
                "",
                "        initialize().catch(console.error)",
                "",
                "        // Cleanup function",
                "        return () => {"
              ]
            },
            {
              "startLineNumber": 419,
              "endLineNumberExclusive": 420,
              "beforeContextLines": [
                "            }",
                "",
                "            animationFrameIdRef.current = requestAnimationFrame(renderLoop)",
                "        }",
                ""
              ],
              "removedLines": [
                "    initialize().catch(console.error);"
              ],
              "addedLines": [
                "        initialize().catch(console.error)"
              ],
              "afterContextLines": [
                "",
                "        // Cleanup function",
                "        return () => {",
                "            if (animationFrameIdRef.current) {",
                "                cancelAnimationFrame(animationFrameIdRef.current)"
              ]
            },
            {
              "startLineNumber": 424,
              "endLineNumberExclusive": 425,
              "beforeContextLines": [
                "        initialize().catch(console.error)",
                "",
                "        // Cleanup function",
                "        return () => {",
                "            if (animationFrameIdRef.current) {"
              ],
              "removedLines": [
                "        cancelAnimationFrame(animationFrameIdRef.current);"
              ],
              "addedLines": [
                "                cancelAnimationFrame(animationFrameIdRef.current)"
              ],
              "afterContextLines": [
                "            }",
                "            if (wakeLockRef.current) {",
                "                wakeLockRef.current.release().catch((e) => console.warn(\"Could not release wake lock:\", e))",
                "            }",
                "            const gl = glRef.current"
              ]
            },
            {
              "startLineNumber": 427,
              "endLineNumberExclusive": 428,
              "beforeContextLines": [
                "        return () => {",
                "            if (animationFrameIdRef.current) {",
                "                cancelAnimationFrame(animationFrameIdRef.current)",
                "            }",
                "            if (wakeLockRef.current) {"
              ],
              "removedLines": [
                "        wakeLockRef.current.release().catch((e) => console.warn(\"Could not release wake lock:\", e));"
              ],
              "addedLines": [
                "                wakeLockRef.current.release().catch((e) => console.warn(\"Could not release wake lock:\", e))"
              ],
              "afterContextLines": [
                "            }",
                "            const gl = glRef.current",
                "            if (gl) {",
                "                if (programInfoRef.current) gl.deleteProgram(programInfoRef.current.program)",
                "                if (bufferInfoRef.current) {"
              ]
            },
            {
              "startLineNumber": 429,
              "endLineNumberExclusive": 430,
              "beforeContextLines": [
                "                cancelAnimationFrame(animationFrameIdRef.current)",
                "            }",
                "            if (wakeLockRef.current) {",
                "                wakeLockRef.current.release().catch((e) => console.warn(\"Could not release wake lock:\", e))",
                "            }"
              ],
              "removedLines": [
                "      const gl = glRef.current;"
              ],
              "addedLines": [
                "            const gl = glRef.current"
              ],
              "afterContextLines": [
                "            if (gl) {",
                "                if (programInfoRef.current) gl.deleteProgram(programInfoRef.current.program)",
                "                if (bufferInfoRef.current) {",
                "                    if (bufferInfoRef.current.indices) gl.deleteBuffer(bufferInfoRef.current.indices)",
                "                    Object.values(bufferInfoRef.current.attribs).forEach((attr) => {"
              ]
            },
            {
              "startLineNumber": 431,
              "endLineNumberExclusive": 432,
              "beforeContextLines": [
                "            if (wakeLockRef.current) {",
                "                wakeLockRef.current.release().catch((e) => console.warn(\"Could not release wake lock:\", e))",
                "            }",
                "            const gl = glRef.current",
                "            if (gl) {"
              ],
              "removedLines": [
                "        if (programInfoRef.current) gl.deleteProgram(programInfoRef.current.program);"
              ],
              "addedLines": [
                "                if (programInfoRef.current) gl.deleteProgram(programInfoRef.current.program)"
              ],
              "afterContextLines": [
                "                if (bufferInfoRef.current) {",
                "                    if (bufferInfoRef.current.indices) gl.deleteBuffer(bufferInfoRef.current.indices)",
                "                    Object.values(bufferInfoRef.current.attribs).forEach((attr) => {",
                "                        const bufferAttribute = attr as twgl.AttribInfo",
                "                        if (bufferAttribute.buffer) {"
              ]
            },
            {
              "startLineNumber": 433,
              "endLineNumberExclusive": 434,
              "beforeContextLines": [
                "            }",
                "            const gl = glRef.current",
                "            if (gl) {",
                "                if (programInfoRef.current) gl.deleteProgram(programInfoRef.current.program)",
                "                if (bufferInfoRef.current) {"
              ],
              "removedLines": [
                "          if (bufferInfoRef.current.indices) gl.deleteBuffer(bufferInfoRef.current.indices);"
              ],
              "addedLines": [
                "                    if (bufferInfoRef.current.indices) gl.deleteBuffer(bufferInfoRef.current.indices)"
              ],
              "afterContextLines": [
                "                    Object.values(bufferInfoRef.current.attribs).forEach((attr) => {",
                "                        const bufferAttribute = attr as twgl.AttribInfo",
                "                        if (bufferAttribute.buffer) {",
                "                            gl.deleteBuffer(bufferAttribute.buffer)",
                "                        }"
              ]
            },
            {
              "startLineNumber": 435,
              "endLineNumberExclusive": 436,
              "beforeContextLines": [
                "            if (gl) {",
                "                if (programInfoRef.current) gl.deleteProgram(programInfoRef.current.program)",
                "                if (bufferInfoRef.current) {",
                "                    if (bufferInfoRef.current.indices) gl.deleteBuffer(bufferInfoRef.current.indices)",
                "                    Object.values(bufferInfoRef.current.attribs).forEach((attr) => {"
              ],
              "removedLines": [
                "            const bufferAttribute = attr as twgl.AttribInfo;"
              ],
              "addedLines": [
                "                        const bufferAttribute = attr as twgl.AttribInfo"
              ],
              "afterContextLines": [
                "                        if (bufferAttribute.buffer) {",
                "                            gl.deleteBuffer(bufferAttribute.buffer)",
                "                        }",
                "                    })",
                "                }"
              ]
            },
            {
              "startLineNumber": 437,
              "endLineNumberExclusive": 438,
              "beforeContextLines": [
                "                if (bufferInfoRef.current) {",
                "                    if (bufferInfoRef.current.indices) gl.deleteBuffer(bufferInfoRef.current.indices)",
                "                    Object.values(bufferInfoRef.current.attribs).forEach((attr) => {",
                "                        const bufferAttribute = attr as twgl.AttribInfo",
                "                        if (bufferAttribute.buffer) {"
              ],
              "removedLines": [
                "              gl.deleteBuffer(bufferAttribute.buffer);"
              ],
              "addedLines": [
                "                            gl.deleteBuffer(bufferAttribute.buffer)"
              ],
              "afterContextLines": [
                "                        }",
                "                    })",
                "                }",
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {"
              ]
            },
            {
              "startLineNumber": 439,
              "endLineNumberExclusive": 440,
              "beforeContextLines": [
                "                    Object.values(bufferInfoRef.current.attribs).forEach((attr) => {",
                "                        const bufferAttribute = attr as twgl.AttribInfo",
                "                        if (bufferAttribute.buffer) {",
                "                            gl.deleteBuffer(bufferAttribute.buffer)",
                "                        }"
              ],
              "removedLines": [
                "          });"
              ],
              "addedLines": [
                "                    })"
              ],
              "afterContextLines": [
                "                }",
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {",
                "                        gl.deleteFramebuffer(fb.framebuffer)",
                "                        fb.attachments.forEach((attachment) => {"
              ]
            },
            {
              "startLineNumber": 443,
              "endLineNumberExclusive": 444,
              "beforeContextLines": [
                "                        }",
                "                    })",
                "                }",
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {"
              ],
              "removedLines": [
                "            gl.deleteFramebuffer(fb.framebuffer);"
              ],
              "addedLines": [
                "                        gl.deleteFramebuffer(fb.framebuffer)"
              ],
              "afterContextLines": [
                "                        fb.attachments.forEach((attachment) => {",
                "                            gl.deleteTexture(attachment)",
                "                        })",
                "                    }",
                "                })"
              ]
            },
            {
              "startLineNumber": 445,
              "endLineNumberExclusive": 447,
              "beforeContextLines": [
                "                }",
                "                frameBuffersRef.current.forEach((fb) => {",
                "                    if (fb) {",
                "                        gl.deleteFramebuffer(fb.framebuffer)",
                "                        fb.attachments.forEach((attachment) => {"
              ],
              "removedLines": [
                "              gl.deleteTexture(attachment);",
                "            });"
              ],
              "addedLines": [
                "                            gl.deleteTexture(attachment)",
                "                        })"
              ],
              "afterContextLines": [
                "                    }",
                "                })",
                "                if (initialTextureRef.current) gl.deleteTexture(initialTextureRef.current)",
                "            }",
                ""
              ]
            },
            {
              "startLineNumber": 448,
              "endLineNumberExclusive": 450,
              "beforeContextLines": [
                "                        gl.deleteFramebuffer(fb.framebuffer)",
                "                        fb.attachments.forEach((attachment) => {",
                "                            gl.deleteTexture(attachment)",
                "                        })",
                "                    }"
              ],
              "removedLines": [
                "        });",
                "        if (initialTextureRef.current) gl.deleteTexture(initialTextureRef.current);"
              ],
              "addedLines": [
                "                })",
                "                if (initialTextureRef.current) gl.deleteTexture(initialTextureRef.current)"
              ],
              "afterContextLines": [
                "            }",
                "",
                "            if (fullscreen) {",
                "                // handleResize should be accessible here now",
                "                window.removeEventListener(\"resize\", handleResize)"
              ]
            },
            {
              "startLineNumber": 454,
              "endLineNumberExclusive": 455,
              "beforeContextLines": [
                "                if (initialTextureRef.current) gl.deleteTexture(initialTextureRef.current)",
                "            }",
                "",
                "            if (fullscreen) {",
                "                // handleResize should be accessible here now"
              ],
              "removedLines": [
                "        window.removeEventListener(\"resize\", handleResize);"
              ],
              "addedLines": [
                "                window.removeEventListener(\"resize\", handleResize)"
              ],
              "afterContextLines": [
                "                if (canvasRef.current) {",
                "                    canvasRef.current.classList.remove(\"fullscreen\")",
                "                }",
                "            }",
                ""
              ]
            },
            {
              "startLineNumber": 456,
              "endLineNumberExclusive": 457,
              "beforeContextLines": [
                "",
                "            if (fullscreen) {",
                "                // handleResize should be accessible here now",
                "                window.removeEventListener(\"resize\", handleResize)",
                "                if (canvasRef.current) {"
              ],
              "removedLines": [
                "          canvasRef.current.classList.remove(\"fullscreen\");"
              ],
              "addedLines": [
                "                    canvasRef.current.classList.remove(\"fullscreen\")"
              ],
              "afterContextLines": [
                "                }",
                "            }",
                "",
                "            console.log(\"Visualizer cleaned up.\")",
                "        }"
              ]
            },
            {
              "startLineNumber": 460,
              "endLineNumberExclusive": 463,
              "beforeContextLines": [
                "                if (canvasRef.current) {",
                "                    canvasRef.current.classList.remove(\"fullscreen\")",
                "                }",
                "            }",
                ""
              ],
              "removedLines": [
                "      console.log(\"Visualizer cleaned up.\");",
                "    };",
                "  }, [initialImageUrl, fullscreen]); // Dependencies for setup/cleanup"
              ],
              "addedLines": [
                "            console.log(\"Visualizer cleaned up.\")",
                "        }",
                "    }, [initialImageUrl, fullscreen]) // Dependencies for setup/cleanup"
              ],
              "afterContextLines": [
                "",
                "    // Render just the canvas element, refs handle the rest",
                "    return html`<canvas ref=${canvasRef} />`",
                "}",
                ""
              ]
            },
            {
              "startLineNumber": 465,
              "endLineNumberExclusive": 467,
              "beforeContextLines": [
                "            console.log(\"Visualizer cleaned up.\")",
                "        }",
                "    }, [initialImageUrl, fullscreen]) // Dependencies for setup/cleanup",
                "",
                "    // Render just the canvas element, refs handle the rest"
              ],
              "removedLines": [
                "  return html`<canvas ref=${canvasRef} />`;",
                "};"
              ],
              "addedLines": [
                "    return html`<canvas ref=${canvasRef} />`",
                "}"
              ],
              "afterContextLines": [
                "",
                "// Original makeVisualizer might be kept for compatibility or removed",
                "// export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => { ... }",
                ""
              ]
            }
          ]
        }
      ],
      "summarizedComposers": [],
      "cursorRules": [],
      "contextPieces": [],
      "editTrailContexts": [],
      "allThinkingBlocks": [],
      "diffsSinceLastApply": [],
      "deletedFiles": [],
      "supportedTools": [
        1,
        3,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        14,
        15,
        17,
        20,
        19,
        21,
        22,
        23,
        24
      ],
      "tokenCount": {
        "inputTokens": 0,
        "outputTokens": 0
      },
      "richText": "{\"root\":{\"children\":[{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"use signals instead of hooks where possible. Make lots of small functions and keep testability in mind\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}",
      "text": "use signals instead of hooks where possible. Make lots of small functions and keep testability in mind",
      "tokenDetailsUpUntilHere": [
        {
          "relativeWorkspacePath": "/Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
          "count": 4039,
          "lineCount": 470
        }
      ],
      "tokenCountUpUntilHere": 4039,
      "context": {
        "notepads": [],
        "composers": [],
        "quotes": [],
        "selectedCommits": [],
        "selectedPullRequests": [],
        "selectedImages": [],
        "folderSelections": [],
        "fileSelections": [
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
              "external": "file:///Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
              "path": "/Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
              "scheme": "file"
            },
            "addedWithoutMention": true,
            "autoContext": true
          }
        ],
        "terminalFiles": [],
        "selections": [],
        "terminalSelections": [],
        "selectedDocs": [],
        "externalLinks": [],
        "cursorRules": [],
        "mentions": {
          "notepads": {},
          "composers": {},
          "quotes": {},
          "selectedCommits": {},
          "selectedPullRequests": {},
          "gitDiff": [],
          "gitDiffFromBranchToMain": [],
          "selectedImages": {},
          "usesCodebase": [],
          "useWeb": [],
          "folderSelections": {},
          "fileSelections": {},
          "terminalFiles": {},
          "selections": {},
          "terminalSelections": {},
          "selectedDocs": {},
          "externalLinks": {},
          "useLinterErrors": [],
          "useDiffReview": [],
          "useContextPicking": [],
          "useRememberThis": [],
          "diffHistory": [],
          "cursorRules": {}
        },
        "usesCodebase": false
      },
      "checkpointId": "a29b0464-da6d-4b35-87f3-b3dfee52a2c8",
      "unifiedMode": 2,
      "currentFileLocationData": {
        "relativeWorkspacePath": "src/PaperCrane.tsx",
        "lineNumber": 6,
        "text": "import { shaderWrapper } from \"./shader-wrapper.js\""
      },
      "capabilityStatuses": {
        "mutate-request": [],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": []
      }
    },
    {
      "_v": 1,
      "type": 2,
      "attachedFoldersNew": [],
      "bubbleId": "4fee0965-5a5e-473c-b14d-d6ba231ed165",
      "suggestedCodeBlocks": [],
      "relevantFiles": [],
      "capabilitiesRan": {
        "mutate-request": [
          6
        ],
        "start-submit-chat": [],
        "before-submit-chat": [
          15,
          17
        ],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-codeblock": [],
        "process-stream": [
          15,
          14
        ]
      },
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [],
      "isAgentic": false,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "humanChanges": [],
      "attachedHumanChanges": false,
      "summarizedComposers": [],
      "cursorRules": [],
      "contextPieces": [],
      "editTrailContexts": [],
      "allThinkingBlocks": [],
      "diffsSinceLastApply": [],
      "deletedFiles": [],
      "supportedTools": [],
      "tokenCount": {
        "inputTokens": 0,
        "outputTokens": 0
      },
      "codeBlocks": [],
      "text": "",
      "isChat": false,
      "timingInfo": {
        "clientStartTime": 1744176081370,
        "clientRpcSendTime": 1744176081404,
        "clientSettleTime": 1744176148346,
        "clientEndTime": 1744176148346
      },
      "intermediateChunks": [],
      "serverBubbleId": "d42b92ec-1d7a-4916-8e37-8696f254d92b",
      "usageUuid": "7297e943-98e5-4e6d-bb8d-03b9701085e4",
      "thinking": {
        "text": "The user wants to refactor the `PaperCrane` component in `src/PaperCrane.tsx` to use Preact Signals instead of Hooks (`useState`, `useEffect`, `useRef`) where appropriate.\nThey also emphasize creating smaller, testable functions.\n\n**Plan:**\n\n1.  **Identify State and Refs:** Go through the `PaperCrane` component and identify all uses of `useState`, `useEffect`, and `useRef`. Understand what state each hook manages and what side effects each `useEffect` handles.\n2.  **Replace `useRef` for Mutable State:** Replace `useRef` calls that hold mutable state directly related to the rendering logic or component lifecycle with `signal()`. Examples: `glRef`, `programInfoRef`, `frameBuffersRef`, `bufferInfoRef`, `frameNumberRef`, `lastRenderRef`, `renderTimesRef`, `resolutionRatioRef`, `lastFragmentShaderRef`, `initialTextureRef`, `animationFrameIdRef`, `wakeLockRef`, `featuresRef`, `fragmentShaderRef`, `onErrorRef`.\n3.  **Replace `useRef` for DOM Elements:** Keep `useRef` for the `canvasRef` as it's specifically for accessing the DOM element.\n4.  **Replace `useEffect` with `effect`:** Analyze the `useEffect` hooks.\n    *   The main `useEffect` hook sets up the WebGL context, event listeners, and the render loop. This complex setup and cleanup logic can be encapsulated within an `effect`. The dependencies (`initialImageUrl`, `fullscreen`) will trigger the effect to re-run if they change.\n    *   The `useEffect` hooks updating `featuresRef`, `fragmentShaderRef`, and `onErrorRef` can potentially be removed if the signals holding these values are directly accessed within the `effect` or render loop logic.\n5.  **Refactor Logic into Smaller Functions:** Break down the large `initialize` function and the `renderLoop` function into smaller, more focused functions.\n    *   `initializeWebGL`: Sets up the WebGL context.\n    *   `setupFramebuffers`: Creates and configures framebuffers.\n    *   `setupBuffers`: Creates vertex buffers.\n    *   `loadInitialTexture`: Loads the initial image texture.\n    *   `compileShaderProgram`: Compiles the shader program, handles errors.\n    *   `updateResolution`: Calculates and applies resolution changes.\n    *   `drawFrame`: Performs the actual drawing for a single frame.\n    *   `renderLoop`: The main animation loop function, orchestrating calls to other functions.\n    *   `cleanupWebGL`: Handles the cleanup of WebGL resources.\n6.  **Manage Side Effects with `effect`:** Use `effect` from `@preact/signals` to reactively handle side effects like setting up and tearing down the WebGL context, event listeners, and the animation loop based on signal changes (e.g., `initialImageUrl`, `fullscreen`, `fragmentShader`).\n7.  **Import Signals:** Add necessary imports from `@preact/signals`.\n8.  **Testing Considerations:** Ensure the new smaller functions are pure where possible or clearly manage their dependencies (like the GL context) passed as arguments, making them easier to test in isolation.\n\n**Step-by-step Implementation:**\n\n1.  **Add Imports:** Import `signal` and `effect` from `@preact/signals-core` (or `@preact/signals` if using Preact integration).\n2.  **Create Signals:** Replace `useRef` calls for state management with `signal()`.\n3.  **Refactor `useEffect` into `effect`:** Move the setup and cleanup logic from the main `useEffect` into an `effect`. The dependencies of the original `useEffect` (`initialImageUrl`, `fullscreen`) will implicitly become dependencies of the `effect` if their corresponding signals are accessed within the effect.\n4.  **Break Down Functions:** Implement the smaller functions identified in the planning phase. Pass necessary signals or their values as arguments.\n5.  **Update Render Loop:** Modify the `renderLoop` to read signal values (`signal.value`) instead of ref values (`ref.current`).\n6.  **Update Prop Handling:** Use signals for props that change (`features`, `fragmentShader`, `onError`) and access their `.value` within the `effect` and `renderLoop`.\n7.  **Cleanup Logic:** Ensure the cleanup logic within the `effect`'s return function correctly accesses signal values and disposes of resources.",
        "signature": ""
      },
      "thinkingDurationMs": 10604,
      "capabilityStatuses": {
        "mutate-request": [],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": []
      }
    },
    {
      "_v": 1,
      "type": 2,
      "attachedFoldersNew": [],
      "bubbleId": "f7d27faf-c17f-4002-8ae7-9e3288b5d34b",
      "suggestedCodeBlocks": [],
      "relevantFiles": [],
      "capabilitiesRan": {
        "mutate-request": [],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [
          18
        ],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [
          6
        ],
        "process-codeblock": [],
        "process-stream": []
      },
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [],
      "isAgentic": false,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "humanChanges": [],
      "attachedHumanChanges": false,
      "summarizedComposers": [],
      "cursorRules": [],
      "contextPieces": [],
      "editTrailContexts": [],
      "allThinkingBlocks": [],
      "diffsSinceLastApply": [],
      "deletedFiles": [],
      "supportedTools": [],
      "tokenCount": {
        "inputTokens": 8718,
        "outputTokens": 7465
      },
      "text": "Okay, I can help with that. Refactoring to use Signals and breaking down the logic into smaller, testable functions is a good approach for maintainability and clarity.\n\nHere's the plan:\n\n1.  **Introduce Signals:** Replace `useRef` hooks used for managing component state (like `frameNumber`, `resolutionRatio`, shader code, etc.) with `signal` from `@preact/signals-core`. We'll keep `useRef` for the `canvasRef` as it directly interacts with the DOM element.\n2.  **Refactor `useEffect`:** Convert the main `useEffect` hook responsible for WebGL initialization, render loop setup, and cleanup into an `effect` from `@preact/signals-core`. This effect will reactively run based on the signals it depends on (e.g., `initialImageUrl`, `fullscreen`).\n3.  **Extract Helper Functions:** Break down the monolithic `initialize` and `renderLoop` functions into smaller, more focused units like `initializeWebGL`, `compileShader`, `drawScene`, `updateResolution`, `cleanupWebGLResources`, etc. These functions will receive necessary state (often signal values) as arguments, improving testability.\n4.  **Update Logic:** Modify the component logic to read from and write to signals using `.value`.\n\nLet's start by modifying `src/PaperCrane.tsx`. I'll add the necessary imports, replace the refs with signals, and start restructuring the initialization and render loop logic.\n\n```typescript\nimport { effect, signal } from \"@preact/signals-core\" // Use signals\nimport { useRef } from \"preact/hooks\" // Keep useRef for DOM elements\nimport { RefObject } from \"preact\"\n// @ts-ignore - No readily available types for htm/preact\nimport { html } from \"htm/preact\"\nimport * as twgl from \"twgl.js\"\nimport { shaderWrapper } from \"./shader-wrapper.js\"\n\n// --- Helper Functions (To be potentially extracted further) ---\n\n// Simple full-screen quad\nconst positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]\n\nconst getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {\n    return new Promise((resolve) => {\n        if (!gl) {\n            console.error(\"WebGL context not available for texture loading.\")\n            resolve(null)\n            return\n        }\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)\n        const texture = twgl.createTexture(\n            gl,\n            {\n                src: url,\n                crossOrigin: \"anonymous\",\n                min: gl.NEAREST,\n                mag: gl.NEAREST,\n                wrap: gl.REPEAT\n            },\n            () => {\n                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)\n                resolve(texture)\n            }\n        )\n    })\n}\n\ninterface ShaderError {\n    lineNumber: number\n    message: string\n}\n\n// Function to compile shader and handle errors\nconst compileShaderAndHandleError = (\n    gl: WebGL2RenderingContext,\n    vertexSource: string,\n    fragmentSource: string,\n    onError: (error: ShaderError | null) => void\n): twgl.ProgramInfo | null => {\n    const wrappedFragmentShader = shaderWrapper(fragmentSource)\n    try {\n        // Try creating the program\n        const programInfo = twgl.createProgramInfo(gl, [vertexSource, wrappedFragmentShader])\n        if (!programInfo?.program) {\n            // This path might be redundant if createProgramInfo throws on shader compile error,\n            // but kept for safety. TWGL might handle linking errors here.\n            handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n            return null\n        }\n        onError(null) // Clear error on success\n        return programInfo\n    } catch (error) {\n        // Catch errors thrown by twgl during shader compilation\n        handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n        return null\n    }\n}\n\nconst handleShaderError = (\n    gl: WebGL2RenderingContext,\n    wrappedFragmentShader: string,\n    onError: ((error: ShaderError | null) => void) | undefined\n) => {\n    // We need to manually compile to get the detailed error log\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n    if (!fragmentShader) {\n        onError?.({ lineNumber: 0, message: \"Failed to create fragment shader object.\" })\n        return\n    }\n    gl.shaderSource(fragmentShader, wrappedFragmentShader)\n    gl.compileShader(fragmentShader)\n\n    let log = gl.getShaderInfoLog(fragmentShader)\n    if (typeof log !== \"string\" || log.length === 0) {\n        log = \"Unknown shader compilation error\" // Fallback message\n    }\n    gl.deleteShader(fragmentShader) // Clean up the shader object\n\n    // --- Error Parsing Logic (mostly unchanged) ---\n    const wrappedLines = wrappedFragmentShader.split(\"\\n\")\n    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))\n\n    let message = \"Shader compilation failed.\"\n    let lineNumber = 0\n    const errorMatch = log.match(/ERROR: \\d+:(\\d+): (.*)/)\n    if (errorMatch) {\n        lineNumber = parseInt(errorMatch[1]) - headerLines - 1\n        message = errorMatch[2].trim()\n    } else {\n        const fallbackMatch = log.match(/ERROR: \\d+:(\\d+):/)\n        if (fallbackMatch) {\n            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1\n        }\n        // Adjust message parsing to handle potential multiline logs or different formats\n        const errorParts = log.split(\":\")\n        message = errorParts.length > 3 ? errorParts.slice(3).join(\":\").trim() : log\n    }\n\n    const errorDetails = { lineNumber, message }\n    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)\n    onError?.(errorDetails) // Call the onError prop\n}\n\nconst calculateResolutionRatio = (frameTime: number, renderTimes: number[], currentRatio: number): number => {\n    const newRenderTimes = [...renderTimes, frameTime]\n    if (newRenderTimes.length > 20) newRenderTimes.shift()\n    if (newRenderTimes.length < 20) return currentRatio // Not enough data yet\n\n    const avgFrameTime = newRenderTimes.reduce((a, b) => a + b) / newRenderTimes.length\n\n    let nextRatio = currentRatio\n    if (avgFrameTime > 50) nextRatio = Math.max(0.5, currentRatio - 0.5)\n    else if (avgFrameTime < 20 && currentRatio < 1) nextRatio = Math.min(1, currentRatio + 0.1)\n\n    // Return the times array as well if we need to update it outside\n    return nextRatio\n}\n\n// Wrapper for render times update logic\nconst updateRenderTimes = (frameTime: number, renderTimesSignal: { value: number[] }): void => {\n    const currentTimes = renderTimesSignal.value\n    currentTimes.push(frameTime)\n    if (currentTimes.length > 20) {\n        currentTimes.shift()\n    }\n    // No need to assign back to signal.value if modifying the array in place\n    // renderTimesSignal.value = currentTimes; // This would create a new array and trigger effects unnecessarily\n}\n\nconst askForWakeLock = async (): Promise<WakeLockSentinel | null> => {\n    if (!navigator.wakeLock) return null\n    try {\n        return await navigator.wakeLock.request(\"screen\")\n    } catch (e) {\n        console.warn(\"Could not acquire wake lock:\", e)\n        return null\n    }\n}\n\nconst defaultVertexShader = `#version 300 es\nin vec4 position;\nvoid main() {\n    gl_Position = position;\n}`\n\nconst resolveUniformReferences = (uniforms: Record<string, any>): Record<string, any> => {\n    const resolvedUniforms = { ...uniforms }\n    for (const [key, value] of Object.entries(resolvedUniforms)) {\n        if (typeof value !== \"string\") continue\n\n        const referencedValue = resolvedUniforms[value]\n        if (referencedValue !== undefined && key !== value) {\n            resolvedUniforms[key] = referencedValue\n        } else if (referencedValue === undefined && key !== value) {\n            // console.warn(`Unresolved uniform reference: ${key} -> ${value}`);\n            // Decide how to handle: remove, set to default, etc.\n            // For now, let's remove it to avoid potential WebGL errors\n            delete resolvedUniforms[key]\n        }\n    }\n    return resolvedUniforms\n}\n\nconst filterInvalidUniforms = (uniforms: Record<string, any>): Record<string, any> => {\n    return Object.fromEntries(\n        Object.entries(uniforms).filter(\n            ([, value]) =>\n                value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))\n        )\n    )\n}\n\nconst createAndConfigureFramebuffers = (gl: WebGL2RenderingContext): twgl.FramebufferInfo[] => {\n    const framebuffers = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]\n    framebuffers.forEach((fb) => {\n        if (fb) {\n            const texture = fb.attachments[0]\n            gl.bindTexture(gl.TEXTURE_2D, texture)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)\n        } else {\n            console.error(\"Failed to create framebuffer.\")\n            // Handle error appropriately, maybe return empty array or throw\n        }\n    })\n    gl.bindTexture(gl.TEXTURE_2D, null) // Unbind texture\n    return framebuffers.filter((fb): fb is twgl.FramebufferInfo => fb !== null) // Filter out potential nulls\n}\n\nconst resizeCanvas = (\n    canvas: HTMLCanvasElement,\n    gl: WebGL2RenderingContext,\n    ratio: number,\n    isFullscreen: boolean\n) => {\n    let width = canvas.clientWidth\n    let height = canvas.clientHeight\n    if (isFullscreen) {\n        width = window.innerWidth\n        height = window.innerHeight\n    }\n\n    const newWidth = width * ratio\n    const newHeight = height * ratio\n\n    if (canvas.width !== newWidth || canvas.height !== newHeight) {\n        canvas.width = newWidth\n        canvas.height = newHeight\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)\n\n        if (isFullscreen) {\n            canvas.style.width = `${window.innerWidth}px`\n            canvas.style.height = `${window.innerHeight}px`\n        } else {\n            // For non-fullscreen, twgl.resizeCanvasToDisplaySize might be simpler\n            // twgl.resizeCanvasToDisplaySize(canvas, ratio); // Reconsider this based on exact needs\n        }\n        return true // Indicates resize happened\n    }\n    return false // No resize needed\n}\n\n// Define props for the component\ninterface PaperCraneProps {\n    initialImageUrl: string\n    fullscreen?: boolean\n    features?: Record<string, any>\n    fragmentShader: string\n    onError?: (error: ShaderError | null) => void\n}\n\n// Define WakeLockSentinel type\ninterface WakeLockSentinel extends EventTarget {\n    readonly released: boolean\n    readonly type: string\n    release(): Promise<void>\n    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null\n}\n\n// --- Component Implementation ---\n\nexport const PaperCrane = ({\n    initialImageUrl: initialImageUrlProp,\n    fullscreen: fullscreenProp = false,\n    features: featuresProp,\n    fragmentShader: fragmentShaderProp,\n    onError: onErrorProp\n}: PaperCraneProps) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n\n    // --- Signals for State ---\n    const glSignal = signal<WebGL2RenderingContext | null>(null)\n    const programInfoSignal = signal<twgl.ProgramInfo | null>(null)\n    const frameBuffersSignal = signal<twgl.FramebufferInfo[]>([])\n    const bufferInfoSignal = signal<twgl.BufferInfo | null>(null)\n    const frameNumberSignal = signal(0)\n    const lastRenderSignal = signal(performance.now())\n    const renderTimesSignal = signal<number[]>([])\n    const resolutionRatioSignal = signal(1)\n    const lastFragmentShaderSignal = signal<string | null>(null)\n    const initialTextureSignal = signal<WebGLTexture | null>(null)\n    const animationFrameIdSignal = signal<number | null>(null)\n    const wakeLockSignal = signal<WakeLockSentinel | null>(null)\n\n    // Signals for props to easily react to changes\n    const initialImageUrl = signal(initialImageUrlProp)\n    const fullscreen = signal(fullscreenProp)\n    const features = signal(featuresProp || {})\n    const fragmentShader = signal(fragmentShaderProp)\n    const onError = signal(onErrorProp)\n\n    // Update signals when props change\n    // Note: In strict signal usage, you might pass signals down directly,\n    // but this pattern is common for interfacing with prop-based systems.\n    effect(() => {\n        initialImageUrl.value = initialImageUrlProp\n    })\n    effect(() => {\n        fullscreen.value = fullscreenProp\n    })\n    effect(() => {\n        features.value = featuresProp || {}\n    })\n    effect(() => {\n        fragmentShader.value = fragmentShaderProp\n    })\n    effect(() => {\n        onError.value = onErrorProp\n    })\n\n    // Main setup and render loop effect\n    effect(() => {\n        const canvas = canvasRef.current\n        const currentInitialImageUrl = initialImageUrl.value\n        const currentFullscreen = fullscreen.value\n        const currentOnError = onError.value\n\n        if (!canvas) return\n\n        let handleResize: (() => void) | null = null\n        let isActive = true // Flag to prevent cleanup races\n\n        const initialize = async () => {\n            wakeLockSignal.value = await askForWakeLock()\n\n            const gl = canvas.getContext(\"webgl2\", {\n                antialias: false,\n                powerPreference: \"high-performance\",\n                preserveDrawingBuffer: false,\n                alpha: false,\n                depth: false,\n                stencil: false\n            })\n\n            if (!gl) {\n                console.error(\"WebGL2 not supported or context creation failed.\")\n                // Consider calling onError here\n                currentOnError?.({ lineNumber: 0, message: \"WebGL2 not supported\" })\n                return\n            }\n            glSignal.value = gl\n\n            // --- Buffer Setup ---\n            bufferInfoSignal.value = twgl.createBufferInfoFromArrays(gl, {\n                position: { data: positions, numComponents: 3 }\n            })\n\n            // --- Texture Loading ---\n            const tex = await getTexture(gl, currentInitialImageUrl)\n            if (!tex) {\n                console.error(\"Failed to load initial texture.\")\n                currentOnError?.({ lineNumber: 0, message: `Failed to load texture: ${currentInitialImageUrl}` })\n                // Clean up already created resources if texture fails\n                if (bufferInfoSignal.value) twgl.deleteBufferInfo(gl, bufferInfoSignal.value)\n                glSignal.value = null\n                return\n            }\n            initialTextureSignal.value = tex\n\n            // --- Resize Handling ---\n            handleResize = () => {\n                const currentGl = glSignal.value\n                const currentRatio = resolutionRatioSignal.value\n                const isFs = fullscreen.value // Read current fullscreen value\n                if (!currentGl || !canvas) return\n\n                const didResize = resizeCanvas(canvas, currentGl, currentRatio, isFs)\n\n                if (didResize) {\n                    // Recreate framebuffers on resize\n                    // Clean up old ones first\n                    frameBuffersSignal.value.forEach((fb) => gl.deleteFramebuffer(fb.framebuffer))\n                    frameBuffersSignal.value = createAndConfigureFramebuffers(currentGl)\n                }\n            }\n\n            if (currentFullscreen) {\n                canvas.classList.add(\"fullscreen\")\n                window.addEventListener(\"resize\", handleResize)\n            } else {\n                canvas.classList.remove(\"fullscreen\")\n                // Initial resize for non-fullscreen might need clientWidth/Height\n                canvas.style.width = '' // Reset styles if switching from fullscreen\n                canvas.style.height = ''\n            }\n            handleResize() // Initial size setting and framebuffer creation\n\n            // --- Initial Framebuffer Creation (if not done by resize) ---\n            if (frameBuffersSignal.value.length === 0) {\n                frameBuffersSignal.value = createAndConfigureFramebuffers(gl)\n            }\n            if (frameBuffersSignal.value.length < 2) {\n                 console.error(\"Failed to create sufficient framebuffers.\")\n                 currentOnError?.({ lineNumber: 0, message: \"Framebuffer creation failed\" })\n                 // Perform cleanup before returning\n                 cleanupWebGLResources()\n                 return\n            }\n\n\n            // --- Render Loop ---\n            lastRenderSignal.value = performance.now() // Reset timer\n            renderTimesSignal.value = [] // Reset render times\n\n            const renderLoop = (time: number) => {\n                if (!isActive) return // Stop loop if effect cleaned up\n\n                const gl = glSignal.value\n                const currentFragmentShader = fragmentShader.value // Read signal\n                const currentFeatures = features.value // Read signal\n                const currentOnErrorCallback = onError.value // Read signal\n\n                if (!gl || !bufferInfoSignal.value || !currentFragmentShader) {\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n                    return\n                }\n\n                // --- Shader Compilation ---\n                if (currentFragmentShader !== lastFragmentShaderSignal.value) {\n                    // Clean up old program *before* creating new one\n                    if (programInfoSignal.value) {\n                        gl.deleteProgram(programInfoSignal.value.program)\n                    }\n\n                    const newProgramInfo = compileShaderAndHandleError(\n                        gl,\n                        defaultVertexShader,\n                        currentFragmentShader,\n                        currentOnErrorCallback || (() => {}) // Provide a dummy callback if none exists\n                    )\n                    programInfoSignal.value = newProgramInfo // Update signal, even if null\n                    lastFragmentShaderSignal.value = currentFragmentShader // Update even on failure\n\n                    if (newProgramInfo) {\n                         gl.useProgram(newProgramInfo.program) // Use new program immediately\n                    }\n                }\n\n\n                // --- Early exit if shader failed ---\n                 if (!programInfoSignal.value) {\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return; // Skip rendering if program is invalid\n                 }\n\n                // --- Performance / Resolution Adjustment ---\n                const currentTime = performance.now()\n                const frameTime = currentTime - lastRenderSignal.value\n                updateRenderTimes(frameTime, renderTimesSignal) // Update times using helper\n                const newResolutionRatio = calculateResolutionRatio(\n                    frameTime,\n                    renderTimesSignal.value, // Pass current times array\n                    resolutionRatioSignal.value\n                )\n\n                if (newResolutionRatio !== resolutionRatioSignal.value) {\n                    resolutionRatioSignal.value = newResolutionRatio\n                    renderTimesSignal.value = [] // Reset times after ratio change\n\n                    // Trigger resize logic (which recreates framebuffers if needed)\n                    if (handleResize) handleResize()\n                }\n                lastRenderSignal.value = currentTime\n\n                // --- Drawing Logic ---\n                const frameNumber = frameNumberSignal.value\n                const framebuffers = frameBuffersSignal.value\n                // Ensure framebuffers are valid before proceeding\n                 if (framebuffers.length < 2 || !framebuffers[0] || !framebuffers[1]) {\n                    console.warn(\"Framebuffers not ready, skipping frame.\");\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                    return;\n                 }\n\n                const frame = framebuffers[frameNumber % 2]\n                const prevFrame = framebuffers[(frameNumber + 1) % 2]\n\n\n                // Check attachments explicitly\n                 if (!frame?.framebuffer || !prevFrame?.attachments?.[0]) {\n                     console.warn(\"Framebuffer attachments not ready, skipping frame.\");\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return;\n                 }\n\n\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)\n                gl.viewport(0, 0, frame.width, frame.height)\n\n                let uniforms = {\n                    iTime: time / 1000,\n                    iFrame: frameNumber,\n                    prevFrame: frameNumber === 0 ? initialTextureSignal.value : prevFrame.attachments[0],\n                    initialFrame: initialTextureSignal.value,\n                    iResolution: [frame.width, frame.height, 1],\n                    iMouse: [currentFeatures.touchX || 0, currentFeatures.touchY || 0, currentFeatures.touched ? 1 : 0, 0],\n                    iChannel0: initialTextureSignal.value,\n                    iChannel1: prevFrame.attachments[0],\n                    iChannel2: initialTextureSignal.value,\n                    iChannel3: prevFrame.attachments[0],\n                    ...currentFeatures\n                }\n\n                let processedUniforms = filterInvalidUniforms(uniforms)\n                processedUniforms = resolveUniformReferences(processedUniforms)\n\n\n                 gl.useProgram(programInfoSignal.value.program); // Ensure program is set (might have changed)\n                twgl.setBuffersAndAttributes(gl, programInfoSignal.value, bufferInfoSignal.value)\n                twgl.setUniforms(programInfoSignal.value, processedUniforms)\n                twgl.drawBufferInfo(gl, bufferInfoSignal.value)\n\n                // --- Blit to Canvas ---\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n                gl.blitFramebuffer(\n                    0, 0, frame.width, frame.height, // Source\n                    0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, // Destination\n                    gl.COLOR_BUFFER_BIT, gl.NEAREST\n                )\n\n                frameNumberSignal.value++ // Increment frame number\n                animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n            }\n\n            // Start the loop\n            animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n        }\n\n        // Function to clean up all resources\n        const cleanupWebGLResources = () => {\n             isActive = false // Signal render loop to stop\n            if (animationFrameIdSignal.value) {\n                cancelAnimationFrame(animationFrameIdSignal.value)\n                animationFrameIdSignal.value = null\n            }\n            if (wakeLockSignal.value) {\n                wakeLockSignal.value.release().catch((e) => console.warn(\"Could not release wake lock:\", e))\n                wakeLockSignal.value = null\n            }\n\n            const gl = glSignal.value\n            if (gl) {\n                 // Unbind everything\n                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                 gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n                 gl.bindTexture(gl.TEXTURE_2D, null);\n                 gl.useProgram(null);\n\n\n                // Delete resources using signals\n                if (programInfoSignal.value) gl.deleteProgram(programInfoSignal.value.program)\n                 if (bufferInfoSignal.value) {\n                     // Use TWGL helper for buffer cleanup if available and safe\n                     // twgl.deleteBufferInfo(gl, bufferInfoSignal.value); // Might be simpler? Check TWGL docs.\n                     // Manual cleanup:\n                     if (bufferInfoSignal.value.indices) gl.deleteBuffer(bufferInfoSignal.value.indices)\n                     Object.values(bufferInfoSignal.value.attribs || {}).forEach(attr => {\n                         if (attr.buffer) gl.deleteBuffer(attr.buffer);\n                     });\n                 }\n                frameBuffersSignal.value.forEach(fb => {\n                    if (fb) {\n                        gl.deleteFramebuffer(fb.framebuffer);\n                        // TWGL FramebufferInfo might manage attachment deletion, check docs.\n                        // If not, manually delete textures:\n                        fb.attachments?.forEach(attachment => gl.deleteTexture(attachment));\n                    }\n                });\n                if (initialTextureSignal.value) gl.deleteTexture(initialTextureSignal.value)\n\n                 // Attempt to lose context - helps release GPU resources faster sometimes\n                 const loseContextExt = gl.getExtension('WEBGL_lose_context');\n                 if (loseContextExt) {\n                     loseContextExt.loseContext();\n                 }\n\n            }\n\n            // Reset signals\n            glSignal.value = null\n            programInfoSignal.value = null\n            bufferInfoSignal.value = null\n            frameBuffersSignal.value = []\n            initialTextureSignal.value = null\n            lastFragmentShaderSignal.value = null\n             frameNumberSignal.value = 0\n             resolutionRatioSignal.value = 1 // Reset to default\n\n\n            // Clean up DOM and listeners\n            if (currentFullscreen && handleResize) {\n                window.removeEventListener(\"resize\", handleResize)\n            }\n            if (canvasRef.current) {\n                canvasRef.current.classList.remove(\"fullscreen\")\n                canvasRef.current.width = 1 // Minimize memory usage\n                canvasRef.current.height = 1\n            }\n\n\n            console.log(\"Visualizer cleaned up.\")\n        }\n\n\n        initialize().catch(err => {\n             console.error(\"Initialization failed:\", err);\n             currentOnError?.({ lineNumber: 0, message: `Initialization failed: ${err.message}` });\n             cleanupWebGLResources(); // Ensure cleanup happens on init error too\n         });\n\n\n        // Return the cleanup function for the effect\n        return () => {\n            cleanupWebGLResources()\n            // Remove resize listener specifically here if it was added\n            if (handleResize && fullscreen.peek()) { // Use peek to avoid dependency\n                window.removeEventListener(\"resize\", handleResize)\n            }\n        }\n    }, [\n        // Dependencies for the effect: changes here will trigger re-initialization\n        // initialImageUrl, // Handled by signal update effect\n        // fullscreen, // Handled by signal update effect\n        // No explicit dependencies needed as signals handle reactivity.\n        // The effect runs once, and internal logic uses signal.value.\n        // If re-initialization *is* desired on prop change, add signals here:\n        // initialImageUrl, fullscreen\n    ]) // Effect dependencies - re-run if these signals change\n\n    // Render the canvas element\n    return html`<canvas ref=${canvasRef} />`\n}\n\n```\n\nI'll apply this refactoring to your `src/PaperCrane.tsx` file. This includes:\n*   Adding `@preact/signals-core` import.\n*   Replacing state `useRef` calls with `signal`.\n*   Creating signals for props (`initialImageUrl`, `fullscreen`, etc.) and effects to update them.\n*   Replacing the main `useEffect` with `effect`.\n*   Extracting several helper functions (`compileShaderAndHandleError`, `createAndConfigureFramebuffers`, `resizeCanvas`, `filterInvalidUniforms`, `resolveUniformReferences`, `updateRenderTimes`).\n*   Refactoring the initialization and render loop logic to use signals and helper functions.\n*   Improving the cleanup logic.\n*   Adding more robust error handling during initialization and framebuffer creation.\n*   Adding explicit checks for framebuffer/attachment readiness in the render loop.\n*   Ensuring the shader program is cleaned up *before* attempting recompilation.\n*   Ensuring WebGL state (bindings",
      "usageUuid": "7297e943-98e5-4e6d-bb8d-03b9701085e4",
      "symbolLinks": [
        {
          "symbolName": "useRef",
          "symbolSearchString": "useRef",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 1
        },
        {
          "symbolName": "frameNumber",
          "symbolSearchString": "frameNumber",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 347
        },
        {
          "symbolName": "resolutionRatio",
          "symbolSearchString": "resolutionRatio",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 166
        },
        {
          "symbolName": "canvasRef",
          "symbolSearchString": "canvasRef",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 158
        },
        {
          "symbolName": "useEffect",
          "symbolSearchString": "useEffect",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 1
        },
        {
          "symbolName": "initialImageUrl",
          "symbolSearchString": "initialImageUrl",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 136
        },
        {
          "symbolName": "fullscreen",
          "symbolSearchString": "fullscreen",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 137
        },
        {
          "symbolName": "initialize",
          "symbolSearchString": "initialize",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 194
        },
        {
          "symbolName": "renderLoop",
          "symbolSearchString": "renderLoop",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 277
        },
        {
          "symbolName": "compileShader",
          "symbolSearchString": "compileShader",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 49
        },
        {
          "symbolName": ".value",
          "symbolSearchString": ".value",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 434
        },
        {
          "symbolName": "Failed to load texture: ${currentInitialImageUrl}",
          "symbolSearchString": "Failed",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 255
        },
        {
          "symbolName": "resizeCanvas",
          "symbolSearchString": "resizeCanvas",
          "relativeWorkspacePath": "src/PaperCrane.tsx",
          "roughLineNumber": 249
        }
      ],
      "fileLinks": [
        {
          "displayName": "src/PaperCrane.tsx",
          "relativeWorkspacePath": "src/PaperCrane.tsx"
        }
      ],
      "codeBlocks": [
        {
          "unregistered": true,
          "content": "import { effect, signal } from \"@preact/signals-core\" // Use signals\nimport { useRef } from \"preact/hooks\" // Keep useRef for DOM elements\nimport { RefObject } from \"preact\"\n// @ts-ignore - No readily available types for htm/preact\nimport { html } from \"htm/preact\"\nimport * as twgl from \"twgl.js\"\nimport { shaderWrapper } from \"./shader-wrapper.js\"\n\n// --- Helper Functions (To be potentially extracted further) ---\n\n// Simple full-screen quad\nconst positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0]\n\nconst getTexture = async (gl: WebGL2RenderingContext | null, url: string): Promise<WebGLTexture | null> => {\n    return new Promise((resolve) => {\n        if (!gl) {\n            console.error(\"WebGL context not available for texture loading.\")\n            resolve(null)\n            return\n        }\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)\n        const texture = twgl.createTexture(\n            gl,\n            {\n                src: url,\n                crossOrigin: \"anonymous\",\n                min: gl.NEAREST,\n                mag: gl.NEAREST,\n                wrap: gl.REPEAT\n            },\n            () => {\n                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false)\n                resolve(texture)\n            }\n        )\n    })\n}\n\ninterface ShaderError {\n    lineNumber: number\n    message: string\n}\n\n// Function to compile shader and handle errors\nconst compileShaderAndHandleError = (\n    gl: WebGL2RenderingContext,\n    vertexSource: string,\n    fragmentSource: string,\n    onError: (error: ShaderError | null) => void\n): twgl.ProgramInfo | null => {\n    const wrappedFragmentShader = shaderWrapper(fragmentSource)\n    try {\n        // Try creating the program\n        const programInfo = twgl.createProgramInfo(gl, [vertexSource, wrappedFragmentShader])\n        if (!programInfo?.program) {\n            // This path might be redundant if createProgramInfo throws on shader compile error,\n            // but kept for safety. TWGL might handle linking errors here.\n            handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n            return null\n        }\n        onError(null) // Clear error on success\n        return programInfo\n    } catch (error) {\n        // Catch errors thrown by twgl during shader compilation\n        handleShaderError(gl, wrappedFragmentShader, onError) // Reuse existing error handler logic\n        return null\n    }\n}\n\nconst handleShaderError = (\n    gl: WebGL2RenderingContext,\n    wrappedFragmentShader: string,\n    onError: ((error: ShaderError | null) => void) | undefined\n) => {\n    // We need to manually compile to get the detailed error log\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n    if (!fragmentShader) {\n        onError?.({ lineNumber: 0, message: \"Failed to create fragment shader object.\" })\n        return\n    }\n    gl.shaderSource(fragmentShader, wrappedFragmentShader)\n    gl.compileShader(fragmentShader)\n\n    let log = gl.getShaderInfoLog(fragmentShader)\n    if (typeof log !== \"string\" || log.length === 0) {\n        log = \"Unknown shader compilation error\" // Fallback message\n    }\n    gl.deleteShader(fragmentShader) // Clean up the shader object\n\n    // --- Error Parsing Logic (mostly unchanged) ---\n    const wrappedLines = wrappedFragmentShader.split(\"\\n\")\n    const headerLines = wrappedLines.findIndex((line) => line.includes(\"31CF3F64-9176-4686-9E52-E3CFEC21FE72\"))\n\n    let message = \"Shader compilation failed.\"\n    let lineNumber = 0\n    const errorMatch = log.match(/ERROR: \\d+:(\\d+): (.*)/)\n    if (errorMatch) {\n        lineNumber = parseInt(errorMatch[1]) - headerLines - 1\n        message = errorMatch[2].trim()\n    } else {\n        const fallbackMatch = log.match(/ERROR: \\d+:(\\d+):/)\n        if (fallbackMatch) {\n            lineNumber = parseInt(fallbackMatch[1]) - headerLines - 1\n        }\n        // Adjust message parsing to handle potential multiline logs or different formats\n        const errorParts = log.split(\":\")\n        message = errorParts.length > 3 ? errorParts.slice(3).join(\":\").trim() : log\n    }\n\n    const errorDetails = { lineNumber, message }\n    console.error(`Shader Error: Line ${lineNumber}: ${message}`, errorDetails)\n    onError?.(errorDetails) // Call the onError prop\n}\n\nconst calculateResolutionRatio = (frameTime: number, renderTimes: number[], currentRatio: number): number => {\n    const newRenderTimes = [...renderTimes, frameTime]\n    if (newRenderTimes.length > 20) newRenderTimes.shift()\n    if (newRenderTimes.length < 20) return currentRatio // Not enough data yet\n\n    const avgFrameTime = newRenderTimes.reduce((a, b) => a + b) / newRenderTimes.length\n\n    let nextRatio = currentRatio\n    if (avgFrameTime > 50) nextRatio = Math.max(0.5, currentRatio - 0.5)\n    else if (avgFrameTime < 20 && currentRatio < 1) nextRatio = Math.min(1, currentRatio + 0.1)\n\n    // Return the times array as well if we need to update it outside\n    return nextRatio\n}\n\n// Wrapper for render times update logic\nconst updateRenderTimes = (frameTime: number, renderTimesSignal: { value: number[] }): void => {\n    const currentTimes = renderTimesSignal.value\n    currentTimes.push(frameTime)\n    if (currentTimes.length > 20) {\n        currentTimes.shift()\n    }\n    // No need to assign back to signal.value if modifying the array in place\n    // renderTimesSignal.value = currentTimes; // This would create a new array and trigger effects unnecessarily\n}\n\nconst askForWakeLock = async (): Promise<WakeLockSentinel | null> => {\n    if (!navigator.wakeLock) return null\n    try {\n        return await navigator.wakeLock.request(\"screen\")\n    } catch (e) {\n        console.warn(\"Could not acquire wake lock:\", e)\n        return null\n    }\n}\n\nconst defaultVertexShader = `#version 300 es\nin vec4 position;\nvoid main() {\n    gl_Position = position;\n}`\n\nconst resolveUniformReferences = (uniforms: Record<string, any>): Record<string, any> => {\n    const resolvedUniforms = { ...uniforms }\n    for (const [key, value] of Object.entries(resolvedUniforms)) {\n        if (typeof value !== \"string\") continue\n\n        const referencedValue = resolvedUniforms[value]\n        if (referencedValue !== undefined && key !== value) {\n            resolvedUniforms[key] = referencedValue\n        } else if (referencedValue === undefined && key !== value) {\n            // console.warn(`Unresolved uniform reference: ${key} -> ${value}`);\n            // Decide how to handle: remove, set to default, etc.\n            // For now, let's remove it to avoid potential WebGL errors\n            delete resolvedUniforms[key]\n        }\n    }\n    return resolvedUniforms\n}\n\nconst filterInvalidUniforms = (uniforms: Record<string, any>): Record<string, any> => {\n    return Object.fromEntries(\n        Object.entries(uniforms).filter(\n            ([, value]) =>\n                value !== null && value !== undefined && !(typeof value === \"number\" && Number.isNaN(value))\n        )\n    )\n}\n\nconst createAndConfigureFramebuffers = (gl: WebGL2RenderingContext): twgl.FramebufferInfo[] => {\n    const framebuffers = [twgl.createFramebufferInfo(gl), twgl.createFramebufferInfo(gl)]\n    framebuffers.forEach((fb) => {\n        if (fb) {\n            const texture = fb.attachments[0]\n            gl.bindTexture(gl.TEXTURE_2D, texture)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)\n        } else {\n            console.error(\"Failed to create framebuffer.\")\n            // Handle error appropriately, maybe return empty array or throw\n        }\n    })\n    gl.bindTexture(gl.TEXTURE_2D, null) // Unbind texture\n    return framebuffers.filter((fb): fb is twgl.FramebufferInfo => fb !== null) // Filter out potential nulls\n}\n\nconst resizeCanvas = (\n    canvas: HTMLCanvasElement,\n    gl: WebGL2RenderingContext,\n    ratio: number,\n    isFullscreen: boolean\n) => {\n    let width = canvas.clientWidth\n    let height = canvas.clientHeight\n    if (isFullscreen) {\n        width = window.innerWidth\n        height = window.innerHeight\n    }\n\n    const newWidth = width * ratio\n    const newHeight = height * ratio\n\n    if (canvas.width !== newWidth || canvas.height !== newHeight) {\n        canvas.width = newWidth\n        canvas.height = newHeight\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)\n\n        if (isFullscreen) {\n            canvas.style.width = `${window.innerWidth}px`\n            canvas.style.height = `${window.innerHeight}px`\n        } else {\n            // For non-fullscreen, twgl.resizeCanvasToDisplaySize might be simpler\n            // twgl.resizeCanvasToDisplaySize(canvas, ratio); // Reconsider this based on exact needs\n        }\n        return true // Indicates resize happened\n    }\n    return false // No resize needed\n}\n\n// Define props for the component\ninterface PaperCraneProps {\n    initialImageUrl: string\n    fullscreen?: boolean\n    features?: Record<string, any>\n    fragmentShader: string\n    onError?: (error: ShaderError | null) => void\n}\n\n// Define WakeLockSentinel type\ninterface WakeLockSentinel extends EventTarget {\n    readonly released: boolean\n    readonly type: string\n    release(): Promise<void>\n    onrelease: ((this: WakeLockSentinel, ev: Event) => any) | null\n}\n\n// --- Component Implementation ---\n\nexport const PaperCrane = ({\n    initialImageUrl: initialImageUrlProp,\n    fullscreen: fullscreenProp = false,\n    features: featuresProp,\n    fragmentShader: fragmentShaderProp,\n    onError: onErrorProp\n}: PaperCraneProps) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n\n    // --- Signals for State ---\n    const glSignal = signal<WebGL2RenderingContext | null>(null)\n    const programInfoSignal = signal<twgl.ProgramInfo | null>(null)\n    const frameBuffersSignal = signal<twgl.FramebufferInfo[]>([])\n    const bufferInfoSignal = signal<twgl.BufferInfo | null>(null)\n    const frameNumberSignal = signal(0)\n    const lastRenderSignal = signal(performance.now())\n    const renderTimesSignal = signal<number[]>([])\n    const resolutionRatioSignal = signal(1)\n    const lastFragmentShaderSignal = signal<string | null>(null)\n    const initialTextureSignal = signal<WebGLTexture | null>(null)\n    const animationFrameIdSignal = signal<number | null>(null)\n    const wakeLockSignal = signal<WakeLockSentinel | null>(null)\n\n    // Signals for props to easily react to changes\n    const initialImageUrl = signal(initialImageUrlProp)\n    const fullscreen = signal(fullscreenProp)\n    const features = signal(featuresProp || {})\n    const fragmentShader = signal(fragmentShaderProp)\n    const onError = signal(onErrorProp)\n\n    // Update signals when props change\n    // Note: In strict signal usage, you might pass signals down directly,\n    // but this pattern is common for interfacing with prop-based systems.\n    effect(() => {\n        initialImageUrl.value = initialImageUrlProp\n    })\n    effect(() => {\n        fullscreen.value = fullscreenProp\n    })\n    effect(() => {\n        features.value = featuresProp || {}\n    })\n    effect(() => {\n        fragmentShader.value = fragmentShaderProp\n    })\n    effect(() => {\n        onError.value = onErrorProp\n    })\n\n    // Main setup and render loop effect\n    effect(() => {\n        const canvas = canvasRef.current\n        const currentInitialImageUrl = initialImageUrl.value\n        const currentFullscreen = fullscreen.value\n        const currentOnError = onError.value\n\n        if (!canvas) return\n\n        let handleResize: (() => void) | null = null\n        let isActive = true // Flag to prevent cleanup races\n\n        const initialize = async () => {\n            wakeLockSignal.value = await askForWakeLock()\n\n            const gl = canvas.getContext(\"webgl2\", {\n                antialias: false,\n                powerPreference: \"high-performance\",\n                preserveDrawingBuffer: false,\n                alpha: false,\n                depth: false,\n                stencil: false\n            })\n\n            if (!gl) {\n                console.error(\"WebGL2 not supported or context creation failed.\")\n                // Consider calling onError here\n                currentOnError?.({ lineNumber: 0, message: \"WebGL2 not supported\" })\n                return\n            }\n            glSignal.value = gl\n\n            // --- Buffer Setup ---\n            bufferInfoSignal.value = twgl.createBufferInfoFromArrays(gl, {\n                position: { data: positions, numComponents: 3 }\n            })\n\n            // --- Texture Loading ---\n            const tex = await getTexture(gl, currentInitialImageUrl)\n            if (!tex) {\n                console.error(\"Failed to load initial texture.\")\n                currentOnError?.({ lineNumber: 0, message: `Failed to load texture: ${currentInitialImageUrl}` })\n                // Clean up already created resources if texture fails\n                if (bufferInfoSignal.value) twgl.deleteBufferInfo(gl, bufferInfoSignal.value)\n                glSignal.value = null\n                return\n            }\n            initialTextureSignal.value = tex\n\n            // --- Resize Handling ---\n            handleResize = () => {\n                const currentGl = glSignal.value\n                const currentRatio = resolutionRatioSignal.value\n                const isFs = fullscreen.value // Read current fullscreen value\n                if (!currentGl || !canvas) return\n\n                const didResize = resizeCanvas(canvas, currentGl, currentRatio, isFs)\n\n                if (didResize) {\n                    // Recreate framebuffers on resize\n                    // Clean up old ones first\n                    frameBuffersSignal.value.forEach((fb) => gl.deleteFramebuffer(fb.framebuffer))\n                    frameBuffersSignal.value = createAndConfigureFramebuffers(currentGl)\n                }\n            }\n\n            if (currentFullscreen) {\n                canvas.classList.add(\"fullscreen\")\n                window.addEventListener(\"resize\", handleResize)\n            } else {\n                canvas.classList.remove(\"fullscreen\")\n                // Initial resize for non-fullscreen might need clientWidth/Height\n                canvas.style.width = '' // Reset styles if switching from fullscreen\n                canvas.style.height = ''\n            }\n            handleResize() // Initial size setting and framebuffer creation\n\n            // --- Initial Framebuffer Creation (if not done by resize) ---\n            if (frameBuffersSignal.value.length === 0) {\n                frameBuffersSignal.value = createAndConfigureFramebuffers(gl)\n            }\n            if (frameBuffersSignal.value.length < 2) {\n                 console.error(\"Failed to create sufficient framebuffers.\")\n                 currentOnError?.({ lineNumber: 0, message: \"Framebuffer creation failed\" })\n                 // Perform cleanup before returning\n                 cleanupWebGLResources()\n                 return\n            }\n\n\n            // --- Render Loop ---\n            lastRenderSignal.value = performance.now() // Reset timer\n            renderTimesSignal.value = [] // Reset render times\n\n            const renderLoop = (time: number) => {\n                if (!isActive) return // Stop loop if effect cleaned up\n\n                const gl = glSignal.value\n                const currentFragmentShader = fragmentShader.value // Read signal\n                const currentFeatures = features.value // Read signal\n                const currentOnErrorCallback = onError.value // Read signal\n\n                if (!gl || !bufferInfoSignal.value || !currentFragmentShader) {\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n                    return\n                }\n\n                // --- Shader Compilation ---\n                if (currentFragmentShader !== lastFragmentShaderSignal.value) {\n                    // Clean up old program *before* creating new one\n                    if (programInfoSignal.value) {\n                        gl.deleteProgram(programInfoSignal.value.program)\n                    }\n\n                    const newProgramInfo = compileShaderAndHandleError(\n                        gl,\n                        defaultVertexShader,\n                        currentFragmentShader,\n                        currentOnErrorCallback || (() => {}) // Provide a dummy callback if none exists\n                    )\n                    programInfoSignal.value = newProgramInfo // Update signal, even if null\n                    lastFragmentShaderSignal.value = currentFragmentShader // Update even on failure\n\n                    if (newProgramInfo) {\n                         gl.useProgram(newProgramInfo.program) // Use new program immediately\n                    }\n                }\n\n\n                // --- Early exit if shader failed ---\n                 if (!programInfoSignal.value) {\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return; // Skip rendering if program is invalid\n                 }\n\n                // --- Performance / Resolution Adjustment ---\n                const currentTime = performance.now()\n                const frameTime = currentTime - lastRenderSignal.value\n                updateRenderTimes(frameTime, renderTimesSignal) // Update times using helper\n                const newResolutionRatio = calculateResolutionRatio(\n                    frameTime,\n                    renderTimesSignal.value, // Pass current times array\n                    resolutionRatioSignal.value\n                )\n\n                if (newResolutionRatio !== resolutionRatioSignal.value) {\n                    resolutionRatioSignal.value = newResolutionRatio\n                    renderTimesSignal.value = [] // Reset times after ratio change\n\n                    // Trigger resize logic (which recreates framebuffers if needed)\n                    if (handleResize) handleResize()\n                }\n                lastRenderSignal.value = currentTime\n\n                // --- Drawing Logic ---\n                const frameNumber = frameNumberSignal.value\n                const framebuffers = frameBuffersSignal.value\n                // Ensure framebuffers are valid before proceeding\n                 if (framebuffers.length < 2 || !framebuffers[0] || !framebuffers[1]) {\n                    console.warn(\"Framebuffers not ready, skipping frame.\");\n                    animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                    return;\n                 }\n\n                const frame = framebuffers[frameNumber % 2]\n                const prevFrame = framebuffers[(frameNumber + 1) % 2]\n\n\n                // Check attachments explicitly\n                 if (!frame?.framebuffer || !prevFrame?.attachments?.[0]) {\n                     console.warn(\"Framebuffer attachments not ready, skipping frame.\");\n                     animationFrameIdSignal.value = requestAnimationFrame(renderLoop);\n                     return;\n                 }\n\n\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)\n                gl.viewport(0, 0, frame.width, frame.height)\n\n                let uniforms = {\n                    iTime: time / 1000,\n                    iFrame: frameNumber,\n                    prevFrame: frameNumber === 0 ? initialTextureSignal.value : prevFrame.attachments[0],\n                    initialFrame: initialTextureSignal.value,\n                    iResolution: [frame.width, frame.height, 1],\n                    iMouse: [currentFeatures.touchX || 0, currentFeatures.touchY || 0, currentFeatures.touched ? 1 : 0, 0],\n                    iChannel0: initialTextureSignal.value,\n                    iChannel1: prevFrame.attachments[0],\n                    iChannel2: initialTextureSignal.value,\n                    iChannel3: prevFrame.attachments[0],\n                    ...currentFeatures\n                }\n\n                let processedUniforms = filterInvalidUniforms(uniforms)\n                processedUniforms = resolveUniformReferences(processedUniforms)\n\n\n                 gl.useProgram(programInfoSignal.value.program); // Ensure program is set (might have changed)\n                twgl.setBuffersAndAttributes(gl, programInfoSignal.value, bufferInfoSignal.value)\n                twgl.setUniforms(programInfoSignal.value, processedUniforms)\n                twgl.drawBufferInfo(gl, bufferInfoSignal.value)\n\n                // --- Blit to Canvas ---\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n                gl.blitFramebuffer(\n                    0, 0, frame.width, frame.height, // Source\n                    0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, // Destination\n                    gl.COLOR_BUFFER_BIT, gl.NEAREST\n                )\n\n                frameNumberSignal.value++ // Increment frame number\n                animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n            }\n\n            // Start the loop\n            animationFrameIdSignal.value = requestAnimationFrame(renderLoop)\n        }\n\n        // Function to clean up all resources\n        const cleanupWebGLResources = () => {\n             isActive = false // Signal render loop to stop\n            if (animationFrameIdSignal.value) {\n                cancelAnimationFrame(animationFrameIdSignal.value)\n                animationFrameIdSignal.value = null\n            }\n            if (wakeLockSignal.value) {\n                wakeLockSignal.value.release().catch((e) => console.warn(\"Could not release wake lock:\", e))\n                wakeLockSignal.value = null\n            }\n\n            const gl = glSignal.value\n            if (gl) {\n                 // Unbind everything\n                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                 gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n                 gl.bindTexture(gl.TEXTURE_2D, null);\n                 gl.useProgram(null);\n\n\n                // Delete resources using signals\n                if (programInfoSignal.value) gl.deleteProgram(programInfoSignal.value.program)\n                 if (bufferInfoSignal.value) {\n                     // Use TWGL helper for buffer cleanup if available and safe\n                     // twgl.deleteBufferInfo(gl, bufferInfoSignal.value); // Might be simpler? Check TWGL docs.\n                     // Manual cleanup:\n                     if (bufferInfoSignal.value.indices) gl.deleteBuffer(bufferInfoSignal.value.indices)\n                     Object.values(bufferInfoSignal.value.attribs || {}).forEach(attr => {\n                         if (attr.buffer) gl.deleteBuffer(attr.buffer);\n                     });\n                 }\n                frameBuffersSignal.value.forEach(fb => {\n                    if (fb) {\n                        gl.deleteFramebuffer(fb.framebuffer);\n                        // TWGL FramebufferInfo might manage attachment deletion, check docs.\n                        // If not, manually delete textures:\n                        fb.attachments?.forEach(attachment => gl.deleteTexture(attachment));\n                    }\n                });\n                if (initialTextureSignal.value) gl.deleteTexture(initialTextureSignal.value)\n\n                 // Attempt to lose context - helps release GPU resources faster sometimes\n                 const loseContextExt = gl.getExtension('WEBGL_lose_context');\n                 if (loseContextExt) {\n                     loseContextExt.loseContext();\n                 }\n\n            }\n\n            // Reset signals\n            glSignal.value = null\n            programInfoSignal.value = null\n            bufferInfoSignal.value = null\n            frameBuffersSignal.value = []\n            initialTextureSignal.value = null\n            lastFragmentShaderSignal.value = null\n             frameNumberSignal.value = 0\n             resolutionRatioSignal.value = 1 // Reset to default\n\n\n            // Clean up DOM and listeners\n            if (currentFullscreen && handleResize) {\n                window.removeEventListener(\"resize\", handleResize)\n            }\n            if (canvasRef.current) {\n                canvasRef.current.classList.remove(\"fullscreen\")\n                canvasRef.current.width = 1 // Minimize memory usage\n                canvasRef.current.height = 1\n            }\n\n\n            console.log(\"Visualizer cleaned up.\")\n        }\n\n\n        initialize().catch(err => {\n             console.error(\"Initialization failed:\", err);\n             currentOnError?.({ lineNumber: 0, message: `Initialization failed: ${err.message}` });\n             cleanupWebGLResources(); // Ensure cleanup happens on init error too\n         });\n\n\n        // Return the cleanup function for the effect\n        return () => {\n            cleanupWebGLResources()\n            // Remove resize listener specifically here if it was added\n            if (handleResize && fullscreen.peek()) { // Use peek to avoid dependency\n                window.removeEventListener(\"resize\", handleResize)\n            }\n        }\n    }, [\n        // Dependencies for the effect: changes here will trigger re-initialization\n        // initialImageUrl, // Handled by signal update effect\n        // fullscreen, // Handled by signal update effect\n        // No explicit dependencies needed as signals handle reactivity.\n        // The effect runs once, and internal logic uses signal.value.\n        // If re-initialization *is* desired on prop change, add signals here:\n        // initialImageUrl, fullscreen\n    ]) // Effect dependencies - re-run if these signals change\n\n    // Render the canvas element\n    return html`<canvas ref=${canvasRef} />`\n}\n",
          "languageId": "typescript",
          "isGenerating": false,
          "isClickable": false,
          "codeBlockIdx": 0
        }
      ],
      "capabilityStatuses": {
        "mutate-request": [],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": []
      }
    }
  ],
  "status": "completed",
  "context": {
    "notepads": [],
    "composers": [],
    "quotes": [],
    "selectedCommits": [],
    "selectedPullRequests": [],
    "selectedImages": [],
    "folderSelections": [],
    "fileSelections": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
          "external": "file:///Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
          "path": "/Users/redaphid/Projects/paper-crane/src/PaperCrane.tsx",
          "scheme": "file"
        },
        "addedWithoutMention": true,
        "autoContext": true
      }
    ],
    "selections": [],
    "terminalSelections": [],
    "selectedDocs": [],
    "externalLinks": [],
    "cursorRules": [],
    "mentions": {
      "notepads": {},
      "composers": {},
      "quotes": {},
      "selectedCommits": {},
      "selectedPullRequests": {},
      "gitDiff": [],
      "gitDiffFromBranchToMain": [],
      "selectedImages": {},
      "usesCodebase": [],
      "useWeb": [],
      "folderSelections": {},
      "fileSelections": {},
      "terminalFiles": {},
      "selections": {},
      "terminalSelections": {},
      "selectedDocs": {},
      "externalLinks": {},
      "useLinterErrors": [],
      "useDiffReview": [],
      "useContextPicking": [],
      "useRememberThis": [],
      "diffHistory": [],
      "cursorRules": {}
    }
  },
  "gitGraphFileSuggestions": [],
  "generatingBubbleIds": [],
  "isReadingLongFile": false,
  "codeBlockData": {},
  "originalModelLines": {},
  "newlyCreatedFiles": [],
  "newlyCreatedFolders": [],
  "lastUpdatedAt": 1744176081403,
  "createdAt": 1744176050767,
  "hasChangedContext": false,
  "capabilities": [
    {
      "type": 15,
      "data": {
        "bubbleDataMap": "{}"
      }
    },
    {
      "type": 17,
      "data": {}
    },
    {
      "type": 14,
      "data": {}
    },
    {
      "type": 22,
      "data": {}
    },
    {
      "type": 18,
      "data": {}
    },
    {
      "type": 19,
      "data": {}
    },
    {
      "type": 6,
      "data": {}
    },
    {
      "type": 16,
      "data": {}
    },
    {
      "type": 21,
      "data": {}
    }
  ],
  "name": "Best Practices: Signals and Testable Functions",
  "codebaseSearchSettings": {},
  "isFileListExpanded": false,
  "unifiedMode": "agent",
  "forceMode": "edit",
  "usageData": {},
  "latestConversationSummary": {
    "summary": {
      "summary": "\n- The user requested to refactor a React component to use signals instead of hooks, emphasizing the need for small functions and testability.\n- The assistant outlined a plan to implement the changes, including introducing signals, refactoring the `useEffect` into an `effect`, and extracting helper functions for better organization and testability.\n- The assistant provided a detailed code snippet that demonstrated the refactoring process, replacing hooks with signals, and restructuring the initialization and render loop logic.\n- The assistant highlighted improvements in error handling, cleanup logic, and the overall organization of the code to enhance maintainability and performance.\n- The conversation concluded with the assistant summarizing the changes made to the `src/PaperCrane.tsx` file, focusing on the transition to signals and the restructuring of the component for better testability and clarity.\n",
      "truncationLastBubbleIdInclusive": "f7d27faf-c17f-4002-8ae7-9e3288b5d34b",
      "clientShouldStartSendingFromInclusiveBubbleId": "a37eda56-0aeb-4509-86f3-56b16495ce61",
      "previousConversationSummaryBubbleId": "",
      "includesToolResults": false
    },
    "lastBubbleId": "f7d27faf-c17f-4002-8ae7-9e3288b5d34b"
  },
  "tokenCount": 4039,
  "latestChatGenerationUUID": "7297e943-98e5-4e6d-bb8d-03b9701085e4",
  "isAgentic": true
}