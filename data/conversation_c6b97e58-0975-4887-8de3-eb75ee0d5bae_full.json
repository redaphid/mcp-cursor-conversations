{
  "composerId": "c6b97e58-0975-4887-8de3-eb75ee0d5bae",
  "richText": "{\"root\":{\"children\":[{\"children\":[],\"direction\":null,\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":null,\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}",
  "hasLoaded": true,
  "text": "",
  "conversation": [
    {
      "type": 1,
      "bubbleId": "8277581d-7960-4eb5-a3ee-ad2507a2f275",
      "suggestedCodeBlocks": [],
      "relevantFiles": [
        "esbuild.js",
        "service-worker.js",
        "src/audio/WorkerRPC.js",
        "index.js",
        "shaders/redaphid/wip/psyche/knobs.frag",
        "package.json",
        "shaders/redaphid/wip/psyche/2.frag",
        "edit.js",
        "edit.html",
        "src/monaco.js"
      ],
      "capabilitiesRan": {
        "mutate-request": [
          11,
          14,
          6
        ],
        "start-submit-chat": [],
        "before-submit-chat": [
          15
        ],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [
          6
        ],
        "process-codeblock": [],
        "process-stream": [
          15
        ]
      },
      "editTrailContexts": [],
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [
        {
          "relativeWorkspacePath": "service-worker.js",
          "lineNumber": 6
        },
        {
          "relativeWorkspacePath": "service-worker.js",
          "lineNumber": 32
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 12
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 69
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 89
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 12
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 59
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 100
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 82
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 73
        },
        {
          "relativeWorkspacePath": "index.js",
          "lineNumber": 129
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 115
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 16
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 16
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 2
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 35
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 20
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 35
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 8
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 96
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 64
        },
        {
          "relativeWorkspacePath": "package.json",
          "lineNumber": 30
        },
        {
          "relativeWorkspacePath": "package.json",
          "lineNumber": 9
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 64
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 114
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 98
        },
        {
          "relativeWorkspacePath": "package.json",
          "lineNumber": 9
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 97
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 78
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 98
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 57
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 96
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 20
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 78
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/2.frag",
          "lineNumber": 11
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/2.frag",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/2.frag",
          "lineNumber": 16
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 77
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 89
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 91
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 14
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 115
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 69
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 114
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 87
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 27
        }
      ],
      "isAgentic": false,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "richText": "{\"root\":{\"children\":[{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"How do I totally clear the service worker cache in this \",\"type\":\"text\",\"version\":1},{\"detail\":1,\"format\":0,\"mode\":\"segmented\",\"style\":\"\",\"text\":\"@Codebase\",\"type\":\"mention\",\"version\":1,\"mentionName\":\"Codebase\",\"storedKey\":\"762\",\"metadata\":{\"selection\":{\"type\":0},\"selectedOption\":{\"key\":\"Codebase\",\"type\":\"codebase\",\"name\":\"Codebase\",\"picture\":{},\"_score\":9.15,\"isSlash\":false}}},{\"detail\":1,\"format\":0,\"mode\":\"segmented\",\"style\":\"\",\"text\":\"\",\"type\":\"text\",\"version\":1},{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\" \",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}",
      "text": "How do I totally clear the service worker cache in this @Codebase ",
      "context": {
        "editTrailContexts": [],
        "notepads": [],
        "quotes": [],
        "selectedCommits": [],
        "selectedPullRequests": [],
        "selectedImages": [],
        "usesCodebase": {
          "editTrailContexts": [],
          "notepads": [],
          "quotes": [],
          "selectedCommits": [],
          "selectedPullRequests": [],
          "selectedImages": [],
          "usesCodebase": true,
          "folderSelections": [],
          "fileSelections": [
            {
              "uri": {
                "$mid": 1,
                "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
                "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
                "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
                "scheme": "file"
              },
              "addedWithoutMention": true,
              "autoContext": true
            }
          ],
          "terminalFiles": [],
          "selections": [],
          "terminalSelections": [],
          "selectedDocs": [],
          "externalLinks": [],
          "diffHistory": {
            "files": [],
            "diffHistories": [],
            "uniqueId": "fc7c8c6b-64cc-47bf-8103-36a559aacbde"
          },
          "mentions": {
            "editTrailContexts": {},
            "notepads": {},
            "quotes": {},
            "selectedCommits": {},
            "selectedPullRequests": {},
            "gitDiff": [],
            "gitDiffFromBranchToMain": [],
            "selectedImages": {},
            "usesCodebase": [
              {
                "uuid": "762"
              }
            ],
            "useWeb": [],
            "folderSelections": {},
            "fileSelections": {},
            "terminalFiles": {},
            "selections": {},
            "terminalSelections": {},
            "selectedDocs": {},
            "externalLinks": {},
            "useLinterErrors": [],
            "useDiffReview": [],
            "useContextPicking": [],
            "useRememberThis": [],
            "diffHistory": []
          }
        },
        "folderSelections": [],
        "fileSelections": [
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
              "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
              "scheme": "file"
            },
            "addedWithoutMention": true,
            "autoContext": true
          }
        ],
        "terminalFiles": [],
        "selections": [],
        "terminalSelections": [],
        "selectedDocs": [],
        "externalLinks": [],
        "diffHistory": {
          "files": [],
          "diffHistories": [],
          "uniqueId": "fc7c8c6b-64cc-47bf-8103-36a559aacbde"
        },
        "mentions": {
          "editTrailContexts": {},
          "notepads": {},
          "quotes": {},
          "selectedCommits": {},
          "selectedPullRequests": {},
          "gitDiff": [],
          "gitDiffFromBranchToMain": [],
          "selectedImages": {},
          "usesCodebase": [
            {
              "uuid": "762"
            }
          ],
          "useWeb": [],
          "folderSelections": {},
          "fileSelections": {},
          "terminalFiles": {},
          "selections": {},
          "terminalSelections": {},
          "selectedDocs": {},
          "externalLinks": {},
          "useLinterErrors": [],
          "useDiffReview": [],
          "useContextPicking": [],
          "useRememberThis": [],
          "diffHistory": []
        }
      },
      "checkpoint": {
        "files": [
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/service-worker.js",
              "path": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": [],
            "isNewlyCreated": false
          },
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/index.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/index.js",
              "path": "/Users/redaphid/Projects/paper-cranes/index.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": [],
            "isNewlyCreated": false
          }
        ],
        "nonExistentFiles": [],
        "newlyCreatedFolders": [],
        "activeInlineDiffs": [],
        "inlineDiffNewlyCreatedResources": {
          "files": [],
          "folders": []
        }
      },
      "capabilityStatuses": {
        "mutate-request": [
          {
            "type": 14,
            "status": "completed"
          }
        ],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": []
      }
    },
    {
      "type": 2,
      "bubbleId": "71eb909d-8612-4648-8706-1be3db8b70df",
      "suggestedCodeBlocks": [],
      "relevantFiles": [],
      "capabilitiesRan": {
        "mutate-request": [
          11,
          14,
          6
        ],
        "start-submit-chat": [],
        "before-submit-chat": [
          15
        ],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [
          6
        ],
        "process-codeblock": [],
        "process-stream": [
          15
        ]
      },
      "editTrailContexts": [],
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [],
      "isAgentic": false,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "codeBlocks": [
        {
          "uri": {
            "$mid": 1,
            "fsPath": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
            "external": "file:///Users/redaphid/Projects/paper-cranes/service-worker.js",
            "path": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
            "scheme": "file"
          },
          "version": 0,
          "codeBlockIdx": 0
        },
        {
          "uri": {
            "$mid": 1,
            "fsPath": "/Users/redaphid/Projects/paper-cranes/index.js",
            "external": "file:///Users/redaphid/Projects/paper-cranes/index.js",
            "path": "/Users/redaphid/Projects/paper-cranes/index.js",
            "scheme": "file"
          },
          "version": 0,
          "codeBlockIdx": 1
        }
      ],
      "text": "Based on the codebase, I can help you clear the service worker cache. The cache name is defined as \"cranes-cache-v2\" in the esbuild.js configuration.\n\nHere are two approaches to clear the service worker cache:\n\n1. Add a function to the service-worker.js file to clear the cache:\n\n```javascript:service-worker.js\n// Add this after the existing event listeners\n\nself.addEventListener('message', async (event) => {\n    if (event.data === 'clearCache') {\n        try {\n            const cacheNames = await caches.keys()\n            await Promise.all(\n                cacheNames.map(cacheName => caches.delete(cacheName))\n            )\n            console.log('Cache cleared successfully')\n        } catch (error) {\n            console.error('Error clearing cache:', error)\n        }\n    }\n})\n```\n\n2. Then you can trigger the cache clearing from your application code by adding this function somewhere appropriate (like index.js):\n\n```javascript:index.js\nasync function clearServiceWorkerCache() {\n    if ('serviceWorker' in navigator) {\n        try {\n            // Get all service worker registrations\n            const registrations = await navigator.serviceWorker.getRegistrations()\n            \n            // Unregister all service workers\n            await Promise.all(registrations.map(registration => registration.unregister()))\n            \n            // Clear all caches\n            const cacheNames = await caches.keys()\n            await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)))\n            \n            // Send message to service worker to clear cache\n            if (navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage('clearCache')\n            }\n            \n            console.log('Service worker cache cleared successfully')\n            // Optionally reload the page to ensure clean state\n            window.location.reload()\n        } catch (error) {\n            console.error('Error clearing service worker cache:', error)\n        }\n    }\n}\n\n// You can call this function when needed\nwindow.clearServiceWorkerCache = clearServiceWorkerCache\n```\n\nYou can then clear the cache in three ways:\n\n1. From the browser console:\n```javascript\nwindow.clearServiceWorkerCache()\n```\n\n2. From your application code:\n```javascript\nawait clearServiceWorkerCache()\n```\n\n3. Manually through the browser:\n- Open DevTools (F12)\n- Go to Application tab\n- Select \"Service Workers\" in the left sidebar\n- Click \"Unregister\" for your service worker\n- Select \"Cache Storage\" in the left sidebar\n- Right-click on \"cranes-cache-v2\" and select \"Delete\"\n\nThis will ensure a complete clearing of the service worker and its cache. After clearing, the service worker will be reinstalled on the next page load and start with a fresh cache.",
      "timingInfo": {
        "clientStartTime": 1737076070031,
        "clientRpcSendTime": 1737076070053,
        "clientSettleTime": 1737076084293,
        "clientEndTime": 1737076084293
      },
      "intermediateChunks": [
        {
          "chunkIdentity": {
            "fileName": "service-worker.js",
            "startLine": 1,
            "endLine": 42,
            "text": "const wait = async (ms) => new Promise((resolve) => setTimeout(resolve, ms))\n\nself.addEventListener('install', function (event) {\n    // Perform install steps\n})\n\nasync function fetchWithControlledRetry(request) {\n    const cache = await caches.open(CACHE_NAME)\n\n    async function attemptFetch() {\n        let cacheResponse = await caches.match(request)\n\n        const timeoutPromise = new Promise((resolve) =>\n            setTimeout(async () => {\n                if (cacheResponse) return resolve(cacheResponse)\n                await wait(500)\n                resolve(fetch(request))\n            }, 1000),\n        )\n\n        const networkPromise = fetch(request)\n            .then(async (response) => {\n                if (response.ok) {\n                    await cache.put(request, response.clone()) // Cache the successful response\n                    return response\n                }\n                throw new Error('Network response was not ok')\n            })\n            .catch(async (error) => {\n                // In case of network error (including being offline), return cached response if available\n                if (cacheResponse) {\n                    return cacheResponse\n                }\n                wait(500) // Wait 500ms before retrying\n                return fetch(request)\n            })\n\n        return Promise.race([networkPromise, timeoutPromise])\n    }\n\n    return attemptFetch()\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "service-worker.js",
            "startLine": 44,
            "endLine": 51,
            "text": "self.addEventListener('fetch', function (event) {\n    // Guard clauses for GET requests, excluding 'edit' in URL, and ensuring same-origin\n    if (event.request.method !== 'GET' || event.request.url.includes('edit') || new URL(event.request.url).origin !== location.origin) {\n        return\n    }\n\n    event.respondWith(fetchWithControlledRetry(event.request))\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 439,
            "endLine": 441,
            "text": "export function deactivate() {\n  // Clean up will be handled automatically by VS Code\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 1,
            "endLine": 8,
            "text": "import * as monaco from 'monaco-editor'\n\n// Set up Monaco's worker path\nself.MonacoEnvironment = {\n    getWorkerUrl: function(moduleId, label) {\n        return './vs/base/worker/workerMain.js';\n    }\n};",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "esbuild.js",
            "startLine": 54,
            "endLine": 116,
            "text": "async function generateHTML(shaderFiles) {\n    let htmlContent = '<!DOCTYPE html>\\n<html>\\n<head>\\n<title>Shaders</title>\\n</head>\\n<body>\\n<ul>\\n'\n    shaderFiles.forEach((file) => {\n        const relativePath = relative('shaders', file)\n        const queryParam = relativePath.replace(/\\\\/g, '/').replace('.frag', '')\n        htmlContent += `<li><a href=\"/?shader=${queryParam}&fullscreen=true\">${queryParam}</a></li>\\n`\n    })\n    htmlContent += '</ul>\\n</body>\\n</html>'\n\n    await writeFile(join('dist', 'shaders.html'), htmlContent)\n}\n\nasync function main() {\n    await ensureDistDirectory()\n\n    const entryPoints = ['index.js', 'edit.js', 'service-worker.js', 'analyze.js']\n    const srcEntryPoints = await getEntryPoints('./src')\n    entryPoints.push(...srcEntryPoints)\n\n    const shaderDir = 'shaders'\n    const shaderFiles = await getShaderFiles(shaderDir)\n\n    await generateHTML(shaderFiles)\n\n    await build({\n        entryPoints,\n        format: 'esm',\n        bundle: true,\n        minify: true,\n        sourcemap: !process.env.NODE_ENV,\n        outdir: join(process.cwd(), 'dist'),\n        treeShaking: true,\n        define: {\n            CACHE_NAME: '\"cranes-cache-v2\"',\n            'process.env.NODE_ENV': process.env.NODE_ENV ?? '\"development\"',\n        },\n        loader: {\n            '.ttf': 'file',\n            '.woff': 'file',\n            '.woff2': 'file',\n        }\n    })\n\n    // Copy Monaco's files separately\n    await ncpAsync(\n        'node_modules/monaco-editor/min/vs',\n        'dist/vs'\n    )\n\n    await Promise.all([\n        ncpAsync('index.html', 'dist/index.html'),\n        ncpAsync('index.css', 'dist/index.css'),\n        ncpAsync('edit.html', 'dist/edit.html'),\n        ncpAsync('edit.css', 'dist/edit.css'),\n        ncpAsync('BarGraph.css', 'dist/BarGraph.css'),\n        ncpAsync('favicon.ico', 'dist/favicon.ico'),\n        ncpAsync('images', 'dist/images'),\n        ncpAsync('shaders', 'dist/shaders'),\n        ncpAsync('codicon.ttf', 'dist/codicon.ttf'),\n        ncpAsync('analyze.html', 'dist/analyze.html'),\n        ncpAsync('analyze.css', 'dist/analyze.css'),\n    ])\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 42,
            "endLine": 86,
            "text": "window.cranes = window.cranes || {}\nwindow.cranes.manualFeatures = window.cranes.manualFeatures || {}\nconst getRelativeOrAbsolute = async (url) => {\n    //if the url is not a full url, then it's a relative url\n    if (!url.includes('http')) {\n        url = `/shaders/${url}`\n    }\n    const res = await fetch(url)\n    const shader = await res.text()\n    return shader\n}\n\nconst getFragmentShader = async () => {\n    const shaderUrl = params.get('shader')\n    let fragmentShader\n    if (shaderUrl) {\n        fragmentShader = await getRelativeOrAbsolute(`${shaderUrl}.frag`)\n    }\n\n    if (!fragmentShader) {\n        fragmentShader = localStorage.getItem('cranes-manual-code')\n    }\n\n    if (!fragmentShader) {\n        fragmentShader = await getRelativeOrAbsolute('default.frag')\n    }\n    return fragmentShader\n}\n\nconst getVertexShader = async () => {\n    const shaderUrl = params.get('vertex_shader')\n    let vertexShader\n    if (shaderUrl) {\n        vertexShader = await getRelativeOrAbsolute(`${shaderUrl}.vert`)\n    }\n\n    if (!vertexShader) {\n        vertexShader = localStorage.getItem('cranes-manual-code-vertex')\n    }\n\n    if (!vertexShader) {\n        vertexShader = await getRelativeOrAbsolute('default.vert')\n    }\n    return vertexShader\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/WorkerRPC.js",
            "startLine": 88,
            "endLine": 115,
            "text": "export class WorkerRPC {\n    ...\n    initialize = async () => {\n        const workerUrl = new URL(`./src/audio/analyzers/${this.workerName}.js`, import.meta.url)\n        const response = await fetch(workerUrl)\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${this.workerName} worker: ${response.statusText}`)\n        }\n\n        const code = await response.text()\n        const blob = new Blob([code], { type: 'application/javascript' })\n        this.worker = new Worker(URL.createObjectURL(blob))\n\n        this.worker.onmessage = this.handleMessage\n        this.worker.onerror = this.handleError\n\n        this.worker.postMessage({\n            type: 'config',\n            config: { historySize: this.historySize },\n        })\n    }\n\n    handleError = (error) => {\n        console.error(`Error in worker ${this.workerName}:`, error)\n    }\n\n    terminate = () => {\n        this.worker?.terminate()\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "webpack.config.js",
            "startLine": 1,
            "endLine": 64,
            "text": "const path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst TerserPlugin = require('terser-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst { DefinePlugin } = require('webpack')\n\nmodule.exports = {\n    mode: 'production',\n\n    // Your other webpack configurations go here\n    devServer: {\n        static: {\n            directory: path.join(__dirname, 'dist'), // Path to your built files\n        },\n        port: 6969, // Choose any port you prefer\n        hot: false, // Enable hot module replacement\n    },\n\n    entry: {\n        app: './index.js',\n        'service-worker': './service-worker.js',\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js',\n        publicPath: '/',\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [MiniCssExtractPlugin.loader, 'css-loader'],\n            },\n            {\n                test: /\\.(png|jpe?g|gif|svg)$/i,\n                use: [\n                    {\n                        loader: 'file-loader',\n                        options: {\n                            outputPath: 'images',\n                            name: '[name].[ext]',\n                        },\n                    },\n                ],\n            },\n            {\n                test: /\\.html$/,\n                use: ['html-loader'],\n            },\n            {\n                test: /src\\/audio\\/analyzers\\/.+\\.js$/, // Regex to match JS files in the specific directory\n                use: [\n                    {\n                        loader: 'file-loader',\n                        options: {\n                            name: '[contenthash]/[name].js',\n                            outputPath: 'audio/analyzers',\n                        },\n                    },\n                ],\n            },\n        ],\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "esbuild.js",
            "startLine": 118,
            "endLine": 118,
            "text": "main().catch(console.error)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 490,
            "endLine": 508,
            "text": "function init() {\n    ...\n    // Update the undo/redo commands to work on both Windows and Mac\n    editor.addCommand(monaco.KeyMod.WinCtrl | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'undo', null)\n    })\n\n    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'undo', null)\n    })\n\n    editor.addCommand(monaco.KeyMod.WinCtrl | monaco.KeyMod.Shift | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'redo', null)\n    })\n\n    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'redo', null)\n    })\n\n    document.querySelector('#publish').addEventListener('click', () => {})\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 88,
            "endLine": 128,
            "text": "const main = async () => {\n    try {\n        if (ranMain) return\n        ranMain = true\n        window.c = cranes\n        startTime = performance.now()\n        const audio = await setupAudio()\n\n        const fragmentShader = await getFragmentShader()\n        const vertexShader = await getVertexShader()\n\n        window.shader = fragmentShader\n        const initialImageUrl = params.get('image') ?? 'images/placeholder-image.png'\n        const fullscreen = (params.get('fullscreen') ?? false) === 'true'\n        const canvas = getVisualizerDOMElement()\n        const render = await makeVisualizer({ canvas, initialImageUrl, fullscreen })\n        requestAnimationFrame(() => animate({ render, audio, fragmentShader, vertexShader }))\n    } catch (e) {\n        console.error(`main error: ${e}`)\n    }\n}\n\n// if the url contains the string 'edit', don't do this.\nif (!window.location.href.includes('edit')) {\n    events.forEach((event) => {\n        // get the visualizer\n        const visualizer = getVisualizerDOMElement()\n        visualizer.addEventListener(event, main, { once: true })\n        visualizer.addEventListener(\n            event,\n            () => {\n                try {\n                    document.documentElement.requestFullscreen()\n                } catch (e) {\n                    console.error(`preventing a crash: ${e}`)\n                }\n            },\n            { once: true },\n        )\n    })\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.css",
            "startLine": 1,
            "endLine": 23,
            "text": "body {\n  min-height: 100vh;\n  min-width: 100vw;\n  margin: 0;\n  padding: 0;\n  overflow: hidden; /* Prevents scrolling */\n  display: flex;\n  justify-content: center;\n  align-items: center;;\n  user-select: none;\n  background-color: #000000;\n}\ncanvas {\n  margin: 0;\n  height: 100vmin;\n  width: 100vmin;\n}\n\ncanvas.fullscreen {\n  height: 100vh;\n  width: 100vw;\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 10,
            "endLine": 52,
            "text": "function init() {\n    //if we have a shader in the query param, return\n    if (new URLSearchParams(window.location.search).get('shader')) return\n    console.log('no shader in query param')\n    const shader = localStorage.getItem('cranes-manual-code') || ''\n    const conf = {\n        comments: {\n            lineComment: '//',\n            blockComment: ['/*', '*/'],\n        },\n        brackets: [\n            ['{', '}'],\n            ['[', ']'],\n            ['(', ')'],\n        ],\n        autoClosingPairs: [\n            { open: '[', close: ']' },\n            { open: '{', close: '}' },\n            { open: '(', close: ')' },\n            { open: \"'\", close: \"'\", notIn: ['string', 'comment'] },\n            { open: '\"', close: '\"', notIn: ['string'] },\n            { open: '/*', close: ' */', notIn: ['string'] },\n        ],\n        surroundingPairs: [\n            { open: '{', close: '}' },\n            { open: '[', close: ']' },\n            { open: '(', close: ')' },\n            { open: '\"', close: '\"' },\n            { open: \"'\", close: \"'\" },\n        ],\n    }\n\n    const keywords = [\n        'getLastFrameColor',\n        'PI',\n        'mapValue',\n        'resolution',\n        'time',\n        'spectralCentroid',\n        'energy',\n        'spectralRolloff',\n        'spectralRolloffNormalized',\n        'spectralRolloffMean'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "esbuild.js",
            "startLine": 1,
            "endLine": 52,
            "text": "import { build } from 'esbuild'\nimport { join, relative } from 'path'\nimport { readdir, stat, mkdir, writeFile } from 'fs/promises'\nimport ncp from 'ncp'\nimport { promisify } from 'util'\n\nconst ncpAsync = promisify(ncp)\n\nasync function ensureDistDirectory() {\n    try {\n        await mkdir('dist', { recursive: true })\n    } catch (err) {\n        console.error('Error ensuring dist directory:', err)\n    }\n}\n\nasync function getShaderFiles(dir) {\n    let fileList = []\n    const files = await readdir(dir)\n    await Promise.all(\n        files.map(async (file) => {\n            const filePath = join(dir, file)\n            const stats = await stat(filePath)\n            if (stats.isDirectory()) {\n                if (!['private', 'knobs', 'utils', 'practice'].includes(file)) {\n                    const subDirFiles = await getShaderFiles(filePath)\n                    fileList = fileList.concat(subDirFiles)\n                }\n            } else if (file.endsWith('.frag')) {\n                fileList.push(filePath)\n            }\n        }),\n    )\n    return fileList\n}\n\nasync function getEntryPoints(dir) {\n    let entryPoints = []\n    const files = await readdir(dir, { withFileTypes: true })\n    await Promise.all(\n        files.map(async (file) => {\n            const filePath = join(dir, file.name)\n            if (file.isDirectory()) {\n                const subDirEntries = await getEntryPoints(filePath)\n                entryPoints = entryPoints.concat(subDirEntries)\n            } else if (file.isFile() && file.name.endsWith('.js')) {\n                entryPoints.push(filePath)\n            }\n        }),\n    )\n    return entryPoints\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/WorkerRPC.js",
            "startLine": 1,
            "endLine": 38,
            "text": "export class WorkerRPC {\n    constructor(workerName, historySize, timeout = 50) {\n        this.workerName = workerName\n        this.historySize = historySize\n        this.timeout = timeout\n        this.currentMessageId = 0\n        this.resolveMessage = null\n        this.lastMessage = this.createDefaultMessage()\n    }\n\n    createDefaultMessage = () => ({\n        type: 'computedValue',\n        workerName: this.workerName,\n        value: 0,\n        stats: {\n            current: 0,\n            mean: 0,\n            median: 0,\n            min: 0,\n            max: 0,\n            variance: 0,\n            standardDeviation: 0,\n            zScore: 0,\n            normalized: 0,\n        },\n    })\n\n    validateStats = (stats = {}) => ({\n        current: isFinite(stats.current) ? stats.current : 0,\n        mean: isFinite(stats.mean) ? stats.mean : 0,\n        median: isFinite(stats.median) ? stats.median : 0,\n        min: isFinite(stats.min) ? stats.min : 0,\n        max: isFinite(stats.max) ? stats.max : 0,\n        variance: isFinite(stats.variance) ? stats.variance : 0,\n        standardDeviation: isFinite(stats.standardDeviation) ? stats.standardDeviation : 0,\n        zScore: isFinite(stats.zScore) ? stats.zScore : 0,\n        normalized: isFinite(stats.normalized) ? stats.normalized : 0,\n    })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.html",
            "startLine": 1,
            "endLine": 28,
            "text": "<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <link rel=\"stylesheet\" data-name=\"vs/editor/editor.main\" href=\"./vs/editor/editor.main.css\" />\n    <link rel=\"stylesheet\" href=\"edit.css\" />\n    <title>Paper Cranes - Editor</title>\n</head>\n\n<body class=\"ready\">\n    <div class=\"sparkly animated\" id=\"feature-editor\"></div>\n    <canvas id=\"visualizer\" width=\"1920\" height=\"1920\"></canvas>\n    <div id=\"save-and-publish\" class=\"sparkly animated\">\n        <button id=\"save\">Save</button>\n        <button id=\"publish\">\n            <a href=\"https://github.com/loqwai/paper-cranes/new/main/shaders\" target=\"_blank\">Publish</a>\n        </button>\n        <button id=\"reset\">Reset</button>\n    </div>\n    <div id=\"monaco-editor\"></div>\n    <script type=\"module\" src=\"./src/monaco.js\"></script>\n    <script type=\"module\" src=\"./index.js\"></script>\n    <script type=\"module\" src=\"./edit.js\"></script>\n    <script type=\"module\" src=\"./src/midi.js\"></script>\n</body>\n\n</html>\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "webpack.config.js",
            "startLine": 64,
            "endLine": 99,
            "text": "    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            inject: true,\n        }),\n        new MiniCssExtractPlugin({\n            filename: '[name].[contenthash].css',\n        }),\n        new CopyWebpackPlugin({\n            patterns: [\n                { from: 'images', to: 'images' },\n                { from: 'shaders', to: 'shaders' },\n                { from: 'favicon.ico', to: 'favicon.ico' },\n                { from: 'index.css', to: 'index.css' },\n                { from: './src/utils', to: 'utils' },\n            ],\n        }),\n        new DefinePlugin({\n            WEBPACK_CACHE_NAME: JSON.stringify(new Date().toISOString()),\n        }),\n    ],\n    optimization: {\n        minimize: true,\n        minimizer: [\n            new TerserPlugin({\n                terserOptions: {\n                    format: {\n                        comments: false,\n                    },\n                },\n                extractComments: false,\n            }),\n        ],\n    },\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 450,
            "endLine": 488,
            "text": "function init() {\n    ...\n    monaco.languages.register({ id: 'glsl' })\n    monaco.languages.setMonarchTokensProvider('glsl', language)\n    monaco.languages.setLanguageConfiguration('glsl', conf)\n    const editor = monaco.editor.create(document.querySelector('#monaco-editor'), {\n        value: shader,\n        minimap: { enabled: false },\n        language: 'glsl',\n        theme: 'vs-dark',\n        automaticLayout: true,\n        contextmenu: true,\n        copyWithSyntaxHighlighting: true,\n        quickSuggestions: true,\n    })\n\n    // on window resize, resize the editor\n    window.addEventListener('resize', () => {\n        editor.layout()\n    })\n    window.editor = editor\n\n    document.querySelector('#save').addEventListener('click', () => {\n        editor.pushUndoStop()\n        window.cranes.shader = editor.getValue()\n        localStorage.setItem('cranes-manual-code', editor.getValue())\n        editor.pushUndoStop()\n    })\n\n    // save on control or command s\n    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S, function () {\n        editor.pushUndoStop()\n        window.cranes.shader = editor.getValue()\n        localStorage.setItem('cranes-manual-code', editor.getValue())\n        editor.pushUndoStop()\n    })\n\n    document.querySelector('#reset').addEventListener('click', () => {\n        localStorage.removeItem('cranes-manual-code')\n        window.location.reload()\n    })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 61,
            "endLine": 97,
            "text": "const FeatureAdder = () => {\n    const [features, setFeatures] = useState({})\n    const [newFeatureName, setNewFeatureName] = useState('')\n\n    useEffect(async () => {\n        const searchParams = new URLSearchParams(window.location.search)\n        const initialFeatures = {}\n        searchParams.forEach((value, key) => {\n            // if the value is not a number, return.\n            if (isNaN(value)) return\n            const [featureName, paramType] = key.includes('.') ? key.split('.') : [key, 'value']\n            if (!initialFeatures[featureName]) initialFeatures[featureName] = { min: -3, max: 3, value: 0 }\n            initialFeatures[featureName][paramType] = parseFloat(value)\n        })\n        setFeatures(initialFeatures)\n        // if there is no 'shader' query param, set the editor code to the default shader\n        if (!searchParams.has('shader')) {\n            // try to get the shader from local storage\n            let shader = localStorage.getItem('cranes-manual-code')\n            // if the shader is not in local storage, fetch it from the server\n            if (!shader) {\n                const res = await fetch('/shaders/default.frag')\n                shader = await res.text()\n            }\n            window.editor.pushUndoStop()\n            window.editor.setValue(shader)\n            window.editor.pushUndoStop()\n            window.editor.layout()\n        } else {\n            // add the no-editor class to body\n            document.body.classList.add('no-editor')\n        }\n        // if we have a searchParam of 'present', add the present class to the body\n        if (searchParams.has('present')) {\n            document.body.classList.add('present')\n        }\n    }, [])",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".gitignore",
            "startLine": 67,
            "endLine": 149,
            "text": "\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variables file\n.env\n.env.test\n.envrc\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n\n# Next.js build output\n.next\n\n# Nuxt.js build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and *not* Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# TernJS port file\n.tern-port\ntmp\nout/\n\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n*.out\n\n# yarn\n/node_modules\n/.pnp\n.pnp.js\n\n# testing\n/coverage\n\n# production\n/build\n\n# misc\n.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# stupid yarn config\n.yarn/cache\n\n**/.yarn/*\n**/.yarn/*\n.\n!**/.yarn/plugins/\n!**/.yarn/releases/\n!**/.yarn/sdks/\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 129,
            "endLine": 160,
            "text": "const setupAudio = async () => {\n    const audioContext = new AudioContext()\n    await audioContext.resume()\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })\n    const sourceNode = audioContext.createMediaStreamSource(stream)\n    const historySize = parseInt(params.get('history_size') ?? '500')\n    const audioProcessor = new AudioProcessor(audioContext, sourceNode, historySize)\n    await audioProcessor.start()\n    return audioProcessor\n}\n\nconst animate = ({ render, audio, fragmentShader, vertexShader }) => {\n    requestAnimationFrame(() => animate({ render, audio, fragmentShader, vertexShader }))\n    fragmentShader = window.cranes?.shader ?? fragmentShader\n    const measuredAudioFeatures = audio.getFeatures()\n    const queryParamFeatures = {}\n\n    for (const [key, value] of params) {\n        queryParamFeatures[key] = value\n    }\n\n    const { manualFeatures } = window.cranes\n    window.cranes.measuredAudioFeatures = measuredAudioFeatures\n    const features = { ...measuredAudioFeatures, ...queryParamFeatures, ...manualFeatures }\n\n    try {\n        render({ time: (performance.now() - startTime) / 1000, features, fragmentShader, vertexShader })\n    } catch (e) {\n        console.error(e)\n    }\n\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 143,
            "endLine": 150,
            "text": "\n\n/* Optional adjustments for a better layout */\n#feature-editor, #visualizer, #monaco-editor {\n    width: 100%; /* Ensures full utilization of their grid cell's width */\n    height: 100%; /* For #monaco-editor to fully expand vertically, depending on your design needs */\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 93,
            "endLine": 142,
            "text": "\n\nbody {\n    display: grid;\n    grid-template-columns: 50% 50%;\n    grid-template-rows: auto; /* Define two rows, their size determined by the content */\n    height: 100vh; /* Ensure the body takes up the full viewport height */\n}\n\nbody.no-editor {\n    display:flex;\n    /* reverse the order of the flex items */\n    flex-direction: row-reverse;\n}\nbody.no-editor #save-and-publish, body.no-editor #monaco-editor{\n   display: none;\n}\nbody.present #feature-editor {\n  display:none;\n}\n#feature-editor {\n    grid-column: 1; /* Places it in the first column */\n    grid-row: 1; /* Places it in the first row */\n}\n\n#save-and-publish {\n    grid-column:2;\n    grid-row: 1;\n    display: flex;\n}\n#save-and-publish > button {\n    flex: 1;\n    cursor:pointer;\n    margin: 1em;\n\n}\n#save-and-publish > button > a {\n    /* clear the default styles */\n    text-decoration: none;\n    color: inherit;\n}\n#monaco-editor {\n    grid-column: 2; /* Places it in the second column */\n    grid-row: 2; /* Places it in the first row */\n    /*span 2 rows*/\n}\n#visualizer {\n    grid-column: 1; /* Also in the first column */\n    grid-row: 2; /* But in the second row, under #feature-editor */\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/WorkerRPC.js",
            "startLine": 40,
            "endLine": 86,
            "text": "export class WorkerRPC {\n    ...\n    validateMessage = (message) => ({\n        ...message,\n        workerName: this.workerName,\n        value: isFinite(message.value) ? message.value : 0,\n        stats: this.validateStats(message.stats),\n    })\n\n    handleMessage = (event) => {\n        if (event.data.type === 'computedValue') {\n            const validatedMessage = this.validateMessage(event.data)\n            this.lastMessage = validatedMessage\n\n            if (this.resolveMessage && event.data.id === this.currentMessageId) {\n                this.resolveMessage(validatedMessage)\n                this.resolveMessage = null\n            }\n        }\n    }\n\n    processData = async (fftData) => {\n        if (this.resolveMessage) {\n            console.log(`${this.workerName} abandoning message after ${performance.now() - this.currentMessageId}ms`)\n            this.resolveMessage()\n        }\n\n        const messageId = (this.currentMessageId = performance.now())\n\n        const messagePromise = Promise.race([\n            new Promise((resolve) => {\n                this.resolveMessage = resolve\n            }),\n            new Promise((_, reject) => setTimeout(() => reject(new Error(`Worker ${this.workerName} timed out`)), this.timeout)).catch(() => {\n                if (this.currentMessageId === messageId) {\n                    this.resolveMessage = null\n                }\n                return this.lastMessage\n            }),\n        ])\n\n        this.worker.postMessage({\n            type: 'fftData',\n            id: messageId,\n            data: { fft: fftData },\n        })\n\n        return messagePromise\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/AudioProcessor.js",
            "startLine": 72,
            "endLine": 104,
            "text": "export class AudioProcessor {\n    ...\n    updateCurrentFeatures = () => {\n        requestAnimationFrame(this.updateCurrentFeatures)\n        this.currentFeatures = getFlatAudioFeatures(AudioFeatures, this.rawFeatures)\n        this.currentFeatures.beat = this.isBeat()\n    }\n\n    isBeat = () => {\n        const spectralFlux = this.rawFeatures.SpectralFlux\n        return spectralFlux?.stats.zScore > 0.9 || false\n    }\n\n    start = async () => {\n        this.sourceNode.connect(this.fftAnalyzer)\n        await this.audioContext.audioWorklet.addModule('src/window-processor.js')\n        const windowNode = new AudioWorkletNode(this.audioContext, 'window-processor')\n        this.sourceNode.connect(windowNode)\n        await Promise.all(AudioFeatures.map(this.initializeWorker))\n        this.updateCurrentFeatures()\n        this.updateFftData()\n    }\n\n    updateFftData = () => {\n        requestAnimationFrame(this.updateFftData)\n        this.fftAnalyzer.getByteFrequencyData(this.fftData)\n    }\n\n    getFeatures = () => this.currentFeatures\n\n    cleanup = () => {\n        this.workers.forEach(worker => worker.terminate())\n        this.workers.clear()\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 1,
            "endLine": 20,
            "text": "import { render, Fragment } from 'preact'\nimport { useState, useEffect } from 'preact/hooks'\nimport { html } from 'htm/preact'\nimport debounce from 'debounce'\n\nconst updateUrl = (params) => {\n    const currentUrl = new URL(window.location)\n    Object.entries(params).forEach(([paramName, paramValue]) => {\n        if (paramValue !== null && paramValue !== undefined) {\n            currentUrl.searchParams.set(paramName, paramValue)\n        } else {\n            currentUrl.searchParams.delete(paramName)\n        }\n    })\n    window.history.replaceState({}, '', currentUrl.toString())\n}\n\nconst updateUrlDebounced = debounce(updateUrl, 50)\n\nconst FeatureEditor",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 1,
            "endLine": 41,
            "text": "import { AudioProcessor } from './src/audio/AudioProcessor.js'\nimport { makeVisualizer } from './src/Visualizer.js'\nimport './index.css'\nconst events = ['touchstart', 'touchmove', 'touchstop', 'click', 'keydown', 'mousemove', 'mousedown', 'mouseup', 'resize']\nlet ranMain = false\nlet startTime = 0\nconst params = new URLSearchParams(window.location.search)\n\nconst getVisualizerDOMElement = () => {\n    if (!window.visualizer) {\n        window.visualizer = document.getElementById('visualizer')\n    }\n    return window.visualizer\n}\n\n// check if we have microphone access. If so, just run main immediately\nnavigator.mediaDevices\n    .getUserMedia({\n        audio: {\n            echoCancellation: false,\n            noiseSuppression: false,\n            autoGainControl: false,\n        },\n    })\n    .then(() => main())\n    .catch(() => {\n        const body = document.querySelector('body')\n        body.classList.remove('ready')\n    })\nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n        navigator.serviceWorker.register(new URL('/service-worker.js', import.meta.url)).then(\n            (registration) => {\n                console.log('ServiceWorker registration successful with scope: ', registration.scope)\n            },\n            (err) => {\n                console.log('ServiceWorker registration failed: ', err)\n            },\n        )\n    })\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/.nvmrc",
            "startLine": 1,
            "endLine": 2,
            "text": "v22.8.0\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 432,
            "endLine": 437,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      },\n    },\n  );\n\n  context.subscriptions.push(completionProvider, hoverProvider);\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/README.md",
            "startLine": 38,
            "endLine": 40,
            "text": "\nMIT License - see LICENSE file for details.\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 1,
            "endLine": 39,
            "text": "import {\n    createTexture,\n    createFramebufferInfo,\n    createProgramInfo,\n    createBufferInfoFromArrays,\n    resizeCanvasToDisplaySize,\n    setBuffersAndAttributes,\n    setUniforms,\n    drawBufferInfo,\n} from 'twgl-base.js'\n\nimport { shaderWrapper } from './shader-transformers/shader-wrapper'\n\nconst gridSize = 100\n\nconst getTexture = async (gl, url) => {\n    return new Promise((resolve) => {\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) // Flip the texture\n        const texture = createTexture(gl, { src: url, crossOrigin: 'anonymous' }, () => {\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) // Reset the parameter\n            resolve(texture)\n        })\n    })\n}\n\n// Function to create and update the WebGL program with error handling\nconst updateWebGLProgram = (gl, vertexShader, fragmentShader) => {\n    try {\n        const programInfo = createProgramInfo(gl, [vertexShader, fragmentShader])\n        if (!programInfo?.program) {\n            throw new Error('Failed to create a program. The shader code might be bad.')\n        }\n        gl.useProgram(programInfo.program)\n        return programInfo\n    } catch (error) {\n        console.error('Error creating WebGL program:', error.message)\n        return\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 33,
            "endLine": 66,
            "text": "\n.save-load {\n    margin-top: 0.5em;\n    display: flex;\n    flex-direction: row;\n    justify-content: start;\n}\n:root {\n    --foreground-rgb: 0, 0, 0;\n    --background-start-rgb: 214, 219, 220;\n    --background-end-rgb: 255, 255, 255;\n    /* Cosmic Color Scheme */\n    --color-space-black: #000000;\n    --color-nebula-purple: #a365f2;\n    --color-asteroid-pink: #e16ce6;\n    --color-galaxy-blue: #a398f4;\n    --color-comet-tail: #e099e6;\n    --color-starlight-blue: #6195f9;\n    --color-deep-sky: #2198fb;\n    --color-twilight-purple: #6566f4;\n    --color-alien-green: #a22bec;\n    --color-rocket-metal: #2065f5;\n    --color-lunar-white: #e6e6e6;\n\n    --radius: 0.5rem;\n}\n\n/* Sparkly Class */\n.sparkly {\n    background: linear-gradient(\n        270deg,\n        var(--color-nebula-purple),\n        var(--color-asteroid-pink),\n        var(--color-comet-tail),",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 99,
            "endLine": 142,
            "text": "const FeatureAdder = () => {\n    ...\n    const updateFeature = (name, updatedFeature) => {\n        // get the previous feature\n        updatedFeature.min = updatedFeature.min ?? -2\n        updatedFeature.max = updatedFeature.max ?? 1\n        //round the value to the nearest 3 decimal places\n        updatedFeature.value = Math.round(updatedFeature.value * 1000) / 1000\n        setFeatures((prev) => ({ ...prev, [name]: updatedFeature }))\n    }\n\n    window.cranes.updateFeature = (name, value) => {\n        updateFeature(name, { ...features[name], value })\n    }\n\n    const addNewFeature = () => {\n        if (!newFeatureName.trim()) {\n            alert('Feature name cannot be empty')\n            return\n        }\n        const newFeature = { value: 1, min: -3, max: 3 }\n        updateFeature(newFeatureName, newFeature)\n        setNewFeatureName('')\n    }\n\n    const deleteFeature = (name) => {\n        const { [name]: _, ...rest } = features\n        setFeatures(rest)\n        updateUrl({ [name]: null, [`${name}.min`]: null, [`${name}.max`]: null })\n        delete window.cranes?.manualFeatures[name]\n    }\n\n    return html`\n        <${Fragment}>\n            <div className=\"new-feature\">\n                <input type=\"text\" value=${newFeatureName} onInput=${(e) => setNewFeatureName(e.target.value)} placeholder=\"Enter new feature name\" />\n                <button onClick=${addNewFeature}>Add Feature</button>\n            </div>\n            <div id=\"existing-features-editor\">\n                ${Object.entries(features).map(\n                    ([name, feature]) => html` <${FeatureEditor} key=${name} name=${name} feature=${feature} onChange=${updateFeature} onDelete=${deleteFeature} />`,\n                )}\n            </div>\n        </${Fragment}>\n    `\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 1,
            "endLine": 32,
            "text": "form {\n    color: white;\n}\n\nlabel {\n    display: flex;\n    justify-content: center; /* This centers the child elements (including text) horizontally */\n    align-items: center; /* This centers the child elements (including text) vertically */\n}\nlabel input {\n    flex: 1;\n}\n\nhtml {\n    background-color: black;\n    font-family: 'Space-Age', sans-serif;\n}\n#feature-editor {\n    border-radius: 10px;\n    box-sizing: border-box;\n    padding: 1em;\n}\n.edit-feature {\n    display:grid;\n    grid-template-columns: 6em 6em auto 6em 2.5em 1.5em;\n    height: 2em;\n}\n.new-feature {\n    display: grid;\n    grid-template-columns: auto 6em;\n    margin-bottom: 0.5em;\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "package.json",
            "startLine": 1,
            "endLine": 57,
            "text": "{\n  \"name\": \"paper-cranes-audio\",\n  \"version\": \"1.0.2\",\n  \"description\": \"\",\n  \"type\": \"module\",\n  \"main\": \"dist/src/audio/AudioProcessor.js\",\n  \"scripts\": {\n    \"start\": \"npm run dev\",\n    \"serve\": \"browser-sync start --server dist --port 6969 --files 'dist/**/*' --no-open\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"node ./esbuild.js\",\n    \"dev\": \"npm run build && concurrently \\\"npm run serve\\\" \\\"npm run build:watch\\\"\",\n    \"build:watch\": \"chokidar '**/*.*' -i 'node_modules/*' -i 'dist/**/*.*' -c 'npm run build'\",\n    \"format\": \"eslint --fix .\"\n  },\n  \"author\": \"hypnodroid\",\n  \"license\": \"UNLICENSED\",\n  \"dependencies\": {\n    \"@preact/signals\": \"^1.3.1\",\n    \"debounce\": \"^2.2.0\",\n    \"htm\": \"^3.1.1\",\n    \"html\": \"^1.0.0\",\n    \"hypnosound\": \"^1.8.0\",\n    \"monaco-editor\": \"^0.52.2\",\n    \"preact\": \"^10.25.4\",\n    \"twgl-base.js\": \"^5.5.3\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.96.0\",\n    \"browser-sync\": \"^3.0.0\",\n    \"chokidar-cli\": \"^3.0.0\",\n    \"concurrently\": \"^9.1.2\",\n    \"esbuild\": \"^0.20.2\",\n    \"esbuild-plugin-copy\": \"^2.1.1\",\n    \"esbuild-plugin-css-modules\": \"^0.3.0\",\n    \"esbuild-plugin-html\": \"^1.0.0\",\n    \"eslint\": \"^8.57.1\",\n    \"mini-css-extract-plugin\": \"^2.9.2\",\n    \"ncp\": \"^2.0.0\",\n    \"prettier\": \"^3.4.2\"\n  },\n  \"languages\": [\n    {\n      \"id\": \"paper-cranes-fragment-shader\",\n      \"aliases\": [\n        \"GLSL\",\n        \"glsl\"\n      ],\n      \"extensions\": [\n        \".frag\",\n        \".vert\",\n        \".glsl\"\n      ]\n    }\n  ]\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 509,
            "endLine": 509,
            "text": "init()",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".nvmrc",
            "startLine": 1,
            "endLine": 2,
            "text": "v22.8.0\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".github/workflows/publish-extension.yml",
            "startLine": 1,
            "endLine": 33,
            "text": "name: Publish VS Code Extension\non:\n    workflow_dispatch:\n    push:\n        branches:\n            - main\n        paths:\n            - 'vscode-extension/package.json'\n            - '.github/workflows/'\n\njobs:\n    publish-extension:\n        runs-on: ubuntu-22.04\n        permissions:\n            contents: read\n            id-token: write\n        steps:\n            - uses: actions/checkout@v4\n            - uses: actions/setup-node@v4\n              with:\n                  node-version: '22.x'\n                  registry-url: 'https://registry.npmjs.org'\n\n            # Build and publish VS Code extension\n            - name: Install dependencies\n              run: cd ./vscode-extension && npm clean-install\n\n            - name: Build extension\n              run: cd ./vscode-extension && npm run build\n\n            - name: Publish to VS Code Marketplace\n              run: cd ./vscode-extension && npx vsce publish -p ${{ secrets.VSCE_PAT }}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 156,
            "endLine": 160,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    const render = ({ time, features, vertexShader: newVertexShader, fragmentShader: newFragmentShader }) => {\n        ...\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n        gl.blitFramebuffer(0, 0, frame.width, frame.height, 0, 0, gl.canvas.width, gl.canvas.height, gl.COLOR_BUFFER_BIT, gl.LINEAR)\n\n        frameNumber++\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.html",
            "startLine": 1,
            "endLine": 18,
            "text": "<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <link rel=\"stylesheet\" href=\"index.css\" />\n    <title>Paper Cranes</title>\n    <!-- Google tag (gtag.js) -->\n    <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-4BWWJ5ZPHY\"></script>\n\n</head>\n\n<body class=\"ready\">\n    <canvas id=\"visualizer\" width=\"2160\" height=\"1920\"></canvas>\n    <script type=\"module\" src=\"./index.js\"></script>\n</body>\n\n</html>\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 1,
            "endLine": 18,
            "text": "# Beadfamous\n\nWelcome to the Beadfamous project! This repo is an open-source project I made to do advanced audio analysis from a microphone in the browser, and drive arbitrary music visualizations with the data. The project can run on mobile phones, and is designed to make it easy to create new visualizations and share them with others.\n\nThe other half of the project is a sort of \"art project\" where you make bead bracelets, and flash the visualizations onto them. This is a fun way to share your visualizations with others, and to make a physical object that represents your music. Scanning the bracelet with a phone will take you to a specific visualization - even when offline!\n\n## Usage\n\nIf you've done web development before, the following steps should be pretty familiar.\n\n1. `npm install`\n2. `npm run dev`\n\nThis will serve beadfamous on localhost:6969\n\n## Viewing the visualizations\n\nvisualizations are specified by the query param 'shader' in the url. For example, to view the 'star' visualization, you would go to [localhost:6969/?shader=star](http://localhost:6969/?shader=star)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/AudioProcessor.js",
            "startLine": 34,
            "endLine": 70,
            "text": "export class AudioProcessor {\n    constructor(audioContext, sourceNode, historySize=500,  fftSize = 32768/2) {\n        this.audioContext = audioContext\n        this.sourceNode = sourceNode\n        this.fftSize = fftSize\n        this.historySize = historySize\n        this.fftAnalyzer = this.createAnalyzer()\n        this.fftData = new Uint8Array(this.fftAnalyzer.frequencyBinCount)\n        this.workers = new Map()\n        this.rawFeatures = {}\n        this.currentFeatures = getFlatAudioFeatures()\n        this.currentFeatures.beat = false\n    }\n\n    createAnalyzer = () => {\n        const analyzer = this.audioContext.createAnalyser()\n        analyzer.smoothingTimeConstant = 0.25\n        analyzer.minDecibels = -100\n        analyzer.maxDecibels = -30\n        analyzer.fftSize = this.fftSize\n        return analyzer\n    }\n\n    initializeWorker = async (name) => {\n        const worker = new WorkerRPC(name, this.historySize)\n        await worker.initialize()\n        this.workers.set(name, worker)\n        this.runWorkerLoop(worker)\n    }\n\n    runWorkerLoop = async (worker) => {\n        const result = await worker.processData(this.fftData)\n        if (result) {\n            this.rawFeatures[result.workerName] = result\n        }\n        requestAnimationFrame(() => this.runWorkerLoop(worker));\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 19,
            "endLine": 29,
            "text": "\nBehind the scenes, this loads code for what's called a 'shader' from the `shaders/` directory. These are written in GLSL, and are the code that actually runs on the GPU to make the visualizations. In the above example, the 'star' visualization is defined in `shaders/star.frag`. You can look at other files in the `shaders/` directory to see which visualizations are available.\n\nThis project is deployed at [visuals.beadfamous.com](https://visuals.beadfamous.com), and you can view the visualizations there as well.\n\n## Making your own visualizations\n\nMaking your own visualization is easy, but requires some knowledge of GLSL shading language.\nLucky for you, I'm hosting a hackathon with HeatSync Labs next month, in which we go from nothing to a working visualization and bracelet in a couple of hours next month! Stay tuned for more details.\n\nTo make your own visualizations, you can create a new file in the `shaders/` directory, and then load it by specifying the 'shader' query param in the url. For example, to view the 'my_new_shader' visualization, you would go to [localhost:6969/?shader=my_new_shader](http://localhost:6969/?shader=my_new_shader)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/.gitignore",
            "startLine": 1,
            "endLine": 3,
            "text": ".map\n*.vsix\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 56,
            "endLine": 107,
            "text": "const Analyzer = () => {\n    ...\n    const handleAnalyze = async (e) => {\n        const fileInput = e.target.form.querySelector('input[type=\"file\"]')\n        if (!fileInput.files?.length) return\n\n        setIsAnalyzing(true)\n        setStatus('Analyzing...')\n        setProgress(0)\n        analysisResults.current = []\n\n        try {\n            // Setup audio processing\n            audioContext.current = new AudioContext()\n            const file = fileInput.files[0]\n            const buffer = await file.arrayBuffer()\n            const decodedBuffer = await audioContext.current.decodeAudioData(buffer)\n\n            source.current = audioContext.current.createBufferSource()\n            source.current.buffer = decodedBuffer\n\n            processor.current = new AudioProcessor(audioContext.current, source.current, 500)\n            await processor.current.start()\n\n            // Connect and start playback\n            source.current.connect(audioContext.current.destination)\n            source.current.start()\n\n            const startTime = performance.now()\n            const duration = decodedBuffer.duration * 1000\n            setTimeInfo({ current: '0:00', start: '0:00', end: formatTime(duration) })\n\n            // Analysis loop - Fixed version\n            await new Promise((resolve) => {\n                const analyze = async () => {\n                    const currentTime = performance.now() - startTime\n                    const progress = currentTime / duration\n\n                    setProgress(Math.min(progress * 100, 100))\n                    setTimeInfo(prev => ({ ...prev, current: formatTime(currentTime) }))\n\n                    const features = await processor.current.getFeatures()\n                    analysisResults.current.push({ timestamp: currentTime, features })\n                    setCurrentFeatures(features)\n\n                    if (progress >= 1) {\n                        cleanup()\n                        resolve()\n                    } else {\n                        requestAnimationFrame(analyze)\n                    }\n                }\n                requestAnimationFrame(analyze)\n            })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 30,
            "endLine": 42,
            "text": "\nYou can copy and paste any of the existing files in the `shaders/` directory to get started. Or ya know, wait until the Hackathon and I'll walk you through it.\n\nIf you want to deploy a visualization you made, PR me and I'll add it to the deployed site!\n\n## Deploying your visualization to visuals.beadfamous.com\n\nBeadfamous has no backend. But you can still host your shader there.\nAny pull request that only touches files under the shaders/<YOUR_GITHUB_USERNAME> will be automatically merged to main and deployed to Beadfamous. If this is your first commit, it will require manual approval. Afterwards, all your shaders will be automatically deployed.\n\nMaking a pull request will usually mean you need to fork the repo, make your changes, and then make a pull request from your fork to the main repo. If you're not familiar with this process, here's a [tutorial](https://guides.github.com/activities/forking/).\n\nIf you want to quickly make a pull request without cloning the repo down, you can add your shader through the Github UI. Here's a quick guide:",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 89,
            "endLine": 120,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    const render = ({ time, features, vertexShader: newVertexShader, fragmentShader: newFragmentShader }) => {\n        if (newFragmentShader !== lastFragmentShader || newVertexShader !== lastVertexShader) {\n            console.log('Shader updated')\n            // Wrap the new fragment shader with any necessary transformations\n            const wrappedFragmentShader = shaderWrapper(newFragmentShader)\n            const wrappedVertexShader = shaderWrapper(newVertexShader)\n            // Update program with new shaders\n            const newProgramInfo = updateWebGLProgram(gl, wrappedVertexShader, wrappedFragmentShader)\n            console.log('newProgramInfo', newProgramInfo)\n\n            if (!newProgramInfo) {\n                programInfo = null\n                return\n            }\n\n            programInfo = newProgramInfo\n            lastVertexShader = newVertexShader\n            lastFragmentShader = newFragmentShader\n        }\n\n        if (!programInfo) return\n\n        const renderTime = performance.now()\n        let resolutionRatio = 1\n        if (renderTime - lastRender > 100) {\n            slowFrames++\n        }\n        if (slowFrames > 30) {\n            resolutionRatio = 0.5\n        }\n        resizeCanvasToDisplaySize(gl.canvas, resolutionRatio)\n        lastRender = renderTime",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 67,
            "endLine": 92,
            "text": "\n        var(--color-galaxy-blue),\n        var(--color-starlight-blue),\n        var(--color-deep-sky),\n        var(--color-twilight-purple),\n        var(--color-alien-green),\n        var(--color-rocket-metal),\n        var(--color-nebula-purple)\n    );\n    background-size: 800% 800%;\n    color: var(--color-lunar-white);\n}\n.sparkly.animated {\n    animation: sparkle 8s linear infinite;\n}\n\n/* Sparkly Animation */\n@keyframes sparkle {\n    0%,\n    100% {\n        background-position: 0% 50%;\n    }\n    50% {\n        background-position: 100% 50%;\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 109,
            "endLine": 118,
            "text": "const Analyzer = () => {\n    ...\n    const handleAnalyze = async (e) => {\n            ...\n            setStatus('Analysis complete!')\n            setHasResults(true)\n        } catch (error) {\n            console.error(error)\n            setStatus(`Error: ${error.message}`)\n            cleanup()\n        } finally {\n            setIsAnalyzing(false)\n        }\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".eslintrc",
            "startLine": 1,
            "endLine": 7,
            "text": "{\n    \"parserOptions\": {\n        \"ecmaVersion\": 2023,\n        \"sourceType\": \"module\"\n    }\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.css",
            "startLine": 1,
            "endLine": 75,
            "text": ".container {\n    max-width: 600px;\n    margin: 50px auto;\n    padding: 20px;\n    background: #f5f5f5;\n    border-radius: 8px;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n    display: flex;\n    gap: 10px;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 20px;\n    background: #ddd;\n    border-radius: 10px;\n    overflow: hidden;\n}\n\n.progress {\n    width: 0%;\n    height: 100%;\n    background: #4caf50;\n    transition: width 0.3s ease;\n}\n\n#status {\n    margin-top: 10px;\n    text-align: center;\n    color: #666;\n}\n\nbutton {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    background: #4caf50;\n    color: white;\n    cursor: pointer;\n}\n\nbutton:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n}\n\n.progress-bar-container {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    width: 100%;\n}\n\n.progress-bar {\n    flex-grow: 1;\n}\n\n.time-label {\n    font-family: monospace;\n    font-size: 14px;\n    color: #666;\n    min-width: 45px;\n}\n\n.time-current {\n    font-family: monospace;\n    font-size: 16px;\n    color: #333;\n    text-align: center;\n    margin: 5px 0;\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/midi.js",
            "startLine": 1,
            "endLine": 35,
            "text": "'use strict'\n\n// Unified function to update knob value in URL\nfunction updateKnobValue(knob, value) {\n    const currentUrl = new URL(window.location)\n    let current = parseFloat(currentUrl.searchParams.get(knob) ?? 0)\n    // get the min and max value for the knob from knob_0.min and knob_0.max in the query params\n    const min = parseFloat(currentUrl.searchParams.get(`${knob}.min`) ?? 0)\n    const max = parseFloat(currentUrl.searchParams.get(`${knob}.max`) ?? 1)\n    // the incoming knob value is between 0 and 127, so we need to scale it to the min and max values\n    if (!window.cranes.updateFeature) return\n    current = (value / 127) * (max - min) + min\n    window.cranes.updateFeature(knob, current)\n}\n\n// MIDI Access request\nnavigator\n    .requestMIDIAccess()\n    .then((midiAccess) => {\n        console.log('MIDI ready')\n        midiAccess.inputs.forEach((input) => {\n            input.onmidimessage = (message) => {\n                const [command, control, value] = message.data\n                // Listen for Control Change messages from knobs\n                if (command === 176) {\n                    let knobNumber = control\n                    let knob = `knob_${knobNumber}`\n                    updateKnobValue(knob, value)\n                }\n            }\n        })\n    })\n    .catch((error) => {\n        console.error('MIDI failed to start', error)\n    })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".gitignore",
            "startLine": 1,
            "endLine": 66,
            "text": "# Logs\nlogs\n*.log\n*.log*\n\n# Diagnostic reports (https://nodejs.org/api/report.html)\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n#platform.io output\n.pio/\n# Coverage directory used by tools like istanbul\ncoverage\n*.lcov\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# TypeScript v1 declaration files\ntypings/\n\n# TypeScript cache\n*.tsbuildinfo\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n*.tar*",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 248,
            "endLine": 257,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      },\n    },\n    \".\", // Trigger completion on dot\n    \" \", // Trigger completion on space\n  );\n\n  // Register hover provider\n  const hoverProvider = vscode.languages.registerHoverProvider(\n    { scheme: \"file\", language: \"paper-cranes-fragment-shader\" },\n    {",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/AudioProcessor.js",
            "startLine": 1,
            "endLine": 32,
            "text": "import { StatTypes } from 'hypnosound'\nimport { WorkerRPC } from './WorkerRPC'\n\nexport const AudioFeatures = [\n    'SpectralCentroid',\n    'SpectralFlux',\n    'SpectralSpread',\n    'SpectralRolloff',\n    'SpectralRoughness',\n    'SpectralKurtosis',\n    'Energy',\n    'SpectralEntropy',\n    'SpectralCrest',\n    'SpectralSkew',\n    'PitchClass',\n    'Bass',\n    'Mids',\n    'Treble',\n]\n\nexport const getFlatAudioFeatures = (audioFeatures = AudioFeatures, rawFeatures = {}) => {\n    const features = {}\n    for (const feature of audioFeatures) {\n        const featureKey = feature.charAt(0).toLowerCase() + feature.slice(1)\n        for (const propertyKey of StatTypes) {\n            const key = `${featureKey}${propertyKey.charAt(0).toUpperCase() + propertyKey.slice(1)}`\n            features[key] = rawFeatures[feature]?.stats[propertyKey]\n        }\n        features[featureKey] = rawFeatures[feature]?.stats?.current\n    }\n    return features\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 120,
            "endLine": 172,
            "text": "const Analyzer = () => {\n    ...\n    const downloadData = (data, filename) => {\n        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' })\n        const url = URL.createObjectURL(blob)\n        const a = document.createElement('a')\n        a.href = url\n        a.download = filename\n        document.body.appendChild(a)\n        a.click()\n        document.body.removeChild(a)\n        URL.revokeObjectURL(url)\n    }\n\n    const handleDownload = () => {\n        downloadData(analysisResults.current, `${inputFileName}-analysis.json`)\n    }\n\n    const handleDownloadNormalized = () => {\n        const { normalized, ranges } = normalizeAnalysisData(analysisResults.current)\n        downloadData(normalized, `${inputFileName}-normalized.json`)\n        downloadData(ranges, `${inputFileName}-normalized-ranges.json`)\n    }\n\n    return html`\n        <div class=\"container\">\n            <form class=\"upload-section\">\n                <input type=\"file\" accept=\"audio/mp3\" onChange=${handleFileChange} disabled=${isAnalyzing} />\n                <button type=\"button\" onClick=${handleAnalyze} disabled=${isAnalyzing}>Analyze</button>\n                <div class=\"download-buttons\">\n                    <button type=\"button\" onClick=${handleDownload} disabled=${!hasResults}>Download Results</button>\n                    <button type=\"button\" onClick=${handleDownloadNormalized} disabled=${!hasResults}>Download Normalized</button>\n                </div>\n            </form>\n\n            <div class=\"progress-section\">\n                <div class=\"progress-bar-container\">\n                    <span class=\"time-label\">${timeInfo.start}</span>\n                    <div class=\"progress-bar\">\n                        <div class=\"progress\" style=${`width: ${progress}%`} />\n                    </div>\n                    <span class=\"time-label\">${timeInfo.end}</span>\n                </div>\n                <div class=\"time-current\">${timeInfo.current}</div>\n                <div id=\"status\">${status}</div>\n            </div>\n\n            <${BarGraph} features=${currentFeatures} />\n            <pre class=\"analysis-display\">\n                ${JSON.stringify(currentFeatures, null, 2)}\n            </pre\n            >\n        </div>\n    `\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 58,
            "endLine": 89,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    const gl = canvas.getContext('webgl2', { antialias: false })\n    if (fullscreen) {\n        const width = window.innerWidth\n        const height = window.innerHeight\n        canvas.width = width\n        canvas.height = height\n        gl.viewport(0, 0, width, height)\n        canvas.classList.add('fullscreen')\n    }\n    const ext = gl.getExtension('GMAN_debug_helper')\n    if (ext) {\n        ext.setConfiguration({\n            failUnsetUniforms: false,\n        })\n    }\n    const initialTexture = await getTexture(gl, initialImageUrl)\n    const frameBuffers = [createFramebufferInfo(gl), createFramebufferInfo(gl)]\n    const gridPositions = generateGridPositions(gridSize)\n    const arrays = { position: gridPositions }\n    const bufferInfo = createBufferInfoFromArrays(gl, arrays)\n\n    let frameNumber = 0\n    let slowFrames = 0\n    let lastRender = performance.now()\n    let programInfo\n    // Assuming the other parts of the code remain the same\n\n    let lastVertexShader = undefined // Initial vertex shader\n    let lastFragmentShader = undefined // Placeholder for initial fragment shader\n\n    const render",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 1,
            "endLine": 3,
            "text": "import * as vscode from \"vscode\";\n\nconsole.log(\"\ud83c\udfee Paper Cranes Extension Exists \ud83c\udfee\");",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/package.json",
            "startLine": 1,
            "endLine": 89,
            "text": "{\n  \"name\": \"paper-cranes-shader-vscode-extension\",\n  \"version\": \"1.3.0\",\n  \"publisher\": \"hypnodroid\",\n  \"repository\": \"https://github.com/hypnodroid/paper-cranes\",\n  \"readme\": \"README.md\",\n  \"displayName\": \"Paper Cranes Shader Syntax\",\n  \"description\": \"Language support for Paper Cranes audio visualization shaders\",\n  \"icon\": \"logo.png\",\n  \"main\": \"./out/index.js\",\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"package\": \"vsce package -o extension.vsix\",\n    \"build\": \"rm -rf out && npm run compile && npm run package\",\n    \"debug\": \"npm run compile && code --extensionDevelopmentPath=${PWD} ../shaders/plasma.frag\"\n  },\n  \"engines\": {\n    \"vscode\": \"^1.93.1\"\n  },\n  \"categories\": [\n    \"Programming Languages\"\n  ],\n  \"contributes\": {\n    \"languages\": [\n      {\n        \"id\": \"paper-cranes-fragment-shader\",\n        \"aliases\": [\n          \"Paper Cranes Visualization\",\n          \"GLSL\",\n          \"glsl\"\n        ],\n        \"extensions\": [\n          \".frag\",\n          \".vert\",\n          \".glsl\",\n          \".crane\"\n        ],\n        \"configuration\": \"./language-configuration.json\"\n      }\n    ],\n    \"grammars\": [\n      {\n        \"language\": \"paper-cranes-fragment-shader\",\n        \"scopeName\": \"source.paper-cranes-fragment-shader\",\n        \"path\": \"./paper-cranes-fragment-shader.tmLanguage.json\",\n        \"embeddedLanguages\": {\n          \"source.glsl\": \"glsl\"\n        }\n      }\n    ],\n    \"configurationDefaults\": {\n      \"files.associations\": {\n        \"*.frag\": \"paper-cranes-fragment-shader\",\n        \"*.vert\": \"paper-cranes-fragment-shader\",\n        \"*.glsl\": \"paper-cranes-fragment-shader\",\n        \"*.crane\": \"paper-cranes-fragment-shader\"\n      }\n    },\n    \"commands\": [\n      {\n        \"command\": \"paper-cranes-fragment-shader.activate\",\n        \"title\": \"Activate Paper Cranes Shader\"\n      }\n    ]\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.x\",\n    \"@types/vscode\": \"^1.93.1\",\n    \"@vscode/vsce\": \"^3.x\",\n    \"typescript\": \"^5.x\"\n  },\n  \"files\": [\n    \"logo.png\",\n    \"out/**\",\n    \"language-configuration.json\",\n    \"LICENSE\",\n    \"paper-cranes-fragment-shader.tmLanguage.json\"\n  ],\n  \"extensionDependencies\": [\n    \"slevesque.shader\"\n  ],\n  \"activationEvents\": [\n    \"onLanguage:paper-cranes-fragment-shader\",\n    \"onCommand:paper-cranes-fragment-shader.activate\"\n  ]\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 190,
            "endLine": 307,
            "text": "function init() {\n        ...\n        'return',\n        'sampler2D',\n        'samplerCube',\n        'sampler3D',\n        'struct',\n        'radians',\n        'degrees',\n        'sin',\n        'cos',\n        'tan',\n        'asin',\n        'acos',\n        'atan',\n        'pow',\n        'sinh',\n        'cosh',\n        'tanh',\n        'asinh',\n        'acosh',\n        'atanh',\n        'exp',\n        'log',\n        'exp2',\n        'log2',\n        'sqrt',\n        'inversesqrt',\n        'abs',\n        'sign',\n        'floor',\n        'ceil',\n        'round',\n        'roundEven',\n        'trunc',\n        'fract',\n        'mod',\n        'modf',\n        'min',\n        'max',\n        'clamp',\n        'mix',\n        'step',\n        'smoothstep',\n        'length',\n        'distance',\n        'dot',\n        'cross ',\n        'determinant',\n        'inverse',\n        'normalize',\n        'faceforward',\n        'reflect',\n        'refract',\n        'matrixCompMult',\n        'outerProduct',\n        'transpose',\n        'lessThan ',\n        'lessThanEqual',\n        'greaterThan',\n        'greaterThanEqual',\n        'equal',\n        'notEqual',\n        'any',\n        'all',\n        'not',\n        'packUnorm2x16',\n        'unpackUnorm2x16',\n        'packSnorm2x16',\n        'unpackSnorm2x16',\n        'packHalf2x16',\n        'unpackHalf2x16',\n        'dFdx',\n        'dFdy',\n        'fwidth',\n        'textureSize',\n        'texture',\n        'textureProj',\n        'textureLod',\n        'textureGrad',\n        'texelFetch',\n        'texelFetchOffset',\n        'textureProjLod',\n        'textureLodOffset',\n        'textureGradOffset',\n        'textureProjLodOffset',\n        'textureProjGrad',\n        'intBitsToFloat',\n        'uintBitsToFloat',\n        'floatBitsToInt',\n        'floatBitsToUint',\n        'isnan',\n        'isinf',\n        'vec2',\n        'vec3',\n        'vec4',\n        'ivec2',\n        'ivec3',\n        'ivec4',\n        'uvec2',\n        'uvec3',\n        'uvec4',\n        'bvec2',\n        'bvec3',\n        'bvec4',\n        'mat2',\n        'mat3',\n        'mat2x2',\n        'mat2x3',\n        'mat2x4',\n        'mat3x2',\n        'mat3x3',\n        'mat3x4',\n        'mat4x2',\n        'mat4x3',\n        'mat4x4',\n        'mat4',\n        'float',\n        'int',\n        'uint'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 308,
            "endLine": 362,
            "text": "function init() {\n        ...\n        'void',\n        'bool',\n    ]\n\n    const language = {\n        tokenPostfix: '.glsl',\n        // Set defaultToken to invalid to see what you do not tokenize yet\n        defaultToken: 'invalid',\n        keywords,\n        operators: [\n            '=',\n            '>',\n            '<',\n            '!',\n            '~',\n            '?',\n            ':',\n            '==',\n            '<=',\n            '>=',\n            '!=',\n            '&&',\n            '||',\n            '++',\n            '--',\n            '+',\n            '-',\n            '*',\n            '/',\n            '&',\n            '|',\n            '^',\n            '%',\n            '<<',\n            '>>',\n            '>>>',\n            '+=',\n            '-=',\n            '*=',\n            '/=',\n            '&=',\n            '|=',\n            '^=',\n            '%=',\n            '<<=',\n            '>>=',\n            '>>>=',\n        ],\n        symbols: /[=><!~?:&|+\\-*\\/\\^%]+/,\n        escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n        integersuffix: /([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,\n        floatsuffix: /[fFlL]?/,\n        encoding: /u|u8|U|L/,\n\n        tokenizer: {",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".github/workflows/submit-shader.yml",
            "startLine": 28,
            "endLine": 40,
            "text": "\n                      const isValidScope = filesChanged.data.every(file => {\n                        const inUserFolder = file.filename.startsWith(`shaders/${username}/`);\n                        const isFragmentShader = file.filename.endsWith('.frag');\n                        return inUserFolder && isFragmentShader;\n                      });\n\n                      core.setOutput('valid_scope', isValidScope.toString());\n                      if (!isValidScope) {\n                        console.log(\"PR contains changes outside the user's specific directory.\");\n                      } else {\n                        console.log(\"All changes are within the user's specific directory.\");\n                      }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 122,
            "endLine": 155,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    const render = ({ time, features, vertexShader: newVertexShader, fragmentShader: newFragmentShader }) => {\n        ...\n        const frame = frameBuffers[frameNumber % 2]\n        const prevFrame = frameBuffers[(frameNumber + 1) % 2]\n\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)\n\n        const uniforms = {\n            time,\n            prevFrame: frameNumber === 0 ? initialTexture : prevFrame.attachments[0],\n            initialFrame: initialTexture,\n            resolution: [frame.width, frame.height],\n            frame: frameNumber,\n            iRandom: Math.random(),\n            iResolution: [frame.width, frame.height, 0],\n            iMouse: [46, 19, 208, 0],\n            iTime: time,\n            iChannel0: initialTexture,\n            iChannel1: prevFrame.attachments[0],\n            iChannel2: initialTexture,\n            iChannel3: prevFrame.attachments[0],\n            gridSize,\n            ...features,\n        }\n\n        const nonNullOrUndefinedOrNanUniforms = Object.fromEntries(\n            Object.entries(uniforms).filter(([, value]) => {\n                return value !== null && value !== undefined && !Number.isNaN(value)\n            }),\n        )\n\n        setBuffersAndAttributes(gl, programInfo, bufferInfo)\n        setUniforms(programInfo, nonNullOrUndefinedOrNanUniforms)\n        drawBufferInfo(gl, bufferInfo)\n\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/shader-transformers/shader-wrapper.js",
            "startLine": 55,
            "endLine": 171,
            "text": "const paperCranes = () => /* glsl */ `\n\nuniform float time;\nuniform vec2 resolution;// iResolution equivalent\n\nuniform int frame;\n\nuniform sampler2D prevFrame;// Texture of the previous frame\nuniform sampler2D initialFrame;\n\nuniform float iRandom;\n\nfloat random(vec2 st, float seed){\n    st=vec2(st.x*cos(seed)-st.y*sin(seed),\n    st.x*sin(seed)+st.y*cos(seed));\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 11118.5453123);\n}\n\nfloat random(vec2 st){\n    return random(st, iRandom);\n}\n\nfloat staticRandom(vec2 st){\n    return random(st, 0.);\n}\n\nfloat mapValue(float val, float inMin, float inMax, float outMin, float outMax) {\n    float normalized =  outMin + (outMax - outMin) * (val - inMin) / (inMax - inMin);\n    return clamp(normalized, outMin, outMax);\n}\n\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl){\nfloat h=hsl.x;\nfloat s=hsl.y;\nfloat l=hsl.z;\n\nfloat r,g,b;\n\nif(s==0.f){\n  r=g=b=l;// achromatic\n}else{\n  float q=l<.5f?l*(1.f+s):l+s-l*s;\n  float p=2.f*l-q;\n  r=hue2rgb(p,q,h+1.f/3.f);\n  g=hue2rgb(p,q,h);\n  b=hue2rgb(p,q,h-1.f/3.f);\n}\n\nreturn vec3(r,g,b);\n}\n\nvec3 rgb2hsl(vec3 color){\n    float maxColor=max(max(color.r,color.g),color.b);\n    float minColor=min(min(color.r,color.g),color.b);\n    float delta=maxColor-minColor;\n\n    float h=0.f;\n    float s=0.f;\n    float l=(maxColor+minColor)/2.f;\n\n    if(delta!=0.f){\n      s=l<.5f?delta/(maxColor+minColor):delta/(2.f-maxColor-minColor);\n\n      if(color.r==maxColor){\n        h=(color.g-color.b)/delta+(color.g<color.b?6.f:0.f);\n      }else if(color.g==maxColor){\n        h=(color.b-color.r)/delta+2.f;\n      }else{\n        h=(color.r-color.g)/delta+4.f;\n      }\n      h/=6.f;\n    }\n\n    return vec3(h,s,l);\n  }\n\n  vec2 centerUv(vec2 res, vec2 coord) {\n    // step 1: normalize the coord to 0-1\n    vec2 uv = coord.xy / res;\n    // step 2: center the uv\n    uv -= 0.5;\n    // step 3: scale the uv to -1 to 1\n    uv *= 2.0;\n    uv += 0.5;\n    return uv;\n}\n\nvec2 centerUv(vec2 coord) {\n    return centerUv(resolution, coord);\n}\n\nvec3 hslmix(vec3 c1, vec3 c2, float t){\n    vec3 hsl1 = rgb2hsl(c1);\n    vec3 hsl2 = rgb2hsl(c2);\n    vec3 hsl = mix(hsl1, hsl2, t);\n    return hsl2rgb(hsl);\n    }\n`\nexport default shaderWrapper",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 15,
            "endLine": 54,
            "text": "const Analyzer = () => {\n    // UI State\n    const [status, setStatus] = useState('Upload an MP3 file to begin')\n    const [progress, setProgress] = useState(0)\n    const [isAnalyzing, setIsAnalyzing] = useState(false)\n    const [hasResults, setHasResults] = useState(false)\n    const [inputFileName, setInputFileName] = useState('audio')\n    const [timeInfo, setTimeInfo] = useState({\n        current: '0:00',\n        start: '0:00',\n        end: '0:00',\n    })\n    const [currentFeatures, setCurrentFeatures] = useState({ ready: 0 })\n\n    // Audio State\n    const analysisResults = useRef([])\n    const audioContext = useRef(null)\n    const source = useRef(null)\n    const processor = useRef(null)\n\n    const handleFileChange = (e) => {\n        const file = e.target.files?.[0]\n        if (!file) {\n            setStatus('Upload an MP3 file to begin')\n            return\n        }\n\n        const fullName = file.name\n        setInputFileName(fullName.substring(0, fullName.lastIndexOf('.')) || fullName)\n        setHasResults(false)\n        setStatus('Click Analyze to begin')\n    }\n\n    const cleanup = () => {\n        source.current?.stop()\n        audioContext.current?.close()\n        source.current = null\n        audioContext.current = null\n        processor.current = null\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 1,
            "endLine": 15,
            "text": "import { render } from 'preact'\nimport { useState, useRef } from 'preact/hooks'\nimport { html } from 'htm/preact'\nimport { AudioProcessor } from './src/audio/AudioProcessor'\nimport { normalizeAnalysisData } from './src/audio/normalizer'\nimport BarGraph from './src/components/BarGraph'\n\nconst formatTime = (ms) => {\n    const totalSeconds = Math.floor(ms / 1000)\n    const minutes = Math.floor(totalSeconds / 60)\n    const seconds = totalSeconds % 60\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`\n}\n\nconst Analyzer",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 102,
            "endLine": 189,
            "text": "function init() {\n        ...\n        'spectralCrestMedian',\n        'spectralCrestZScore',\n        'spectralCrestMin',\n        'spectralCrestMax',\n        'spectralSkew',\n        'spectralSkewNormalized',\n        'spectralSkewMean',\n        'spectralSkewStandardDeviation',\n        'spectralSkewMedian',\n        'spectralSkewZScore',\n        'spectralSkewMin',\n        'spectralSkewMax',\n        'pitchClass',\n        'pitchClassNormalized',\n        'pitchClassMean',\n        'pitchClassStandardDeviation',\n        'pitchClassMedian',\n        'pitchClassZScore',\n        'pitchClassMin',\n        'pitchClassMax',\n        'hslmix',\n        'hsl2rgb',\n        'rgb2hsl',\n        'map',\n\n        'energy',\n        'energyNormalized',\n        'energyMean',\n        'energyStandardDeviation',\n        'energyMedian',\n        'energyZScore',\n        'energyMin',\n        'energyMax',\n\n        'bass',\n        'bassNormalized',\n        'bassMean',\n        'bassStandardDeviation',\n        'bassMedian',\n        'bassZScore',\n        'bassMin',\n        'bassMax',\n\n        'mids',\n        'midsNormalized',\n        'midsMean',\n        'midsStandardDeviation',\n        'midsMedian',\n        'midsZScore',\n        'midsMin',\n        'midsMax',\n\n        'treble',\n        'trebleNormalized',\n        'trebleMean',\n        'trebleStandardDeviation',\n        'trebleMedian',\n        'trebleZScore',\n        'trebleMin',\n        'trebleMax',\n\n        'spectralFlux',\n        'spectralFluxNormalized',\n        'spectralFluxMean',\n        'spectralFluxStandardDeviation',\n        'spectralFluxMedian',\n        'spectralFluxZScore',\n        'spectralFluxMin',\n        'spectralFluxMax',\n        'random',\n        'const',\n        'uniform',\n        'break',\n        'continue',\n        'do',\n        'for',\n        'while',\n        'if',\n        'else',\n        'switch',\n        'case',\n        'in',\n        'out',\n        'inout',\n        'true',\n        'false',\n        'invariant',\n        'discard'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/window-processor.js",
            "startLine": 1,
            "endLine": 31,
            "text": "class WindowProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [] // Add any parameters you might need, like window type\n    }\n\n    constructor() {\n        super()\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0]\n        const output = outputs[0]\n\n        if (input.length > 0) {\n            const windowLength = input[0].length\n            for (let channel = 0; channel < input.length; channel++) {\n                const inputChannel = input[channel]\n                const outputChannel = output[channel]\n                for (let i = 0; i < windowLength; i++) {\n                    // Apply a Hanning window as an example\n                    const windowCoeff = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (windowLength - 1)))\n                    outputChannel[i] = inputChannel[i] * windowCoeff\n                }\n            }\n        }\n\n        return true // Keep processor alive\n    }\n}\n\nregisterProcessor('window-processor', WindowProcessor)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/tsconfig.json",
            "startLine": 1,
            "endLine": 21,
            "text": "{\n    \"compilerOptions\": {\n        \"module\": \"nodenext\",\n        \"target\": \"ES2022\",\n        \"outDir\": \"out\",\n        \"rootDir\": \".\",\n        \"sourceMap\": true,\n        \"strict\": true,\n        \"esModuleInterop\": true,\n        \"noImplicitAny\": false\n    },\n    \"include\": [\n        \"**/*.ts\",\n        \"**/*.js\"\n    ],\n    \"exclude\": [\n        \"node_modules\",\n        \".vscode-test\"\n    ]\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/Treble.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { treble, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = treble(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 5,
            "endLine": 11,
            "text": "export function activate(context: vscode.ExtensionContext) {\n  console.log(\"\ud83c\udfee Paper Cranes Extension Activated \ud83c\udfee\");\n\n  // Register completion provider\n  const completionProvider = vscode.languages.registerCompletionItemProvider(\n    { scheme: \"file\", language: \"paper-cranes-fragment-shader\" },\n    {",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 20,
            "endLine": 59,
            "text": "const FeatureEditor = ({ name, feature, onChange, onDelete }) => {\n    const handleValueChange = (e) => onChange(name, { ...feature, value: parseFloat(e.target.value) })\n    const handleMinChange = (e) => onChange(name, { ...feature, min: parseFloat(e.target.value) })\n    const handleMaxChange = (e) => onChange(name, { ...feature, max: parseFloat(e.target.value) })\n    const handleCommitValue = () => {\n        delete window.cranes?.manualFeatures[name]\n        updateUrlDebounced({ [name]: feature.value })\n    }\n    // Update the URL immediately for live updates\n    useEffect(() => {\n        updateUrlDebounced({\n            [name]: feature.value,\n            [`${name}.min`]: feature.min,\n            [`${name}.max`]: feature.max,\n        })\n        if (window.cranes?.manualFeatures) {\n            window.cranes.manualFeatures[name] = feature.value\n        }\n    }, [feature])\n\n    return html`\n        <div className=\"edit-feature\" key=${name}>\n            <label>${name}:</label>\n            <input class=\"min-feature-value\" type=\"number\" step=\"0.1\" value=${feature.min} onInput=${handleMinChange} />\n            <input\n                class=\"feature-value\"\n                type=\"range\"\n                min=${feature.min}\n                max=${feature.max}\n                step=\"0.01\"\n                value=${feature.value}\n                onInput=${handleValueChange}\n                onChange=${handleCommitValue}\n            />\n            <span> (${feature.value})</span>\n            <input class=\"max-feature-value\" type=\"number\" step=\"0.1\" value=${feature.max} onInput=${handleMaxChange} />\n            <button onClick=${() => onDelete(name)}>x</button>\n        </div>\n    `\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/LICENSE",
            "startLine": 1,
            "endLine": 21,
            "text": "MIT License\n\nCopyright (c) 2025 Loqwai\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "BarGraph.css",
            "startLine": 1,
            "endLine": 72,
            "text": ".bar-graph {\n    background: #1a1a1a;\n    padding: 1rem;\n    border-radius: 4px;\n    margin: 1rem 0;\n    font-family: monospace;\n}\n\n.bar-row {\n    display: flex;\n    align-items: center;\n    height: 30px;\n    margin: 4px 0;\n}\n\n.negative-space {\n    flex: 1;\n    display: flex;\n    justify-content: flex-end;\n    position: relative;\n}\n\n.positive-space {\n    flex: 1;\n    position: relative;\n}\n\n.feature-name {\n    padding: 0 1rem;\n    color: #fff;\n    width: 180px;\n    text-align: center;\n    font-size: 0.9rem;\n    background: #333;\n    margin: 0 2px;\n    border-radius: 2px;\n}\n\n.bar {\n    position: absolute;\n    height: 16px;\n    top: 50%;\n    transform: translateY(-50%);\n}\n\n.bar.positive {\n    left: 0;\n    background: #4caf50;\n    border-radius: 0 2px 2px 0;\n}\n\n.bar.negative {\n    right: 0;\n    background: #f44336;\n    border-radius: 2px 0 0 2px;\n}\n\n.value {\n    width: 60px;\n    padding-left: 1rem;\n    color: #fff;\n    font-size: 0.9rem;\n}\n\n.filter-controls {\n    display: flex;\n    gap: 1rem;\n    margin-bottom: 1rem;\n    padding: 0.5rem;\n    background: #333;\n    border-radius: 4px;\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "shaders/redaphid/wip/orbit/TODO.md",
            "startLine": 1,
            "endLine": 10,
            "text": "TODO.md\n\n# Checking\n\n-   Up to rain\n\n## Needs repair\n\n-   moody octopus\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/Bass.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { bass, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = bass(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "working-shaders.txt",
            "startLine": 1,
            "endLine": 9,
            "text": "beat-trip\ndance-hole\nmanda\nmoody-octopus\nshape-emitter\nslug\nstarfish\nstar\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 144,
            "endLine": 144,
            "text": "render(html`<${FeatureAdder} />`, document.getElementById('feature-editor'))",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 43,
            "endLine": 51,
            "text": "\n1. Start creating a new file in the `shaders/` directory of the paper-cranes repo [here](https://github.com/loqwai/paper-cranes/new/main/shaders).\n\nThis will automatically fork the repo to your account, and create a new file in your fork.\n\n2. After the fork is created, you can add your shader to the project. The shader must be added to `shaders/<YOUR_GITHUB_USERNAME>/`. For example, if your github username is `loqwai`, you would add your shader to `shaders/loqwai/`. You can create the directory by adding a `/` to the end of the path in the file creation dialog.\n\n3. After you've added your shader, you can create a pull request to the main repo. This will automatically trigger a deployment to [visuals.beadfamous.com](https://visuals.beadfamous.com). For example if your shader is file located at `shaders/loqwai/my_new_shader.frag`, the visualization will be available at `visuals.beadfamous.com/?shader=loqwai/my_new_shader`\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/shader-transformers/shader-wrapper.js",
            "startLine": 1,
            "endLine": 53,
            "text": "import { getFlatAudioFeatures } from '../audio/AudioProcessor'\n\nexport const shaderWrapper = (shader) => {\n    const [firstLine, ...lines] = shader.split('\\n')\n    if (firstLine.includes('#version')) {\n        lines.unshift('#define PAPER_CRANES 1')\n        lines.unshift(firstLine)\n        return lines.join('\\n')\n    }\n    if (shader.includes('mainImage')) {\n        return /* glsl */ `\n#version 300 es\nprecision mediump float;\n\nout vec4 fragColor;\n${shaderToyCompatibilityUniforms()}\n${getAudioUniforms()}\n\n${paperCranes()}\nvec4 getLastFrameColor(vec2 uv){\n    return texture(prevFrame, uv);\n}\nvec4 getInitialFrameColor(vec2 uv){\n    return texture(initialFrame, uv);\n}\n${shader}\n\nvoid main(void){\n    mainImage(fragColor, gl_FragCoord.xy);\n}\n`\n    }\n    throw new Error('Shader does not contain mainImage function. It should look like this: void mainImage( out vec4 fragColor, in vec2 fragCoord ) { ... }')\n}\n\nconst shaderToyCompatibilityUniforms = () => /* glsl */ `\nuniform vec4 iMouse;\nuniform float iTime;\nuniform vec3 iResolution;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\nuniform int iFrame;\n`\nconst getAudioUniforms = () => {\n    const uniforms = []\n    for (const f in getFlatAudioFeatures()) {\n        uniforms.push(`uniform float ${f};`)\n    }\n    uniforms.push('uniform bool beat;') // yeah, this needs to go somewhere else\n    return uniforms.join('\\n')\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "shaders/synthwave.frag",
            "startLine": 37,
            "endLine": 74,
            "text": "\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n\n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n\n    return min(uniVal1, uniVal2);\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "shaders/synthwave.frag",
            "startLine": 128,
            "endLine": 145,
            "text": "\n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            if(beat) cloudTime += 0.5;\n            float cloudY = -0.5;\n            float cloudVal1 = sdCloud(cloudUV,\n                                     vec2(0.1 + sin(cloudTime + spectralSpreadNormalized + 140.5)*0.1,cloudY),\n                                     vec2(1.05 + cos(cloudTime + spectralSpreadNormalized * 0.9 - 36.56) * 0.1, cloudY),\n                                     vec2(0.2 + cos(cloudTime + spectralSpreadNormalized * 0.867 + 387.165) * 0.1,0.25+cloudY),\n                                     vec2(0.5 + cos(cloudTime + spectralSpreadNormalized * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.6;\n            float cloudVal2 = sdCloud(cloudUV,\n                                     vec2(-0.9 + cos(cloudTime + spectralSpreadNormalized * 1.02 + 541.75) * 0.1,cloudY),\n                                     vec2(-0.5 + sin(cloudTime + spectralSpreadNormalized * 0.9 - 316.56) * 0.1, cloudY),\n                                     vec2(-1.5 + cos(cloudTime + spectralSpreadNormalized * 0.867 + 37.165) * 0.1,0.25+cloudY),\n                                     vec2(-0.6 + sin(cloudTime + spectralSpreadNormalized * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 12,
            "endLine": 89,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n        console.log(\"Providing completions for\", document.uri.toString());\n\n        // GLSL Keywords\n        const glslKeywords = [\n          \"const\",\n          \"uniform\",\n          \"break\",\n          \"continue\",\n          \"do\",\n          \"for\",\n          \"while\",\n          \"if\",\n          \"else\",\n          \"switch\",\n          \"case\",\n          \"in\",\n          \"out\",\n          \"inout\",\n          \"true\",\n          \"false\",\n          \"invariant\",\n          \"discard\",\n          \"return\",\n          \"void\",\n          \"bool\",\n          \"int\",\n          \"float\",\n          \"vec2\",\n          \"vec3\",\n          \"vec4\",\n          \"mat2\",\n          \"mat3\",\n          \"mat4\",\n          \"sampler2D\",\n          \"struct\",\n        ];\n\n        // GLSL Built-in Functions\n        const glslFunctions = [\n          \"radians\",\n          \"degrees\",\n          \"sin\",\n          \"cos\",\n          \"tan\",\n          \"asin\",\n          \"acos\",\n          \"atan\",\n          \"pow\",\n          \"exp\",\n          \"log\",\n          \"exp2\",\n          \"log2\",\n          \"sqrt\",\n          \"inversesqrt\",\n          \"abs\",\n          \"sign\",\n          \"floor\",\n          \"ceil\",\n          \"fract\",\n          \"mod\",\n          \"min\",\n          \"max\",\n          \"clamp\",\n          \"mix\",\n          \"step\",\n          \"smoothstep\",\n          \"length\",\n          \"distance\",\n          \"dot\",\n          \"cross\",\n          \"normalize\",\n          \"reflect\",\n          \"refract\",\n          \"texture2D\",\n          \"dFdx\",\n          \"dFdy\",\n        ];",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 174,
            "endLine": 174,
            "text": "render(html`<${Analyzer} />`, document.body)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".cursorrules",
            "startLine": 21,
            "endLine": 59,
            "text": "\n```glsl\n#version 300 es\nprecision mediump float;\nout vec4 fragColor;\nuniform vec4 iMouse;\nuniform float iTime;\nuniform vec3 iResolution;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\nuniform int iFrame;\n\nuniform float spectralCentroidNormalized;\nuniform float spectralCentroidMean;\nuniform float spectralCentroidMedian;\nuniform float spectralCentroidStandardDeviation;\nuniform float spectralCentroidZScore;\nuniform float spectralCentroidMin;\nuniform float spectralCentroidMax;\nuniform float spectralCentroid;\nuniform float spectralFluxNormalized;\nuniform float spectralFluxMean;\nuniform float spectralFluxMedian;\nuniform float spectralFluxStandardDeviation;\nuniform float spectralFluxZScore;\nuniform float spectralFluxMin;\nuniform float spectralFluxMax;\nuniform float spectralFlux;\nuniform float spectralSpreadNormalized;\nuniform float spectralSpreadMean;\nuniform float spectralSpreadMedian;\nuniform float spectralSpreadStandardDeviation;\nuniform float spectralSpreadZScore;\nuniform float spectralSpreadMin;\nuniform float spectralSpreadMax;\nuniform float spectralSpread;\nuniform float spectralRolloffNormalized;",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "shaders/practice/wave.frag",
            "startLine": 1,
            "endLine": 37,
            "text": "\n// #pragma glslify: import(./includes/shadertoy-compat)\n/* \"Wired\" by @kishimisu (2024)\n\n   I wonder what it's powering...\n*/\n\n#define r(a)    mat2(cos(a + vec4(0,33,11,0)));\n#define R(p, T) p.yx *= r(round((atan(p.y, p.x) + T) * 1.91) / 1.91 - T)\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float i, t, d, k = iTime/8.;\n\n    for (O *= i; i < 35.; i++) {\n        vec3 R = iResolution,\n             p = t * normalize(vec3(F+F-R.xy, R.y));\n\n        p.z  -= spectralRoughnessZScore + 3.;\n        p.xz *= r(k+spectralEntropyZScore*2.)\n        p.zy *= r(k+k)\n        d = length(p) - sin(k+k)*spectralRolloffNormalized -spectralKurtosisNormalized;\n\n        p.y  += sin(p.x*3. * cos(k+k) + k*4.) * sin(k)*.3;\n        R(p, 0.)\n        R(p.xz, k)\n        p.x = mod(p.x + k*8., 2.) - 1.;\n\n        t += d = min(d, length(p.yz) - (energyZScore/2.))*spectralCentroid;\n        O += .01 * (1. + cos(t*.5 - k-k + vec4(0,1,2,0)))\n                 / (1. + length(p)*4. - .02) + (.03 + sin(k)*.01) / (1. + d*24.);\n    }\n    vec3 hslBg = vec3(spectralCentroid,1.,0.8);\n\n    O *= vec4(hsl2rgb(hslBg), 1.);\n}\n// #pragma glslify:import(./includes/shadertoy-compat-main)\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".github/workflows/submit-shader.yml",
            "startLine": 41,
            "endLine": 54,
            "text": "\n            - name: Merge PR if only user directory is changed and checks passed\n              if: steps.scope_check.outputs.valid_scope == 'true'\n              uses: actions/github-script@v7.0.1\n              with:\n                  github-token: ${{ secrets.GITHUB_TOKEN }}\n                  script: |\n                      github.rest.pulls.merge({\n                        owner: context.repo.owner,\n                        repo: context.repo.repo,\n                        pull_number: context.payload.pull_request.number,\n                        merge_method: 'squash'\n                      });\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        }
      ],
      "intermediateSectionType": "codebase",
      "statusUpdates": {
        "updates": []
      },
      "capabilityStatuses": {
        "mutate-request": [],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": [
          {
            "type": 15,
            "status": "completed"
          }
        ]
      }
    },
    {
      "type": 1,
      "bubbleId": "33a3d64e-baed-40d5-ad84-89b610399834",
      "suggestedCodeBlocks": [],
      "relevantFiles": [
        "webpack.config.js",
        "service-worker.js",
        "esbuild.js",
        "src/audio/WorkerRPC.js",
        "index.js",
        "shaders/redaphid/wip/psyche/knobs.frag",
        "package.json",
        "shaders/redaphid/wip/psyche/2.frag",
        "edit.js",
        "edit.html"
      ],
      "capabilitiesRan": {
        "mutate-request": [
          11,
          14,
          6
        ],
        "start-submit-chat": [],
        "before-submit-chat": [
          15
        ],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [
          6
        ],
        "process-codeblock": [],
        "process-stream": [
          15
        ]
      },
      "editTrailContexts": [],
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [
        {
          "relativeWorkspacePath": "service-worker.js",
          "lineNumber": 52
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 88
        },
        {
          "relativeWorkspacePath": "service-worker.js",
          "lineNumber": 6
        },
        {
          "relativeWorkspacePath": "service-worker.js",
          "lineNumber": 32
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 12
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 69
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 89
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 12
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 59
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 100
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 82
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 73
        },
        {
          "relativeWorkspacePath": "index.js",
          "lineNumber": 129
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 115
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 16
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 16
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 2
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 35
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 20
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 35
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/knobs.frag",
          "lineNumber": 8
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 96
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 64
        },
        {
          "relativeWorkspacePath": "package.json",
          "lineNumber": 30
        },
        {
          "relativeWorkspacePath": "package.json",
          "lineNumber": 9
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 64
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 114
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 98
        },
        {
          "relativeWorkspacePath": "package.json",
          "lineNumber": 9
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 97
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 78
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 98
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 57
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 96
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 20
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 78
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/2.frag",
          "lineNumber": 11
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/2.frag",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "shaders/redaphid/wip/psyche/2.frag",
          "lineNumber": 16
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 77
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 89
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 1
        },
        {
          "relativeWorkspacePath": "src/audio/WorkerRPC.js",
          "lineNumber": 91
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 14
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 115
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 69
        },
        {
          "relativeWorkspacePath": "esbuild.js",
          "lineNumber": 114
        }
      ],
      "isAgentic": false,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "richText": "{\"root\":{\"children\":[{\"children\":[{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Fix this in \",\"type\":\"text\",\"version\":1},{\"detail\":1,\"format\":0,\"mode\":\"segmented\",\"style\":\"\",\"text\":\"@Codebase\",\"type\":\"mention\",\"version\":1,\"mentionName\":\"Codebase\",\"storedKey\":\"775\",\"metadata\":{\"selection\":{\"type\":0},\"selectedOption\":{\"key\":\"Codebase\",\"type\":\"codebase\",\"name\":\"Codebase\",\"picture\":{},\"_score\":9.15,\"isSlash\":false}}},{\"detail\":1,\"format\":0,\"mode\":\"segmented\",\"style\":\"\",\"text\":\"\",\"type\":\"text\",\"version\":1},{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\" \",\"type\":\"text\",\"version\":1},{\"type\":\"linebreak\",\"version\":1},{\"detail\":0,\"format\":0,\"mode\":\"normal\",\"style\":\"\",\"text\":\"Error in worker SpectralCentroid: ErrorEvent\u00a0{isTrusted: true, message: 'Uncaught SyntaxError: Cannot use import statement outside a module', filename: 'blob:https://visuals.beadfamous.com/d844ebe4-52ea-4715-add5-7d92a38f2e10', lineno: 1, colno: 1,\u00a0\u2026}\",\"type\":\"text\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"paragraph\",\"version\":1}],\"direction\":\"ltr\",\"format\":\"\",\"indent\":0,\"type\":\"root\",\"version\":1}}",
      "text": "Fix this in @Codebase \nError in worker SpectralCentroid: ErrorEvent\u00a0{isTrusted: true, message: 'Uncaught SyntaxError: Cannot use import statement outside a module', filename: 'blob:https://visuals.beadfamous.com/d844ebe4-52ea-4715-add5-7d92a38f2e10', lineno: 1, colno: 1,\u00a0\u2026}",
      "context": {
        "editTrailContexts": [],
        "notepads": [],
        "quotes": [],
        "selectedCommits": [],
        "selectedPullRequests": [],
        "selectedImages": [],
        "folderSelections": [],
        "fileSelections": [
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
              "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
              "scheme": "file"
            },
            "addedWithoutMention": true,
            "autoContext": true
          }
        ],
        "terminalFiles": [],
        "selections": [],
        "terminalSelections": [],
        "selectedDocs": [],
        "externalLinks": [],
        "diffHistory": {
          "files": [
            {
              "$mid": 1,
              "path": "/esbuild.js",
              "scheme": "file"
            },
            {
              "$mid": 1,
              "path": "/service-worker.js",
              "scheme": "file"
            },
            {
              "$mid": 1,
              "path": "/index.js",
              "scheme": "file"
            }
          ],
          "diffHistories": [],
          "uniqueId": "b88b1316-7a85-498f-a1ab-aaea5528650e"
        },
        "mentions": {
          "editTrailContexts": {},
          "notepads": {},
          "quotes": {},
          "selectedCommits": {},
          "selectedPullRequests": {},
          "gitDiff": [],
          "gitDiffFromBranchToMain": [],
          "selectedImages": {},
          "usesCodebase": [
            {
              "uuid": "775"
            }
          ],
          "useWeb": [],
          "folderSelections": {},
          "fileSelections": {},
          "terminalFiles": {},
          "selections": {},
          "terminalSelections": {},
          "selectedDocs": {},
          "externalLinks": {},
          "useLinterErrors": [],
          "useDiffReview": [],
          "useContextPicking": [],
          "useRememberThis": [],
          "diffHistory": []
        },
        "usesCodebase": {
          "editTrailContexts": [],
          "notepads": [],
          "quotes": [],
          "selectedCommits": [],
          "selectedPullRequests": [],
          "selectedImages": [],
          "folderSelections": [],
          "fileSelections": [
            {
              "uri": {
                "$mid": 1,
                "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
                "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
                "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
                "scheme": "file"
              },
              "addedWithoutMention": true,
              "autoContext": true
            }
          ],
          "terminalFiles": [],
          "selections": [],
          "terminalSelections": [],
          "selectedDocs": [],
          "externalLinks": [],
          "diffHistory": {
            "files": [
              {
                "$mid": 1,
                "path": "/esbuild.js",
                "scheme": "file"
              },
              {
                "$mid": 1,
                "path": "/service-worker.js",
                "scheme": "file"
              },
              {
                "$mid": 1,
                "path": "/index.js",
                "scheme": "file"
              }
            ],
            "diffHistories": [],
            "uniqueId": "b88b1316-7a85-498f-a1ab-aaea5528650e"
          },
          "mentions": {
            "editTrailContexts": {},
            "notepads": {},
            "quotes": {},
            "selectedCommits": {},
            "selectedPullRequests": {},
            "gitDiff": [],
            "gitDiffFromBranchToMain": [],
            "selectedImages": {},
            "usesCodebase": [
              {
                "uuid": "775"
              }
            ],
            "useWeb": [],
            "folderSelections": {},
            "fileSelections": {},
            "terminalFiles": {},
            "selections": {},
            "terminalSelections": {},
            "selectedDocs": {},
            "externalLinks": {},
            "useLinterErrors": [],
            "useDiffReview": [],
            "useContextPicking": [],
            "useRememberThis": [],
            "diffHistory": []
          },
          "usesCodebase": true
        }
      },
      "checkpoint": {
        "files": [
          {
            "uri": {
              "$mid": 1,
              "external": "file:///Users/redaphid/Projects/paper-cranes/service-worker.js",
              "path": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": []
          },
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
              "path": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": [],
            "isNewlyCreated": false
          },
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/webpack.config.js",
              "path": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": [],
            "isNewlyCreated": false
          },
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
              "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": [],
            "isNewlyCreated": false
          },
          {
            "uri": {
              "$mid": 1,
              "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
              "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
              "path": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
              "scheme": "file"
            },
            "originalModelDiffWrtV0": [],
            "isNewlyCreated": false
          }
        ],
        "nonExistentFiles": [],
        "newlyCreatedFolders": [],
        "activeInlineDiffs": [
          {
            "uri": {
              "$mid": 1,
              "external": "file:///Users/redaphid/Projects/paper-cranes/index.js",
              "path": "/Users/redaphid/Projects/paper-cranes/index.js",
              "scheme": "file"
            },
            "version": 0
          }
        ],
        "inlineDiffNewlyCreatedResources": {
          "files": [],
          "folders": []
        }
      },
      "capabilityStatuses": {
        "mutate-request": [
          {
            "type": 14,
            "status": "completed"
          }
        ],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": []
      }
    },
    {
      "type": 2,
      "bubbleId": "47740e9f-700f-4e2c-9b97-431c986e7682",
      "suggestedCodeBlocks": [],
      "relevantFiles": [],
      "capabilitiesRan": {
        "mutate-request": [
          11,
          14,
          6
        ],
        "start-submit-chat": [],
        "before-submit-chat": [
          15
        ],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [
          6
        ],
        "process-codeblock": [],
        "process-stream": [
          15
        ]
      },
      "editTrailContexts": [],
      "multiFileLinterErrors": [],
      "diffHistories": [],
      "recentLocationsHistory": [],
      "isAgentic": false,
      "fileDiffTrajectories": [],
      "existedSubsequentTerminalCommand": false,
      "existedPreviousTerminalCommand": false,
      "docsReferences": [],
      "webReferences": [],
      "attachedFoldersListDirResults": [],
      "codeBlocks": [
        {
          "uri": {
            "$mid": 1,
            "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
            "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
            "path": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
            "scheme": "file"
          },
          "version": 0,
          "codeBlockIdx": 0
        },
        {
          "uri": {
            "$mid": 1,
            "fsPath": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
            "external": "file:///Users/redaphid/Projects/paper-cranes/webpack.config.js",
            "path": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
            "scheme": "file"
          },
          "version": 0,
          "codeBlockIdx": 1
        },
        {
          "uri": {
            "$mid": 1,
            "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
            "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
            "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
            "scheme": "file"
          },
          "version": 0,
          "codeBlockIdx": 2
        },
        {
          "uri": {
            "$mid": 1,
            "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
            "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
            "path": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
            "scheme": "file"
          },
          "version": 0,
          "codeBlockIdx": 3
        }
      ],
      "text": "This error occurs because the Web Workers are being created from blobs that don't support ES modules by default. Let's fix this by modifying how the workers are initialized and loaded.\n\nHere are the necessary changes:\n\n1. First, modify the WorkerRPC class to properly initialize workers with module support:\n\n```javascript:src/audio/WorkerRPC.js\ninitialize = async () => {\n    const workerUrl = new URL(`./src/audio/analyzers/${this.workerName}.js`, import.meta.url)\n    const response = await fetch(workerUrl)\n    if (!response.ok) {\n        throw new Error(`Failed to fetch ${this.workerName} worker: ${response.statusText}`)\n    }\n\n    const code = await response.text()\n    // Create blob with module type\n    const blob = new Blob([code], { type: 'application/javascript' })\n    // Create worker with module support\n    this.worker = new Worker(URL.createObjectURL(blob), { type: 'module' })\n\n    this.worker.onmessage = this.handleMessage\n    this.worker.onerror = this.handleError\n\n    this.worker.postMessage({\n        type: 'config',\n        config: { historySize: this.historySize },\n    })\n}\n```\n\n2. Update the webpack configuration to properly handle worker files:\n\n```javascript:webpack.config.js\nmodule: {\n    rules: [\n        // ... other rules ...\n        {\n            test: /src\\/audio\\/analyzers\\/.+\\.js$/,\n            use: [\n                {\n                    loader: 'worker-loader',\n                    options: {\n                        filename: 'audio/analyzers/[name].[contenthash].js',\n                        esModule: true,\n                    },\n                },\n            ],\n            type: 'javascript/auto',\n        },\n    ],\n}\n```\n\n3. Update the esbuild configuration to properly handle worker files:\n\n```javascript:esbuild.js\nawait build({\n    entryPoints,\n    format: 'esm',\n    bundle: true,\n    minify: true,\n    sourcemap: !process.env.NODE_ENV,\n    outdir: join(process.cwd(), 'dist'),\n    treeShaking: true,\n    define: {\n        CACHE_NAME: '\"cranes-cache-v2\"',\n        'process.env.NODE_ENV': process.env.NODE_ENV ?? '\"development\"',\n    },\n    loader: {\n        '.ttf': 'file',\n        '.woff': 'file',\n        '.woff2': 'file',\n    },\n    // Add this section to handle workers\n    plugins: [{\n        name: 'worker-plugin',\n        setup(build) {\n            build.onResolve({ filter: /\\/analyzers\\/.+\\.js$/ }, args => ({\n                path: args.path,\n                namespace: 'worker'\n            }))\n            build.onLoad({ filter: /.*/, namespace: 'worker' }, async (args) => ({\n                contents: `\n                    import * as hypnosound from 'hypnosound';\n                    ${await readFile(args.path, 'utf8')}\n                `,\n                loader: 'js'\n            }))\n        }\n    }]\n})\n```\n\n4. Update the SpectralCentroid worker (and other similar workers) to use ES module syntax:\n\n```javascript:src/audio/analyzers/SpectralCentroid.js\nimport { spectralCentroid, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data\n        const value = spectralCentroid(fft)\n        self.postMessage({\n            id: e.id,\n            type: 'computedValue',\n            value,\n            stats: calculateStats(value)\n        })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})\n```\n\n5. Install the required dev dependency:\n\n```bash\nnpm install --save-dev worker-loader\n```\n\nThese changes will:\n1. Properly initialize Web Workers with module support\n2. Configure the build system to handle worker files correctly\n3. Update the worker files to use proper ES module syntax\n4. Ensure the dependencies are properly bundled with the workers\n\nThe error should now be resolved and the workers should function correctly with ES module imports.",
      "timingInfo": {
        "clientStartTime": 1737076330187,
        "clientRpcSendTime": 1737076330243,
        "clientSettleTime": 1737076351801,
        "clientEndTime": 1737076351801
      },
      "intermediateChunks": [
        {
          "chunkIdentity": {
            "fileName": "service-worker.js",
            "startLine": 1,
            "endLine": 42,
            "text": "const wait = async (ms) => new Promise((resolve) => setTimeout(resolve, ms))\n\nself.addEventListener('install', function (event) {\n    // Perform install steps\n})\n\nasync function fetchWithControlledRetry(request) {\n    const cache = await caches.open(CACHE_NAME)\n\n    async function attemptFetch() {\n        let cacheResponse = await caches.match(request)\n\n        const timeoutPromise = new Promise((resolve) =>\n            setTimeout(async () => {\n                if (cacheResponse) return resolve(cacheResponse)\n                await wait(500)\n                resolve(fetch(request))\n            }, 1000),\n        )\n\n        const networkPromise = fetch(request)\n            .then(async (response) => {\n                if (response.ok) {\n                    await cache.put(request, response.clone()) // Cache the successful response\n                    return response\n                }\n                throw new Error('Network response was not ok')\n            })\n            .catch(async (error) => {\n                // In case of network error (including being offline), return cached response if available\n                if (cacheResponse) {\n                    return cacheResponse\n                }\n                wait(500) // Wait 500ms before retrying\n                return fetch(request)\n            })\n\n        return Promise.race([networkPromise, timeoutPromise])\n    }\n\n    return attemptFetch()\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "service-worker.js",
            "startLine": 44,
            "endLine": 51,
            "text": "self.addEventListener('fetch', function (event) {\n    // Guard clauses for GET requests, excluding 'edit' in URL, and ensuring same-origin\n    if (event.request.method !== 'GET' || event.request.url.includes('edit') || new URL(event.request.url).origin !== location.origin) {\n        return\n    }\n\n    event.respondWith(fetchWithControlledRetry(event.request))\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 42,
            "endLine": 86,
            "text": "window.cranes = window.cranes || {}\nwindow.cranes.manualFeatures = window.cranes.manualFeatures || {}\nconst getRelativeOrAbsolute = async (url) => {\n    //if the url is not a full url, then it's a relative url\n    if (!url.includes('http')) {\n        url = `/shaders/${url}`\n    }\n    const res = await fetch(url)\n    const shader = await res.text()\n    return shader\n}\n\nconst getFragmentShader = async () => {\n    const shaderUrl = params.get('shader')\n    let fragmentShader\n    if (shaderUrl) {\n        fragmentShader = await getRelativeOrAbsolute(`${shaderUrl}.frag`)\n    }\n\n    if (!fragmentShader) {\n        fragmentShader = localStorage.getItem('cranes-manual-code')\n    }\n\n    if (!fragmentShader) {\n        fragmentShader = await getRelativeOrAbsolute('default.frag')\n    }\n    return fragmentShader\n}\n\nconst getVertexShader = async () => {\n    const shaderUrl = params.get('vertex_shader')\n    let vertexShader\n    if (shaderUrl) {\n        vertexShader = await getRelativeOrAbsolute(`${shaderUrl}.vert`)\n    }\n\n    if (!vertexShader) {\n        vertexShader = localStorage.getItem('cranes-manual-code-vertex')\n    }\n\n    if (!vertexShader) {\n        vertexShader = await getRelativeOrAbsolute('default.vert')\n    }\n    return vertexShader\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/WorkerRPC.js",
            "startLine": 88,
            "endLine": 115,
            "text": "export class WorkerRPC {\n    ...\n    initialize = async () => {\n        const workerUrl = new URL(`./src/audio/analyzers/${this.workerName}.js`, import.meta.url)\n        const response = await fetch(workerUrl)\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${this.workerName} worker: ${response.statusText}`)\n        }\n\n        const code = await response.text()\n        const blob = new Blob([code], { type: 'application/javascript' })\n        this.worker = new Worker(URL.createObjectURL(blob))\n\n        this.worker.onmessage = this.handleMessage\n        this.worker.onerror = this.handleError\n\n        this.worker.postMessage({\n            type: 'config',\n            config: { historySize: this.historySize },\n        })\n    }\n\n    handleError = (error) => {\n        console.error(`Error in worker ${this.workerName}:`, error)\n    }\n\n    terminate = () => {\n        this.worker?.terminate()\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 88,
            "endLine": 128,
            "text": "const main = async () => {\n    try {\n        if (ranMain) return\n        ranMain = true\n        window.c = cranes\n        startTime = performance.now()\n        const audio = await setupAudio()\n\n        const fragmentShader = await getFragmentShader()\n        const vertexShader = await getVertexShader()\n\n        window.shader = fragmentShader\n        const initialImageUrl = params.get('image') ?? 'images/placeholder-image.png'\n        const fullscreen = (params.get('fullscreen') ?? false) === 'true'\n        const canvas = getVisualizerDOMElement()\n        const render = await makeVisualizer({ canvas, initialImageUrl, fullscreen })\n        requestAnimationFrame(() => animate({ render, audio, fragmentShader, vertexShader }))\n    } catch (e) {\n        console.error(`main error: ${e}`)\n    }\n}\n\n// if the url contains the string 'edit', don't do this.\nif (!window.location.href.includes('edit')) {\n    events.forEach((event) => {\n        // get the visualizer\n        const visualizer = getVisualizerDOMElement()\n        visualizer.addEventListener(event, main, { once: true })\n        visualizer.addEventListener(\n            event,\n            () => {\n                try {\n                    document.documentElement.requestFullscreen()\n                } catch (e) {\n                    console.error(`preventing a crash: ${e}`)\n                }\n            },\n            { once: true },\n        )\n    })\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "esbuild.js",
            "startLine": 54,
            "endLine": 116,
            "text": "async function generateHTML(shaderFiles) {\n    let htmlContent = '<!DOCTYPE html>\\n<html>\\n<head>\\n<title>Shaders</title>\\n</head>\\n<body>\\n<ul>\\n'\n    shaderFiles.forEach((file) => {\n        const relativePath = relative('shaders', file)\n        const queryParam = relativePath.replace(/\\\\/g, '/').replace('.frag', '')\n        htmlContent += `<li><a href=\"/?shader=${queryParam}&fullscreen=true\">${queryParam}</a></li>\\n`\n    })\n    htmlContent += '</ul>\\n</body>\\n</html>'\n\n    await writeFile(join('dist', 'shaders.html'), htmlContent)\n}\n\nasync function main() {\n    await ensureDistDirectory()\n\n    const entryPoints = ['index.js', 'edit.js', 'service-worker.js', 'analyze.js']\n    const srcEntryPoints = await getEntryPoints('./src')\n    entryPoints.push(...srcEntryPoints)\n\n    const shaderDir = 'shaders'\n    const shaderFiles = await getShaderFiles(shaderDir)\n\n    await generateHTML(shaderFiles)\n\n    await build({\n        entryPoints,\n        format: 'esm',\n        bundle: true,\n        minify: true,\n        sourcemap: !process.env.NODE_ENV,\n        outdir: join(process.cwd(), 'dist'),\n        treeShaking: true,\n        define: {\n            CACHE_NAME: '\"cranes-cache-v2\"',\n            'process.env.NODE_ENV': process.env.NODE_ENV ?? '\"development\"',\n        },\n        loader: {\n            '.ttf': 'file',\n            '.woff': 'file',\n            '.woff2': 'file',\n        }\n    })\n\n    // Copy Monaco's files separately\n    await ncpAsync(\n        'node_modules/monaco-editor/min/vs',\n        'dist/vs'\n    )\n\n    await Promise.all([\n        ncpAsync('index.html', 'dist/index.html'),\n        ncpAsync('index.css', 'dist/index.css'),\n        ncpAsync('edit.html', 'dist/edit.html'),\n        ncpAsync('edit.css', 'dist/edit.css'),\n        ncpAsync('BarGraph.css', 'dist/BarGraph.css'),\n        ncpAsync('favicon.ico', 'dist/favicon.ico'),\n        ncpAsync('images', 'dist/images'),\n        ncpAsync('shaders', 'dist/shaders'),\n        ncpAsync('codicon.ttf', 'dist/codicon.ttf'),\n        ncpAsync('analyze.html', 'dist/analyze.html'),\n        ncpAsync('analyze.css', 'dist/analyze.css'),\n    ])\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 1,
            "endLine": 8,
            "text": "import * as monaco from 'monaco-editor'\n\n// Set up Monaco's worker path\nself.MonacoEnvironment = {\n    getWorkerUrl: function(moduleId, label) {\n        return './vs/base/worker/workerMain.js';\n    }\n};",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "esbuild.js",
            "startLine": 118,
            "endLine": 118,
            "text": "main().catch(console.error)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 129,
            "endLine": 160,
            "text": "const setupAudio = async () => {\n    const audioContext = new AudioContext()\n    await audioContext.resume()\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })\n    const sourceNode = audioContext.createMediaStreamSource(stream)\n    const historySize = parseInt(params.get('history_size') ?? '500')\n    const audioProcessor = new AudioProcessor(audioContext, sourceNode, historySize)\n    await audioProcessor.start()\n    return audioProcessor\n}\n\nconst animate = ({ render, audio, fragmentShader, vertexShader }) => {\n    requestAnimationFrame(() => animate({ render, audio, fragmentShader, vertexShader }))\n    fragmentShader = window.cranes?.shader ?? fragmentShader\n    const measuredAudioFeatures = audio.getFeatures()\n    const queryParamFeatures = {}\n\n    for (const [key, value] of params) {\n        queryParamFeatures[key] = value\n    }\n\n    const { manualFeatures } = window.cranes\n    window.cranes.measuredAudioFeatures = measuredAudioFeatures\n    const features = { ...measuredAudioFeatures, ...queryParamFeatures, ...manualFeatures }\n\n    try {\n        render({ time: (performance.now() - startTime) / 1000, features, fragmentShader, vertexShader })\n    } catch (e) {\n        console.error(e)\n    }\n\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "esbuild.js",
            "startLine": 1,
            "endLine": 52,
            "text": "import { build } from 'esbuild'\nimport { join, relative } from 'path'\nimport { readdir, stat, mkdir, writeFile } from 'fs/promises'\nimport ncp from 'ncp'\nimport { promisify } from 'util'\n\nconst ncpAsync = promisify(ncp)\n\nasync function ensureDistDirectory() {\n    try {\n        await mkdir('dist', { recursive: true })\n    } catch (err) {\n        console.error('Error ensuring dist directory:', err)\n    }\n}\n\nasync function getShaderFiles(dir) {\n    let fileList = []\n    const files = await readdir(dir)\n    await Promise.all(\n        files.map(async (file) => {\n            const filePath = join(dir, file)\n            const stats = await stat(filePath)\n            if (stats.isDirectory()) {\n                if (!['private', 'knobs', 'utils', 'practice'].includes(file)) {\n                    const subDirFiles = await getShaderFiles(filePath)\n                    fileList = fileList.concat(subDirFiles)\n                }\n            } else if (file.endsWith('.frag')) {\n                fileList.push(filePath)\n            }\n        }),\n    )\n    return fileList\n}\n\nasync function getEntryPoints(dir) {\n    let entryPoints = []\n    const files = await readdir(dir, { withFileTypes: true })\n    await Promise.all(\n        files.map(async (file) => {\n            const filePath = join(dir, file.name)\n            if (file.isDirectory()) {\n                const subDirEntries = await getEntryPoints(filePath)\n                entryPoints = entryPoints.concat(subDirEntries)\n            } else if (file.isFile() && file.name.endsWith('.js')) {\n                entryPoints.push(filePath)\n            }\n        }),\n    )\n    return entryPoints\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/WorkerRPC.js",
            "startLine": 40,
            "endLine": 86,
            "text": "export class WorkerRPC {\n    ...\n    validateMessage = (message) => ({\n        ...message,\n        workerName: this.workerName,\n        value: isFinite(message.value) ? message.value : 0,\n        stats: this.validateStats(message.stats),\n    })\n\n    handleMessage = (event) => {\n        if (event.data.type === 'computedValue') {\n            const validatedMessage = this.validateMessage(event.data)\n            this.lastMessage = validatedMessage\n\n            if (this.resolveMessage && event.data.id === this.currentMessageId) {\n                this.resolveMessage(validatedMessage)\n                this.resolveMessage = null\n            }\n        }\n    }\n\n    processData = async (fftData) => {\n        if (this.resolveMessage) {\n            console.log(`${this.workerName} abandoning message after ${performance.now() - this.currentMessageId}ms`)\n            this.resolveMessage()\n        }\n\n        const messageId = (this.currentMessageId = performance.now())\n\n        const messagePromise = Promise.race([\n            new Promise((resolve) => {\n                this.resolveMessage = resolve\n            }),\n            new Promise((_, reject) => setTimeout(() => reject(new Error(`Worker ${this.workerName} timed out`)), this.timeout)).catch(() => {\n                if (this.currentMessageId === messageId) {\n                    this.resolveMessage = null\n                }\n                return this.lastMessage\n            }),\n        ])\n\n        this.worker.postMessage({\n            type: 'fftData',\n            id: messageId,\n            data: { fft: fftData },\n        })\n\n        return messagePromise\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/WorkerRPC.js",
            "startLine": 1,
            "endLine": 38,
            "text": "export class WorkerRPC {\n    constructor(workerName, historySize, timeout = 50) {\n        this.workerName = workerName\n        this.historySize = historySize\n        this.timeout = timeout\n        this.currentMessageId = 0\n        this.resolveMessage = null\n        this.lastMessage = this.createDefaultMessage()\n    }\n\n    createDefaultMessage = () => ({\n        type: 'computedValue',\n        workerName: this.workerName,\n        value: 0,\n        stats: {\n            current: 0,\n            mean: 0,\n            median: 0,\n            min: 0,\n            max: 0,\n            variance: 0,\n            standardDeviation: 0,\n            zScore: 0,\n            normalized: 0,\n        },\n    })\n\n    validateStats = (stats = {}) => ({\n        current: isFinite(stats.current) ? stats.current : 0,\n        mean: isFinite(stats.mean) ? stats.mean : 0,\n        median: isFinite(stats.median) ? stats.median : 0,\n        min: isFinite(stats.min) ? stats.min : 0,\n        max: isFinite(stats.max) ? stats.max : 0,\n        variance: isFinite(stats.variance) ? stats.variance : 0,\n        standardDeviation: isFinite(stats.standardDeviation) ? stats.standardDeviation : 0,\n        zScore: isFinite(stats.zScore) ? stats.zScore : 0,\n        normalized: isFinite(stats.normalized) ? stats.normalized : 0,\n    })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 10,
            "endLine": 52,
            "text": "function init() {\n    //if we have a shader in the query param, return\n    if (new URLSearchParams(window.location.search).get('shader')) return\n    console.log('no shader in query param')\n    const shader = localStorage.getItem('cranes-manual-code') || ''\n    const conf = {\n        comments: {\n            lineComment: '//',\n            blockComment: ['/*', '*/'],\n        },\n        brackets: [\n            ['{', '}'],\n            ['[', ']'],\n            ['(', ')'],\n        ],\n        autoClosingPairs: [\n            { open: '[', close: ']' },\n            { open: '{', close: '}' },\n            { open: '(', close: ')' },\n            { open: \"'\", close: \"'\", notIn: ['string', 'comment'] },\n            { open: '\"', close: '\"', notIn: ['string'] },\n            { open: '/*', close: ' */', notIn: ['string'] },\n        ],\n        surroundingPairs: [\n            { open: '{', close: '}' },\n            { open: '[', close: ']' },\n            { open: '(', close: ')' },\n            { open: '\"', close: '\"' },\n            { open: \"'\", close: \"'\" },\n        ],\n    }\n\n    const keywords = [\n        'getLastFrameColor',\n        'PI',\n        'mapValue',\n        'resolution',\n        'time',\n        'spectralCentroid',\n        'energy',\n        'spectralRolloff',\n        'spectralRolloffNormalized',\n        'spectralRolloffMean'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.js",
            "startLine": 1,
            "endLine": 41,
            "text": "import { AudioProcessor } from './src/audio/AudioProcessor.js'\nimport { makeVisualizer } from './src/Visualizer.js'\nimport './index.css'\nconst events = ['touchstart', 'touchmove', 'touchstop', 'click', 'keydown', 'mousemove', 'mousedown', 'mouseup', 'resize']\nlet ranMain = false\nlet startTime = 0\nconst params = new URLSearchParams(window.location.search)\n\nconst getVisualizerDOMElement = () => {\n    if (!window.visualizer) {\n        window.visualizer = document.getElementById('visualizer')\n    }\n    return window.visualizer\n}\n\n// check if we have microphone access. If so, just run main immediately\nnavigator.mediaDevices\n    .getUserMedia({\n        audio: {\n            echoCancellation: false,\n            noiseSuppression: false,\n            autoGainControl: false,\n        },\n    })\n    .then(() => main())\n    .catch(() => {\n        const body = document.querySelector('body')\n        body.classList.remove('ready')\n    })\nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n        navigator.serviceWorker.register(new URL('/service-worker.js', import.meta.url)).then(\n            (registration) => {\n                console.log('ServiceWorker registration successful with scope: ', registration.scope)\n            },\n            (err) => {\n                console.log('ServiceWorker registration failed: ', err)\n            },\n        )\n    })\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "webpack.config.js",
            "startLine": 1,
            "endLine": 64,
            "text": "const path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst TerserPlugin = require('terser-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst { DefinePlugin } = require('webpack')\n\nmodule.exports = {\n    mode: 'production',\n\n    // Your other webpack configurations go here\n    devServer: {\n        static: {\n            directory: path.join(__dirname, 'dist'), // Path to your built files\n        },\n        port: 6969, // Choose any port you prefer\n        hot: false, // Enable hot module replacement\n    },\n\n    entry: {\n        app: './index.js',\n        'service-worker': './service-worker.js',\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js',\n        publicPath: '/',\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [MiniCssExtractPlugin.loader, 'css-loader'],\n            },\n            {\n                test: /\\.(png|jpe?g|gif|svg)$/i,\n                use: [\n                    {\n                        loader: 'file-loader',\n                        options: {\n                            outputPath: 'images',\n                            name: '[name].[ext]',\n                        },\n                    },\n                ],\n            },\n            {\n                test: /\\.html$/,\n                use: ['html-loader'],\n            },\n            {\n                test: /src\\/audio\\/analyzers\\/.+\\.js$/, // Regex to match JS files in the specific directory\n                use: [\n                    {\n                        loader: 'file-loader',\n                        options: {\n                            name: '[contenthash]/[name].js',\n                            outputPath: 'audio/analyzers',\n                        },\n                    },\n                ],\n            },\n        ],\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "package.json",
            "startLine": 1,
            "endLine": 57,
            "text": "{\n  \"name\": \"paper-cranes-audio\",\n  \"version\": \"1.0.2\",\n  \"description\": \"\",\n  \"type\": \"module\",\n  \"main\": \"dist/src/audio/AudioProcessor.js\",\n  \"scripts\": {\n    \"start\": \"npm run dev\",\n    \"serve\": \"browser-sync start --server dist --port 6969 --files 'dist/**/*' --no-open\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"node ./esbuild.js\",\n    \"dev\": \"npm run build && concurrently \\\"npm run serve\\\" \\\"npm run build:watch\\\"\",\n    \"build:watch\": \"chokidar '**/*.*' -i 'node_modules/*' -i 'dist/**/*.*' -c 'npm run build'\",\n    \"format\": \"eslint --fix .\"\n  },\n  \"author\": \"hypnodroid\",\n  \"license\": \"UNLICENSED\",\n  \"dependencies\": {\n    \"@preact/signals\": \"^1.3.1\",\n    \"debounce\": \"^2.2.0\",\n    \"htm\": \"^3.1.1\",\n    \"html\": \"^1.0.0\",\n    \"hypnosound\": \"^1.8.0\",\n    \"monaco-editor\": \"^0.52.2\",\n    \"preact\": \"^10.25.4\",\n    \"twgl-base.js\": \"^5.5.3\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.96.0\",\n    \"browser-sync\": \"^3.0.0\",\n    \"chokidar-cli\": \"^3.0.0\",\n    \"concurrently\": \"^9.1.2\",\n    \"esbuild\": \"^0.20.2\",\n    \"esbuild-plugin-copy\": \"^2.1.1\",\n    \"esbuild-plugin-css-modules\": \"^0.3.0\",\n    \"esbuild-plugin-html\": \"^1.0.0\",\n    \"eslint\": \"^8.57.1\",\n    \"mini-css-extract-plugin\": \"^2.9.2\",\n    \"ncp\": \"^2.0.0\",\n    \"prettier\": \"^3.4.2\"\n  },\n  \"languages\": [\n    {\n      \"id\": \"paper-cranes-fragment-shader\",\n      \"aliases\": [\n        \"GLSL\",\n        \"glsl\"\n      ],\n      \"extensions\": [\n        \".frag\",\n        \".vert\",\n        \".glsl\"\n      ]\n    }\n  ]\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 439,
            "endLine": 441,
            "text": "export function deactivate() {\n  // Clean up will be handled automatically by VS Code\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 1,
            "endLine": 39,
            "text": "import {\n    createTexture,\n    createFramebufferInfo,\n    createProgramInfo,\n    createBufferInfoFromArrays,\n    resizeCanvasToDisplaySize,\n    setBuffersAndAttributes,\n    setUniforms,\n    drawBufferInfo,\n} from 'twgl-base.js'\n\nimport { shaderWrapper } from './shader-transformers/shader-wrapper'\n\nconst gridSize = 100\n\nconst getTexture = async (gl, url) => {\n    return new Promise((resolve) => {\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) // Flip the texture\n        const texture = createTexture(gl, { src: url, crossOrigin: 'anonymous' }, () => {\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) // Reset the parameter\n            resolve(texture)\n        })\n    })\n}\n\n// Function to create and update the WebGL program with error handling\nconst updateWebGLProgram = (gl, vertexShader, fragmentShader) => {\n    try {\n        const programInfo = createProgramInfo(gl, [vertexShader, fragmentShader])\n        if (!programInfo?.program) {\n            throw new Error('Failed to create a program. The shader code might be bad.')\n        }\n        gl.useProgram(programInfo.program)\n        return programInfo\n    } catch (error) {\n        console.error('Error creating WebGL program:', error.message)\n        return\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 61,
            "endLine": 97,
            "text": "const FeatureAdder = () => {\n    const [features, setFeatures] = useState({})\n    const [newFeatureName, setNewFeatureName] = useState('')\n\n    useEffect(async () => {\n        const searchParams = new URLSearchParams(window.location.search)\n        const initialFeatures = {}\n        searchParams.forEach((value, key) => {\n            // if the value is not a number, return.\n            if (isNaN(value)) return\n            const [featureName, paramType] = key.includes('.') ? key.split('.') : [key, 'value']\n            if (!initialFeatures[featureName]) initialFeatures[featureName] = { min: -3, max: 3, value: 0 }\n            initialFeatures[featureName][paramType] = parseFloat(value)\n        })\n        setFeatures(initialFeatures)\n        // if there is no 'shader' query param, set the editor code to the default shader\n        if (!searchParams.has('shader')) {\n            // try to get the shader from local storage\n            let shader = localStorage.getItem('cranes-manual-code')\n            // if the shader is not in local storage, fetch it from the server\n            if (!shader) {\n                const res = await fetch('/shaders/default.frag')\n                shader = await res.text()\n            }\n            window.editor.pushUndoStop()\n            window.editor.setValue(shader)\n            window.editor.pushUndoStop()\n            window.editor.layout()\n        } else {\n            // add the no-editor class to body\n            document.body.classList.add('no-editor')\n        }\n        // if we have a searchParam of 'present', add the present class to the body\n        if (searchParams.has('present')) {\n            document.body.classList.add('present')\n        }\n    }, [])",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.html",
            "startLine": 1,
            "endLine": 28,
            "text": "<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <link rel=\"stylesheet\" data-name=\"vs/editor/editor.main\" href=\"./vs/editor/editor.main.css\" />\n    <link rel=\"stylesheet\" href=\"edit.css\" />\n    <title>Paper Cranes - Editor</title>\n</head>\n\n<body class=\"ready\">\n    <div class=\"sparkly animated\" id=\"feature-editor\"></div>\n    <canvas id=\"visualizer\" width=\"1920\" height=\"1920\"></canvas>\n    <div id=\"save-and-publish\" class=\"sparkly animated\">\n        <button id=\"save\">Save</button>\n        <button id=\"publish\">\n            <a href=\"https://github.com/loqwai/paper-cranes/new/main/shaders\" target=\"_blank\">Publish</a>\n        </button>\n        <button id=\"reset\">Reset</button>\n    </div>\n    <div id=\"monaco-editor\"></div>\n    <script type=\"module\" src=\"./src/monaco.js\"></script>\n    <script type=\"module\" src=\"./index.js\"></script>\n    <script type=\"module\" src=\"./edit.js\"></script>\n    <script type=\"module\" src=\"./src/midi.js\"></script>\n</body>\n\n</html>\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 99,
            "endLine": 142,
            "text": "const FeatureAdder = () => {\n    ...\n    const updateFeature = (name, updatedFeature) => {\n        // get the previous feature\n        updatedFeature.min = updatedFeature.min ?? -2\n        updatedFeature.max = updatedFeature.max ?? 1\n        //round the value to the nearest 3 decimal places\n        updatedFeature.value = Math.round(updatedFeature.value * 1000) / 1000\n        setFeatures((prev) => ({ ...prev, [name]: updatedFeature }))\n    }\n\n    window.cranes.updateFeature = (name, value) => {\n        updateFeature(name, { ...features[name], value })\n    }\n\n    const addNewFeature = () => {\n        if (!newFeatureName.trim()) {\n            alert('Feature name cannot be empty')\n            return\n        }\n        const newFeature = { value: 1, min: -3, max: 3 }\n        updateFeature(newFeatureName, newFeature)\n        setNewFeatureName('')\n    }\n\n    const deleteFeature = (name) => {\n        const { [name]: _, ...rest } = features\n        setFeatures(rest)\n        updateUrl({ [name]: null, [`${name}.min`]: null, [`${name}.max`]: null })\n        delete window.cranes?.manualFeatures[name]\n    }\n\n    return html`\n        <${Fragment}>\n            <div className=\"new-feature\">\n                <input type=\"text\" value=${newFeatureName} onInput=${(e) => setNewFeatureName(e.target.value)} placeholder=\"Enter new feature name\" />\n                <button onClick=${addNewFeature}>Add Feature</button>\n            </div>\n            <div id=\"existing-features-editor\">\n                ${Object.entries(features).map(\n                    ([name, feature]) => html` <${FeatureEditor} key=${name} name=${name} feature=${feature} onChange=${updateFeature} onDelete=${deleteFeature} />`,\n                )}\n            </div>\n        </${Fragment}>\n    `\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.html",
            "startLine": 1,
            "endLine": 18,
            "text": "<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <link rel=\"stylesheet\" href=\"index.css\" />\n    <title>Paper Cranes</title>\n    <!-- Google tag (gtag.js) -->\n    <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-4BWWJ5ZPHY\"></script>\n\n</head>\n\n<body class=\"ready\">\n    <canvas id=\"visualizer\" width=\"2160\" height=\"1920\"></canvas>\n    <script type=\"module\" src=\"./index.js\"></script>\n</body>\n\n</html>\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 1,
            "endLine": 18,
            "text": "# Beadfamous\n\nWelcome to the Beadfamous project! This repo is an open-source project I made to do advanced audio analysis from a microphone in the browser, and drive arbitrary music visualizations with the data. The project can run on mobile phones, and is designed to make it easy to create new visualizations and share them with others.\n\nThe other half of the project is a sort of \"art project\" where you make bead bracelets, and flash the visualizations onto them. This is a fun way to share your visualizations with others, and to make a physical object that represents your music. Scanning the bracelet with a phone will take you to a specific visualization - even when offline!\n\n## Usage\n\nIf you've done web development before, the following steps should be pretty familiar.\n\n1. `npm install`\n2. `npm run dev`\n\nThis will serve beadfamous on localhost:6969\n\n## Viewing the visualizations\n\nvisualizations are specified by the query param 'shader' in the url. For example, to view the 'star' visualization, you would go to [localhost:6969/?shader=star](http://localhost:6969/?shader=star)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/AudioProcessor.js",
            "startLine": 72,
            "endLine": 104,
            "text": "export class AudioProcessor {\n    ...\n    updateCurrentFeatures = () => {\n        requestAnimationFrame(this.updateCurrentFeatures)\n        this.currentFeatures = getFlatAudioFeatures(AudioFeatures, this.rawFeatures)\n        this.currentFeatures.beat = this.isBeat()\n    }\n\n    isBeat = () => {\n        const spectralFlux = this.rawFeatures.SpectralFlux\n        return spectralFlux?.stats.zScore > 0.9 || false\n    }\n\n    start = async () => {\n        this.sourceNode.connect(this.fftAnalyzer)\n        await this.audioContext.audioWorklet.addModule('src/window-processor.js')\n        const windowNode = new AudioWorkletNode(this.audioContext, 'window-processor')\n        this.sourceNode.connect(windowNode)\n        await Promise.all(AudioFeatures.map(this.initializeWorker))\n        this.updateCurrentFeatures()\n        this.updateFftData()\n    }\n\n    updateFftData = () => {\n        requestAnimationFrame(this.updateFftData)\n        this.fftAnalyzer.getByteFrequencyData(this.fftData)\n    }\n\n    getFeatures = () => this.currentFeatures\n\n    cleanup = () => {\n        this.workers.forEach(worker => worker.terminate())\n        this.workers.clear()\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 56,
            "endLine": 107,
            "text": "const Analyzer = () => {\n    ...\n    const handleAnalyze = async (e) => {\n        const fileInput = e.target.form.querySelector('input[type=\"file\"]')\n        if (!fileInput.files?.length) return\n\n        setIsAnalyzing(true)\n        setStatus('Analyzing...')\n        setProgress(0)\n        analysisResults.current = []\n\n        try {\n            // Setup audio processing\n            audioContext.current = new AudioContext()\n            const file = fileInput.files[0]\n            const buffer = await file.arrayBuffer()\n            const decodedBuffer = await audioContext.current.decodeAudioData(buffer)\n\n            source.current = audioContext.current.createBufferSource()\n            source.current.buffer = decodedBuffer\n\n            processor.current = new AudioProcessor(audioContext.current, source.current, 500)\n            await processor.current.start()\n\n            // Connect and start playback\n            source.current.connect(audioContext.current.destination)\n            source.current.start()\n\n            const startTime = performance.now()\n            const duration = decodedBuffer.duration * 1000\n            setTimeInfo({ current: '0:00', start: '0:00', end: formatTime(duration) })\n\n            // Analysis loop - Fixed version\n            await new Promise((resolve) => {\n                const analyze = async () => {\n                    const currentTime = performance.now() - startTime\n                    const progress = currentTime / duration\n\n                    setProgress(Math.min(progress * 100, 100))\n                    setTimeInfo(prev => ({ ...prev, current: formatTime(currentTime) }))\n\n                    const features = await processor.current.getFeatures()\n                    analysisResults.current.push({ timestamp: currentTime, features })\n                    setCurrentFeatures(features)\n\n                    if (progress >= 1) {\n                        cleanup()\n                        resolve()\n                    } else {\n                        requestAnimationFrame(analyze)\n                    }\n                }\n                requestAnimationFrame(analyze)\n            })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/Treble.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { treble, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = treble(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 89,
            "endLine": 120,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    const render = ({ time, features, vertexShader: newVertexShader, fragmentShader: newFragmentShader }) => {\n        if (newFragmentShader !== lastFragmentShader || newVertexShader !== lastVertexShader) {\n            console.log('Shader updated')\n            // Wrap the new fragment shader with any necessary transformations\n            const wrappedFragmentShader = shaderWrapper(newFragmentShader)\n            const wrappedVertexShader = shaderWrapper(newVertexShader)\n            // Update program with new shaders\n            const newProgramInfo = updateWebGLProgram(gl, wrappedVertexShader, wrappedFragmentShader)\n            console.log('newProgramInfo', newProgramInfo)\n\n            if (!newProgramInfo) {\n                programInfo = null\n                return\n            }\n\n            programInfo = newProgramInfo\n            lastVertexShader = newVertexShader\n            lastFragmentShader = newFragmentShader\n        }\n\n        if (!programInfo) return\n\n        const renderTime = performance.now()\n        let resolutionRatio = 1\n        if (renderTime - lastRender > 100) {\n            slowFrames++\n        }\n        if (slowFrames > 30) {\n            resolutionRatio = 0.5\n        }\n        resizeCanvasToDisplaySize(gl.canvas, resolutionRatio)\n        lastRender = renderTime",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/shader-transformers/shader-wrapper.js",
            "startLine": 55,
            "endLine": 171,
            "text": "const paperCranes = () => /* glsl */ `\n\nuniform float time;\nuniform vec2 resolution;// iResolution equivalent\n\nuniform int frame;\n\nuniform sampler2D prevFrame;// Texture of the previous frame\nuniform sampler2D initialFrame;\n\nuniform float iRandom;\n\nfloat random(vec2 st, float seed){\n    st=vec2(st.x*cos(seed)-st.y*sin(seed),\n    st.x*sin(seed)+st.y*cos(seed));\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 11118.5453123);\n}\n\nfloat random(vec2 st){\n    return random(st, iRandom);\n}\n\nfloat staticRandom(vec2 st){\n    return random(st, 0.);\n}\n\nfloat mapValue(float val, float inMin, float inMax, float outMin, float outMax) {\n    float normalized =  outMin + (outMax - outMin) * (val - inMin) / (inMax - inMin);\n    return clamp(normalized, outMin, outMax);\n}\n\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl){\nfloat h=hsl.x;\nfloat s=hsl.y;\nfloat l=hsl.z;\n\nfloat r,g,b;\n\nif(s==0.f){\n  r=g=b=l;// achromatic\n}else{\n  float q=l<.5f?l*(1.f+s):l+s-l*s;\n  float p=2.f*l-q;\n  r=hue2rgb(p,q,h+1.f/3.f);\n  g=hue2rgb(p,q,h);\n  b=hue2rgb(p,q,h-1.f/3.f);\n}\n\nreturn vec3(r,g,b);\n}\n\nvec3 rgb2hsl(vec3 color){\n    float maxColor=max(max(color.r,color.g),color.b);\n    float minColor=min(min(color.r,color.g),color.b);\n    float delta=maxColor-minColor;\n\n    float h=0.f;\n    float s=0.f;\n    float l=(maxColor+minColor)/2.f;\n\n    if(delta!=0.f){\n      s=l<.5f?delta/(maxColor+minColor):delta/(2.f-maxColor-minColor);\n\n      if(color.r==maxColor){\n        h=(color.g-color.b)/delta+(color.g<color.b?6.f:0.f);\n      }else if(color.g==maxColor){\n        h=(color.b-color.r)/delta+2.f;\n      }else{\n        h=(color.r-color.g)/delta+4.f;\n      }\n      h/=6.f;\n    }\n\n    return vec3(h,s,l);\n  }\n\n  vec2 centerUv(vec2 res, vec2 coord) {\n    // step 1: normalize the coord to 0-1\n    vec2 uv = coord.xy / res;\n    // step 2: center the uv\n    uv -= 0.5;\n    // step 3: scale the uv to -1 to 1\n    uv *= 2.0;\n    uv += 0.5;\n    return uv;\n}\n\nvec2 centerUv(vec2 coord) {\n    return centerUv(resolution, coord);\n}\n\nvec3 hslmix(vec3 c1, vec3 c2, float t){\n    vec3 hsl1 = rgb2hsl(c1);\n    vec3 hsl2 = rgb2hsl(c2);\n    vec3 hsl = mix(hsl1, hsl2, t);\n    return hsl2rgb(hsl);\n    }\n`\nexport default shaderWrapper",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".eslintrc",
            "startLine": 1,
            "endLine": 7,
            "text": "{\n    \"parserOptions\": {\n        \"ecmaVersion\": 2023,\n        \"sourceType\": \"module\"\n    }\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "webpack.config.js",
            "startLine": 64,
            "endLine": 99,
            "text": "    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            inject: true,\n        }),\n        new MiniCssExtractPlugin({\n            filename: '[name].[contenthash].css',\n        }),\n        new CopyWebpackPlugin({\n            patterns: [\n                { from: 'images', to: 'images' },\n                { from: 'shaders', to: 'shaders' },\n                { from: 'favicon.ico', to: 'favicon.ico' },\n                { from: 'index.css', to: 'index.css' },\n                { from: './src/utils', to: 'utils' },\n            ],\n        }),\n        new DefinePlugin({\n            WEBPACK_CACHE_NAME: JSON.stringify(new Date().toISOString()),\n        }),\n    ],\n    optimization: {\n        minimize: true,\n        minimizer: [\n            new TerserPlugin({\n                terserOptions: {\n                    format: {\n                        comments: false,\n                    },\n                },\n                extractComments: false,\n            }),\n        ],\n    },\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 58,
            "endLine": 89,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    const gl = canvas.getContext('webgl2', { antialias: false })\n    if (fullscreen) {\n        const width = window.innerWidth\n        const height = window.innerHeight\n        canvas.width = width\n        canvas.height = height\n        gl.viewport(0, 0, width, height)\n        canvas.classList.add('fullscreen')\n    }\n    const ext = gl.getExtension('GMAN_debug_helper')\n    if (ext) {\n        ext.setConfiguration({\n            failUnsetUniforms: false,\n        })\n    }\n    const initialTexture = await getTexture(gl, initialImageUrl)\n    const frameBuffers = [createFramebufferInfo(gl), createFramebufferInfo(gl)]\n    const gridPositions = generateGridPositions(gridSize)\n    const arrays = { position: gridPositions }\n    const bufferInfo = createBufferInfoFromArrays(gl, arrays)\n\n    let frameNumber = 0\n    let slowFrames = 0\n    let lastRender = performance.now()\n    let programInfo\n    // Assuming the other parts of the code remain the same\n\n    let lastVertexShader = undefined // Initial vertex shader\n    let lastFragmentShader = undefined // Placeholder for initial fragment shader\n\n    const render",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralCentroid.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralCentroid } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralCentroid(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralCrest.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralCrest } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralCrest(fft) // Compute spectral kurtosis\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 109,
            "endLine": 118,
            "text": "const Analyzer = () => {\n    ...\n    const handleAnalyze = async (e) => {\n            ...\n            setStatus('Analysis complete!')\n            setHasResults(true)\n        } catch (error) {\n            console.error(error)\n            setStatus(`Error: ${error.message}`)\n            cleanup()\n        } finally {\n            setIsAnalyzing(false)\n        }\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 1,
            "endLine": 15,
            "text": "import { render } from 'preact'\nimport { useState, useRef } from 'preact/hooks'\nimport { html } from 'htm/preact'\nimport { AudioProcessor } from './src/audio/AudioProcessor'\nimport { normalizeAnalysisData } from './src/audio/normalizer'\nimport BarGraph from './src/components/BarGraph'\n\nconst formatTime = (ms) => {\n    const totalSeconds = Math.floor(ms / 1000)\n    const minutes = Math.floor(totalSeconds / 60)\n    const seconds = totalSeconds % 60\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`\n}\n\nconst Analyzer",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 450,
            "endLine": 488,
            "text": "function init() {\n    ...\n    monaco.languages.register({ id: 'glsl' })\n    monaco.languages.setMonarchTokensProvider('glsl', language)\n    monaco.languages.setLanguageConfiguration('glsl', conf)\n    const editor = monaco.editor.create(document.querySelector('#monaco-editor'), {\n        value: shader,\n        minimap: { enabled: false },\n        language: 'glsl',\n        theme: 'vs-dark',\n        automaticLayout: true,\n        contextmenu: true,\n        copyWithSyntaxHighlighting: true,\n        quickSuggestions: true,\n    })\n\n    // on window resize, resize the editor\n    window.addEventListener('resize', () => {\n        editor.layout()\n    })\n    window.editor = editor\n\n    document.querySelector('#save').addEventListener('click', () => {\n        editor.pushUndoStop()\n        window.cranes.shader = editor.getValue()\n        localStorage.setItem('cranes-manual-code', editor.getValue())\n        editor.pushUndoStop()\n    })\n\n    // save on control or command s\n    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S, function () {\n        editor.pushUndoStop()\n        window.cranes.shader = editor.getValue()\n        localStorage.setItem('cranes-manual-code', editor.getValue())\n        editor.pushUndoStop()\n    })\n\n    document.querySelector('#reset').addEventListener('click', () => {\n        localStorage.removeItem('cranes-manual-code')\n        window.location.reload()\n    })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 156,
            "endLine": 160,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    const render = ({ time, features, vertexShader: newVertexShader, fragmentShader: newFragmentShader }) => {\n        ...\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null)\n        gl.blitFramebuffer(0, 0, frame.width, frame.height, 0, 0, gl.canvas.width, gl.canvas.height, gl.COLOR_BUFFER_BIT, gl.LINEAR)\n\n        frameNumber++\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "index.css",
            "startLine": 1,
            "endLine": 23,
            "text": "body {\n  min-height: 100vh;\n  min-width: 100vw;\n  margin: 0;\n  padding: 0;\n  overflow: hidden; /* Prevents scrolling */\n  display: flex;\n  justify-content: center;\n  align-items: center;;\n  user-select: none;\n  background-color: #000000;\n}\ncanvas {\n  margin: 0;\n  height: 100vmin;\n  width: 100vmin;\n}\n\ncanvas.fullscreen {\n  height: 100vh;\n  width: 100vw;\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 102,
            "endLine": 189,
            "text": "function init() {\n        ...\n        'spectralCrestMedian',\n        'spectralCrestZScore',\n        'spectralCrestMin',\n        'spectralCrestMax',\n        'spectralSkew',\n        'spectralSkewNormalized',\n        'spectralSkewMean',\n        'spectralSkewStandardDeviation',\n        'spectralSkewMedian',\n        'spectralSkewZScore',\n        'spectralSkewMin',\n        'spectralSkewMax',\n        'pitchClass',\n        'pitchClassNormalized',\n        'pitchClassMean',\n        'pitchClassStandardDeviation',\n        'pitchClassMedian',\n        'pitchClassZScore',\n        'pitchClassMin',\n        'pitchClassMax',\n        'hslmix',\n        'hsl2rgb',\n        'rgb2hsl',\n        'map',\n\n        'energy',\n        'energyNormalized',\n        'energyMean',\n        'energyStandardDeviation',\n        'energyMedian',\n        'energyZScore',\n        'energyMin',\n        'energyMax',\n\n        'bass',\n        'bassNormalized',\n        'bassMean',\n        'bassStandardDeviation',\n        'bassMedian',\n        'bassZScore',\n        'bassMin',\n        'bassMax',\n\n        'mids',\n        'midsNormalized',\n        'midsMean',\n        'midsStandardDeviation',\n        'midsMedian',\n        'midsZScore',\n        'midsMin',\n        'midsMax',\n\n        'treble',\n        'trebleNormalized',\n        'trebleMean',\n        'trebleStandardDeviation',\n        'trebleMedian',\n        'trebleZScore',\n        'trebleMin',\n        'trebleMax',\n\n        'spectralFlux',\n        'spectralFluxNormalized',\n        'spectralFluxMean',\n        'spectralFluxStandardDeviation',\n        'spectralFluxMedian',\n        'spectralFluxZScore',\n        'spectralFluxMin',\n        'spectralFluxMax',\n        'random',\n        'const',\n        'uniform',\n        'break',\n        'continue',\n        'do',\n        'for',\n        'while',\n        'if',\n        'else',\n        'switch',\n        'case',\n        'in',\n        'out',\n        'inout',\n        'true',\n        'false',\n        'invariant',\n        'discard'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/midi.js",
            "startLine": 1,
            "endLine": 35,
            "text": "'use strict'\n\n// Unified function to update knob value in URL\nfunction updateKnobValue(knob, value) {\n    const currentUrl = new URL(window.location)\n    let current = parseFloat(currentUrl.searchParams.get(knob) ?? 0)\n    // get the min and max value for the knob from knob_0.min and knob_0.max in the query params\n    const min = parseFloat(currentUrl.searchParams.get(`${knob}.min`) ?? 0)\n    const max = parseFloat(currentUrl.searchParams.get(`${knob}.max`) ?? 1)\n    // the incoming knob value is between 0 and 127, so we need to scale it to the min and max values\n    if (!window.cranes.updateFeature) return\n    current = (value / 127) * (max - min) + min\n    window.cranes.updateFeature(knob, current)\n}\n\n// MIDI Access request\nnavigator\n    .requestMIDIAccess()\n    .then((midiAccess) => {\n        console.log('MIDI ready')\n        midiAccess.inputs.forEach((input) => {\n            input.onmidimessage = (message) => {\n                const [command, control, value] = message.data\n                // Listen for Control Change messages from knobs\n                if (command === 176) {\n                    let knobNumber = control\n                    let knob = `knob_${knobNumber}`\n                    updateKnobValue(knob, value)\n                }\n            }\n        })\n    })\n    .catch((error) => {\n        console.error('MIDI failed to start', error)\n    })",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 1,
            "endLine": 3,
            "text": "import * as vscode from \"vscode\";\n\nconsole.log(\"\ud83c\udfee Paper Cranes Extension Exists \ud83c\udfee\");",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 1,
            "endLine": 20,
            "text": "import { render, Fragment } from 'preact'\nimport { useState, useEffect } from 'preact/hooks'\nimport { html } from 'htm/preact'\nimport debounce from 'debounce'\n\nconst updateUrl = (params) => {\n    const currentUrl = new URL(window.location)\n    Object.entries(params).forEach(([paramName, paramValue]) => {\n        if (paramValue !== null && paramValue !== undefined) {\n            currentUrl.searchParams.set(paramName, paramValue)\n        } else {\n            currentUrl.searchParams.delete(paramName)\n        }\n    })\n    window.history.replaceState({}, '', currentUrl.toString())\n}\n\nconst updateUrlDebounced = debounce(updateUrl, 50)\n\nconst FeatureEditor",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/AudioProcessor.js",
            "startLine": 1,
            "endLine": 32,
            "text": "import { StatTypes } from 'hypnosound'\nimport { WorkerRPC } from './WorkerRPC'\n\nexport const AudioFeatures = [\n    'SpectralCentroid',\n    'SpectralFlux',\n    'SpectralSpread',\n    'SpectralRolloff',\n    'SpectralRoughness',\n    'SpectralKurtosis',\n    'Energy',\n    'SpectralEntropy',\n    'SpectralCrest',\n    'SpectralSkew',\n    'PitchClass',\n    'Bass',\n    'Mids',\n    'Treble',\n]\n\nexport const getFlatAudioFeatures = (audioFeatures = AudioFeatures, rawFeatures = {}) => {\n    const features = {}\n    for (const feature of audioFeatures) {\n        const featureKey = feature.charAt(0).toLowerCase() + feature.slice(1)\n        for (const propertyKey of StatTypes) {\n            const key = `${featureKey}${propertyKey.charAt(0).toUpperCase() + propertyKey.slice(1)}`\n            features[key] = rawFeatures[feature]?.stats[propertyKey]\n        }\n        features[featureKey] = rawFeatures[feature]?.stats?.current\n    }\n    return features\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/AudioProcessor.js",
            "startLine": 34,
            "endLine": 70,
            "text": "export class AudioProcessor {\n    constructor(audioContext, sourceNode, historySize=500,  fftSize = 32768/2) {\n        this.audioContext = audioContext\n        this.sourceNode = sourceNode\n        this.fftSize = fftSize\n        this.historySize = historySize\n        this.fftAnalyzer = this.createAnalyzer()\n        this.fftData = new Uint8Array(this.fftAnalyzer.frequencyBinCount)\n        this.workers = new Map()\n        this.rawFeatures = {}\n        this.currentFeatures = getFlatAudioFeatures()\n        this.currentFeatures.beat = false\n    }\n\n    createAnalyzer = () => {\n        const analyzer = this.audioContext.createAnalyser()\n        analyzer.smoothingTimeConstant = 0.25\n        analyzer.minDecibels = -100\n        analyzer.maxDecibels = -30\n        analyzer.fftSize = this.fftSize\n        return analyzer\n    }\n\n    initializeWorker = async (name) => {\n        const worker = new WorkerRPC(name, this.historySize)\n        await worker.initialize()\n        this.workers.set(name, worker)\n        this.runWorkerLoop(worker)\n    }\n\n    runWorkerLoop = async (worker) => {\n        const result = await worker.processData(this.fftData)\n        if (result) {\n            this.rawFeatures[result.workerName] = result\n        }\n        requestAnimationFrame(() => this.runWorkerLoop(worker));\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 120,
            "endLine": 172,
            "text": "const Analyzer = () => {\n    ...\n    const downloadData = (data, filename) => {\n        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' })\n        const url = URL.createObjectURL(blob)\n        const a = document.createElement('a')\n        a.href = url\n        a.download = filename\n        document.body.appendChild(a)\n        a.click()\n        document.body.removeChild(a)\n        URL.revokeObjectURL(url)\n    }\n\n    const handleDownload = () => {\n        downloadData(analysisResults.current, `${inputFileName}-analysis.json`)\n    }\n\n    const handleDownloadNormalized = () => {\n        const { normalized, ranges } = normalizeAnalysisData(analysisResults.current)\n        downloadData(normalized, `${inputFileName}-normalized.json`)\n        downloadData(ranges, `${inputFileName}-normalized-ranges.json`)\n    }\n\n    return html`\n        <div class=\"container\">\n            <form class=\"upload-section\">\n                <input type=\"file\" accept=\"audio/mp3\" onChange=${handleFileChange} disabled=${isAnalyzing} />\n                <button type=\"button\" onClick=${handleAnalyze} disabled=${isAnalyzing}>Analyze</button>\n                <div class=\"download-buttons\">\n                    <button type=\"button\" onClick=${handleDownload} disabled=${!hasResults}>Download Results</button>\n                    <button type=\"button\" onClick=${handleDownloadNormalized} disabled=${!hasResults}>Download Normalized</button>\n                </div>\n            </form>\n\n            <div class=\"progress-section\">\n                <div class=\"progress-bar-container\">\n                    <span class=\"time-label\">${timeInfo.start}</span>\n                    <div class=\"progress-bar\">\n                        <div class=\"progress\" style=${`width: ${progress}%`} />\n                    </div>\n                    <span class=\"time-label\">${timeInfo.end}</span>\n                </div>\n                <div class=\"time-current\">${timeInfo.current}</div>\n                <div id=\"status\">${status}</div>\n            </div>\n\n            <${BarGraph} features=${currentFeatures} />\n            <pre class=\"analysis-display\">\n                ${JSON.stringify(currentFeatures, null, 2)}\n            </pre\n            >\n        </div>\n    `\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 15,
            "endLine": 54,
            "text": "const Analyzer = () => {\n    // UI State\n    const [status, setStatus] = useState('Upload an MP3 file to begin')\n    const [progress, setProgress] = useState(0)\n    const [isAnalyzing, setIsAnalyzing] = useState(false)\n    const [hasResults, setHasResults] = useState(false)\n    const [inputFileName, setInputFileName] = useState('audio')\n    const [timeInfo, setTimeInfo] = useState({\n        current: '0:00',\n        start: '0:00',\n        end: '0:00',\n    })\n    const [currentFeatures, setCurrentFeatures] = useState({ ready: 0 })\n\n    // Audio State\n    const analysisResults = useRef([])\n    const audioContext = useRef(null)\n    const source = useRef(null)\n    const processor = useRef(null)\n\n    const handleFileChange = (e) => {\n        const file = e.target.files?.[0]\n        if (!file) {\n            setStatus('Upload an MP3 file to begin')\n            return\n        }\n\n        const fullName = file.name\n        setInputFileName(fullName.substring(0, fullName.lastIndexOf('.')) || fullName)\n        setHasResults(false)\n        setStatus('Click Analyze to begin')\n    }\n\n    const cleanup = () => {\n        source.current?.stop()\n        audioContext.current?.close()\n        source.current = null\n        audioContext.current = null\n        processor.current = null\n    }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralSpread.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralSpread } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralSpread(fft) // Compute spectral spread\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralSkew.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralSkew } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralSkew(fft) // Compute spectral skewness\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 122,
            "endLine": 155,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    const render = ({ time, features, vertexShader: newVertexShader, fragmentShader: newFragmentShader }) => {\n        ...\n        const frame = frameBuffers[frameNumber % 2]\n        const prevFrame = frameBuffers[(frameNumber + 1) % 2]\n\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frame.framebuffer)\n\n        const uniforms = {\n            time,\n            prevFrame: frameNumber === 0 ? initialTexture : prevFrame.attachments[0],\n            initialFrame: initialTexture,\n            resolution: [frame.width, frame.height],\n            frame: frameNumber,\n            iRandom: Math.random(),\n            iResolution: [frame.width, frame.height, 0],\n            iMouse: [46, 19, 208, 0],\n            iTime: time,\n            iChannel0: initialTexture,\n            iChannel1: prevFrame.attachments[0],\n            iChannel2: initialTexture,\n            iChannel3: prevFrame.attachments[0],\n            gridSize,\n            ...features,\n        }\n\n        const nonNullOrUndefinedOrNanUniforms = Object.fromEntries(\n            Object.entries(uniforms).filter(([, value]) => {\n                return value !== null && value !== undefined && !Number.isNaN(value)\n            }),\n        )\n\n        setBuffersAndAttributes(gl, programInfo, bufferInfo)\n        setUniforms(programInfo, nonNullOrUndefinedOrNanUniforms)\n        drawBufferInfo(gl, bufferInfo)\n\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frame.framebuffer)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralRoughness.js",
            "startLine": 1,
            "endLine": 13,
            "text": "import { makeCalculateStats, spectralRoughness } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralRoughness(fft) // Compute spectral roughness\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/Bass.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { bass, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = bass(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/package.json",
            "startLine": 1,
            "endLine": 89,
            "text": "{\n  \"name\": \"paper-cranes-shader-vscode-extension\",\n  \"version\": \"1.3.0\",\n  \"publisher\": \"hypnodroid\",\n  \"repository\": \"https://github.com/hypnodroid/paper-cranes\",\n  \"readme\": \"README.md\",\n  \"displayName\": \"Paper Cranes Shader Syntax\",\n  \"description\": \"Language support for Paper Cranes audio visualization shaders\",\n  \"icon\": \"logo.png\",\n  \"main\": \"./out/index.js\",\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run compile\",\n    \"compile\": \"tsc -p ./\",\n    \"watch\": \"tsc -watch -p ./\",\n    \"package\": \"vsce package -o extension.vsix\",\n    \"build\": \"rm -rf out && npm run compile && npm run package\",\n    \"debug\": \"npm run compile && code --extensionDevelopmentPath=${PWD} ../shaders/plasma.frag\"\n  },\n  \"engines\": {\n    \"vscode\": \"^1.93.1\"\n  },\n  \"categories\": [\n    \"Programming Languages\"\n  ],\n  \"contributes\": {\n    \"languages\": [\n      {\n        \"id\": \"paper-cranes-fragment-shader\",\n        \"aliases\": [\n          \"Paper Cranes Visualization\",\n          \"GLSL\",\n          \"glsl\"\n        ],\n        \"extensions\": [\n          \".frag\",\n          \".vert\",\n          \".glsl\",\n          \".crane\"\n        ],\n        \"configuration\": \"./language-configuration.json\"\n      }\n    ],\n    \"grammars\": [\n      {\n        \"language\": \"paper-cranes-fragment-shader\",\n        \"scopeName\": \"source.paper-cranes-fragment-shader\",\n        \"path\": \"./paper-cranes-fragment-shader.tmLanguage.json\",\n        \"embeddedLanguages\": {\n          \"source.glsl\": \"glsl\"\n        }\n      }\n    ],\n    \"configurationDefaults\": {\n      \"files.associations\": {\n        \"*.frag\": \"paper-cranes-fragment-shader\",\n        \"*.vert\": \"paper-cranes-fragment-shader\",\n        \"*.glsl\": \"paper-cranes-fragment-shader\",\n        \"*.crane\": \"paper-cranes-fragment-shader\"\n      }\n    },\n    \"commands\": [\n      {\n        \"command\": \"paper-cranes-fragment-shader.activate\",\n        \"title\": \"Activate Paper Cranes Shader\"\n      }\n    ]\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.x\",\n    \"@types/vscode\": \"^1.93.1\",\n    \"@vscode/vsce\": \"^3.x\",\n    \"typescript\": \"^5.x\"\n  },\n  \"files\": [\n    \"logo.png\",\n    \"out/**\",\n    \"language-configuration.json\",\n    \"LICENSE\",\n    \"paper-cranes-fragment-shader.tmLanguage.json\"\n  ],\n  \"extensionDependencies\": [\n    \"slevesque.shader\"\n  ],\n  \"activationEvents\": [\n    \"onLanguage:paper-cranes-fragment-shader\",\n    \"onCommand:paper-cranes-fragment-shader.activate\"\n  ]\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 143,
            "endLine": 150,
            "text": "\n\n/* Optional adjustments for a better layout */\n#feature-editor, #visualizer, #monaco-editor {\n    width: 100%; /* Ensures full utilization of their grid cell's width */\n    height: 100%; /* For #monaco-editor to fully expand vertically, depending on your design needs */\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/.nvmrc",
            "startLine": 1,
            "endLine": 2,
            "text": "v22.8.0\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 19,
            "endLine": 29,
            "text": "\nBehind the scenes, this loads code for what's called a 'shader' from the `shaders/` directory. These are written in GLSL, and are the code that actually runs on the GPU to make the visualizations. In the above example, the 'star' visualization is defined in `shaders/star.frag`. You can look at other files in the `shaders/` directory to see which visualizations are available.\n\nThis project is deployed at [visuals.beadfamous.com](https://visuals.beadfamous.com), and you can view the visualizations there as well.\n\n## Making your own visualizations\n\nMaking your own visualization is easy, but requires some knowledge of GLSL shading language.\nLucky for you, I'm hosting a hackathon with HeatSync Labs next month, in which we go from nothing to a working visualization and bracelet in a couple of hours next month! Stay tuned for more details.\n\nTo make your own visualizations, you can create a new file in the `shaders/` directory, and then load it by specifying the 'shader' query param in the url. For example, to view the 'my_new_shader' visualization, you would go to [localhost:6969/?shader=my_new_shader](http://localhost:6969/?shader=my_new_shader)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 403,
            "endLine": 432,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      provideHover(document: vscode.TextDocument, position: vscode.Position) {\n          ...\n          trebleMedian: \"Median treble energy value.\",\n          trebleStandardDeviation: \"How much the treble energy varies.\",\n          trebleZScore: \"How many standard deviations from mean (-1 to 1).\",\n          trebleMin: \"Minimum treble energy observed.\",\n          trebleMax: \"Maximum treble energy observed.\",\n\n          // Beat Detection\n          beat: \"Boolean indicating if current frame is on a beat.\",\n\n          // Helper Functions\n          getLastFrameColor: \"Returns the color from the previous frame at the given UV coordinate.\\nUsage: getLastFrameColor(vec2 uv)\",\n          rgb2hsl: \"Converts RGB color to HSL color space.\\nUsage: rgb2hsl(vec3 rgb)\",\n          hsl2rgb: \"Converts HSL color to RGB color space.\\nUsage: hsl2rgb(vec3 hsl)\",\n          hslmix: \"Mixes two colors in HSL space.\\nUsage: hslmix(vec3 col1, vec3 col2, float t)\",\n          map: \"Maps a value from one range to another.\\nUsage: map(float value, float inMin, float inMax, float outMin, float outMax)\",\n\n          // Constants\n          PI: \"Mathematical constant \u03c0 (3.14159...)\",\n          resolution: \"Screen resolution in pixels (vec2)\",\n          time: \"Current time in seconds (float)\",\n          random: \"Returns a random value between 0-1.\\nUsage: random(vec2 st)\",\n        };\n\n        const info = hoverInfo[word];\n        if (info) {\n          return new vscode.Hover(info);\n        }\n\n        return undefined;\n      }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 5,
            "endLine": 11,
            "text": "export function activate(context: vscode.ExtensionContext) {\n  console.log(\"\ud83c\udfee Paper Cranes Extension Activated \ud83c\udfee\");\n\n  // Register completion provider\n  const completionProvider = vscode.languages.registerCompletionItemProvider(\n    { scheme: \"file\", language: \"paper-cranes-fragment-shader\" },\n    {",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".gitignore",
            "startLine": 67,
            "endLine": 149,
            "text": "\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variables file\n.env\n.env.test\n.envrc\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n\n# Next.js build output\n.next\n\n# Nuxt.js build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and *not* Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# TernJS port file\n.tern-port\ntmp\nout/\n\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n*.out\n\n# yarn\n/node_modules\n/.pnp\n.pnp.js\n\n# testing\n/coverage\n\n# production\n/build\n\n# misc\n.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# stupid yarn config\n.yarn/cache\n\n**/.yarn/*\n**/.yarn/*\n.\n!**/.yarn/plugins/\n!**/.yarn/releases/\n!**/.yarn/sdks/\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".nvmrc",
            "startLine": 1,
            "endLine": 2,
            "text": "v22.8.0\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/window-processor.js",
            "startLine": 1,
            "endLine": 31,
            "text": "class WindowProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n        return [] // Add any parameters you might need, like window type\n    }\n\n    constructor() {\n        super()\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0]\n        const output = outputs[0]\n\n        if (input.length > 0) {\n            const windowLength = input[0].length\n            for (let channel = 0; channel < input.length; channel++) {\n                const inputChannel = input[channel]\n                const outputChannel = output[channel]\n                for (let i = 0; i < windowLength; i++) {\n                    // Apply a Hanning window as an example\n                    const windowCoeff = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (windowLength - 1)))\n                    outputChannel[i] = inputChannel[i] * windowCoeff\n                }\n            }\n        }\n\n        return true // Keep processor alive\n    }\n}\n\nregisterProcessor('window-processor', WindowProcessor)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.js",
            "startLine": 20,
            "endLine": 59,
            "text": "const FeatureEditor = ({ name, feature, onChange, onDelete }) => {\n    const handleValueChange = (e) => onChange(name, { ...feature, value: parseFloat(e.target.value) })\n    const handleMinChange = (e) => onChange(name, { ...feature, min: parseFloat(e.target.value) })\n    const handleMaxChange = (e) => onChange(name, { ...feature, max: parseFloat(e.target.value) })\n    const handleCommitValue = () => {\n        delete window.cranes?.manualFeatures[name]\n        updateUrlDebounced({ [name]: feature.value })\n    }\n    // Update the URL immediately for live updates\n    useEffect(() => {\n        updateUrlDebounced({\n            [name]: feature.value,\n            [`${name}.min`]: feature.min,\n            [`${name}.max`]: feature.max,\n        })\n        if (window.cranes?.manualFeatures) {\n            window.cranes.manualFeatures[name] = feature.value\n        }\n    }, [feature])\n\n    return html`\n        <div className=\"edit-feature\" key=${name}>\n            <label>${name}:</label>\n            <input class=\"min-feature-value\" type=\"number\" step=\"0.1\" value=${feature.min} onInput=${handleMinChange} />\n            <input\n                class=\"feature-value\"\n                type=\"range\"\n                min=${feature.min}\n                max=${feature.max}\n                step=\"0.01\"\n                value=${feature.value}\n                onInput=${handleValueChange}\n                onChange=${handleCommitValue}\n            />\n            <span> (${feature.value})</span>\n            <input class=\"max-feature-value\" type=\"number\" step=\"0.1\" value=${feature.max} onInput=${handleMaxChange} />\n            <button onClick=${() => onDelete(name)}>x</button>\n        </div>\n    `\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 490,
            "endLine": 508,
            "text": "function init() {\n    ...\n    // Update the undo/redo commands to work on both Windows and Mac\n    editor.addCommand(monaco.KeyMod.WinCtrl | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'undo', null)\n    })\n\n    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'undo', null)\n    })\n\n    editor.addCommand(monaco.KeyMod.WinCtrl | monaco.KeyMod.Shift | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'redo', null)\n    })\n\n    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_Z, () => {\n        editor.trigger('keyboard', 'redo', null)\n    })\n\n    document.querySelector('#publish').addEventListener('click', () => {})\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 432,
            "endLine": 437,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      },\n    },\n  );\n\n  context.subscriptions.push(completionProvider, hoverProvider);\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 190,
            "endLine": 307,
            "text": "function init() {\n        ...\n        'return',\n        'sampler2D',\n        'samplerCube',\n        'sampler3D',\n        'struct',\n        'radians',\n        'degrees',\n        'sin',\n        'cos',\n        'tan',\n        'asin',\n        'acos',\n        'atan',\n        'pow',\n        'sinh',\n        'cosh',\n        'tanh',\n        'asinh',\n        'acosh',\n        'atanh',\n        'exp',\n        'log',\n        'exp2',\n        'log2',\n        'sqrt',\n        'inversesqrt',\n        'abs',\n        'sign',\n        'floor',\n        'ceil',\n        'round',\n        'roundEven',\n        'trunc',\n        'fract',\n        'mod',\n        'modf',\n        'min',\n        'max',\n        'clamp',\n        'mix',\n        'step',\n        'smoothstep',\n        'length',\n        'distance',\n        'dot',\n        'cross ',\n        'determinant',\n        'inverse',\n        'normalize',\n        'faceforward',\n        'reflect',\n        'refract',\n        'matrixCompMult',\n        'outerProduct',\n        'transpose',\n        'lessThan ',\n        'lessThanEqual',\n        'greaterThan',\n        'greaterThanEqual',\n        'equal',\n        'notEqual',\n        'any',\n        'all',\n        'not',\n        'packUnorm2x16',\n        'unpackUnorm2x16',\n        'packSnorm2x16',\n        'unpackSnorm2x16',\n        'packHalf2x16',\n        'unpackHalf2x16',\n        'dFdx',\n        'dFdy',\n        'fwidth',\n        'textureSize',\n        'texture',\n        'textureProj',\n        'textureLod',\n        'textureGrad',\n        'texelFetch',\n        'texelFetchOffset',\n        'textureProjLod',\n        'textureLodOffset',\n        'textureGradOffset',\n        'textureProjLodOffset',\n        'textureProjGrad',\n        'intBitsToFloat',\n        'uintBitsToFloat',\n        'floatBitsToInt',\n        'floatBitsToUint',\n        'isnan',\n        'isinf',\n        'vec2',\n        'vec3',\n        'vec4',\n        'ivec2',\n        'ivec3',\n        'ivec4',\n        'uvec2',\n        'uvec3',\n        'uvec4',\n        'bvec2',\n        'bvec3',\n        'bvec4',\n        'mat2',\n        'mat3',\n        'mat2x2',\n        'mat2x3',\n        'mat2x4',\n        'mat3x2',\n        'mat3x3',\n        'mat3x4',\n        'mat4x2',\n        'mat4x3',\n        'mat4x4',\n        'mat4',\n        'float',\n        'int',\n        'uint'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 258,
            "endLine": 284,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      provideHover(document: vscode.TextDocument, position: vscode.Position) {\n        console.log(`provideHover for ${document.uri}`);\n        const range = document.getWordRangeAtPosition(position);\n        if (!range) {\n          return undefined;\n        }\n\n        const word = document.getText(range);\n        if (!word) {\n          return undefined;\n        }\n\n        const hoverInfo: { [key: string]: string } = {\n          // Spectral Centroid\n          spectralCentroid: \"The center of mass of the spectrum. Higher values indicate 'brighter' sounds.\",\n          spectralCentroidNormalized: \"Normalized spectral centroid (0-1). Higher values = brighter sounds.\",\n          spectralCentroidMean: \"Average spectral centroid over time.\",\n          spectralCentroidMedian: \"Median spectral centroid value.\",\n          spectralCentroidStandardDeviation: \"How much the spectral centroid varies.\",\n          spectralCentroidZScore: \"How many standard deviations from mean (-1 to 1). Good for detecting dramatic timbral changes.\",\n          spectralCentroidMin: \"Minimum spectral centroid value observed.\",\n          spectralCentroidMax: \"Maximum spectral centroid value observed.\",\n\n          // Spectral Flux\n          spectralFlux: \"Rate of change of the spectrum. Higher values = more dramatic changes.\",\n          spectralFluxNormalized: \"Normalized spectral flux (0-1). Good for detecting onsets.\",\n          spectralFluxMean: \"Average spectral flux over time.\"",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 248,
            "endLine": 257,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      },\n    },\n    \".\", // Trigger completion on dot\n    \" \", // Trigger completion on space\n  );\n\n  // Register hover provider\n  const hoverProvider = vscode.languages.registerHoverProvider(\n    { scheme: \"file\", language: \"paper-cranes-fragment-shader\" },\n    {",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralEntropy.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralEntropy } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralEntropy(fft) // Compute spectral kurtosis\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 30,
            "endLine": 42,
            "text": "\nYou can copy and paste any of the existing files in the `shaders/` directory to get started. Or ya know, wait until the Hackathon and I'll walk you through it.\n\nIf you want to deploy a visualization you made, PR me and I'll add it to the deployed site!\n\n## Deploying your visualization to visuals.beadfamous.com\n\nBeadfamous has no backend. But you can still host your shader there.\nAny pull request that only touches files under the shaders/<YOUR_GITHUB_USERNAME> will be automatically merged to main and deployed to Beadfamous. If this is your first commit, it will require manual approval. Afterwards, all your shaders will be automatically deployed.\n\nMaking a pull request will usually mean you need to fork the repo, make your changes, and then make a pull request from your fork to the main repo. If you're not familiar with this process, here's a [tutorial](https://guides.github.com/activities/forking/).\n\nIf you want to quickly make a pull request without cloning the repo down, you can add your shader through the Github UI. Here's a quick guide:",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 53,
            "endLine": 101,
            "text": "function init() {\n        ...\n        'spectralRolloffStandardDeviation',\n        'spectralRolloffMedian',\n        'spectralRolloffZScore',\n        'spectralRolloffMin',\n        'spectralRolloffMax',\n        'spectralCentroid',\n        'spectralCentroidNormalized',\n        'spectralCentroidMean',\n        'spectralCentroidStandardDeviation',\n        'spectralCentroidMedian',\n        'spectralCentroidZScore',\n        'spectralCentroidMin',\n        'spectralCentroidMax',\n        'spectralEntropy',\n        'spectralEntropyNormalized',\n        'spectralEntropyMean',\n        'spectralEntropyStandardDeviation',\n        'spectralEntropyMedian',\n        'spectralEntropyZScore',\n        'spectralEntropyMin',\n        'spectralEntropyMax',\n        'spectralSpread',\n        'spectralSpreadNormalized',\n        'spectralSpreadMean',\n        'spectralSpreadStandardDeviation',\n        'spectralSpreadMedian',\n        'spectralSpreadZScore',\n        'spectralSpreadMin',\n        'spectralSpreadMax',\n        'spectralRoughness',\n        'spectralRoughnessNormalized',\n        'spectralRoughnessMean',\n        'spectralRoughnessStandardDeviation',\n        'spectralRoughnessMedian',\n        'spectralRoughnessZScore',\n        'spectralRoughnessMin',\n        'spectralRoughnessMax',\n        'spectralKurtosis',\n        'spectralKurtosisNormalized',\n        'spectralKurtosisMean',\n        'spectralKurtosisStandardDeviation',\n        'spectralKurtosisMedian',\n        'spectralKurtosisZScore',\n        'spectralKurtosisMin',\n        'spectralKurtosisMax',\n        'spectralCrest',\n        'spectralCrestNormalized',\n        'spectralCrestMean',\n        'spectralCrestStandardDeviation'",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/README.md",
            "startLine": 1,
            "endLine": 37,
            "text": "# Paper Cranes Shader Syntax\n\nLanguage support for [Paper Cranes](https://github.com/loqwai/paper-cranes) audio visualization shaders.\n\n## Features\n\n- Syntax highlighting for GLSL shader files (`.frag`, `.vert`, `.glsl`)\n- Intelligent code completion for Paper Cranes-specific uniforms and functions including:\n    - Audio analysis uniforms (`spectralCentroid`, `energy`, `spectralRolloff`, etc.)\n    - Helper functions (`getLastFrameColor`, `mapValue`)\n    - Constants (`PI`, `resolution`, `time`)\n- Smart bracket matching and auto-closing pairs\n- Comment toggling support (line and block comments)\n\n## Installation\n\n`code --install-extension paper-cranes-shader-syntax-1.0.0.vsix`\n\nOr install directly from the VS Code marketplace by searching for \"Paper Cranes Shader Syntax\".\n\n## Development\n\n1. Clone the repository\n2. Install dependencies:\n    ```bash\n    npm install\n    ```\n3. Build the extension:\n    ```bash\n    npm run build\n    ```\n\n## Usage with Paper Cranes\n\nThis extension is designed to work with the [Paper Cranes](https://github.com/loqwai/paper-cranes) audio visualization project. It provides enhanced editing support when working with Paper Cranes shader files.\n\n## License",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralRolloff.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralRolloff } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralRolloff(fft) // Compute spectral rolloff\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "README.md",
            "startLine": 43,
            "endLine": 51,
            "text": "\n1. Start creating a new file in the `shaders/` directory of the paper-cranes repo [here](https://github.com/loqwai/paper-cranes/new/main/shaders).\n\nThis will automatically fork the repo to your account, and create a new file in your fork.\n\n2. After the fork is created, you can add your shader to the project. The shader must be added to `shaders/<YOUR_GITHUB_USERNAME>/`. For example, if your github username is `loqwai`, you would add your shader to `shaders/loqwai/`. You can create the directory by adding a `/` to the end of the path in the file creation dialog.\n\n3. After you've added your shader, you can create a pull request to the main repo. This will automatically trigger a deployment to [visuals.beadfamous.com](https://visuals.beadfamous.com). For example if your shader is file located at `shaders/loqwai/my_new_shader.frag`, the visualization will be available at `visuals.beadfamous.com/?shader=loqwai/my_new_shader`\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralFlux.js",
            "startLine": 1,
            "endLine": 21,
            "text": "import { makeCalculateStats, spectralFlux } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\nlet previousSignal = new Float32Array() // Initialize with zeros\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data\n\n        if (!previousSignal.length) {\n            previousSignal = new Float32Array(fft.length)\n            return\n        }\n\n        const value = spectralFlux(fft, previousSignal)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/SpectralKurtosis.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, spectralKurtosis } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = spectralKurtosis(fft) // Compute spectral kurtosis\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/Energy.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { energy, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = energy(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.html",
            "startLine": 1,
            "endLine": 28,
            "text": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <title>Audio Analysis</title>\n  <link rel=\"stylesheet\" href=\"analyze.css\" />\n  <link rel=\"stylesheet\" href=\"BarGraph.css\" />\n</head>\n\n<body>\n  <div class=\"container\">\n    <div class=\"upload-section\">\n      <input type=\"file\" id=\"audioFile\" accept=\"audio/mp3\" />\n      <button id=\"analyze\" disabled>Analyze</button>\n      <button id=\"download\" disabled>Download Results</button>\n    </div>\n    <div class=\"progress-section\">\n      <div id=\"progress-bar\" class=\"progress-bar\">\n        <div id=\"progress\" class=\"progress\"></div>\n      </div>\n      <div id=\"status\">Upload an MP3 file to begin</div>\n    </div>\n  </div>\n  <script type=\"module\" src=\"./analyze.js\"></script>\n</body>\n\n</html>\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 93,
            "endLine": 142,
            "text": "\n\nbody {\n    display: grid;\n    grid-template-columns: 50% 50%;\n    grid-template-rows: auto; /* Define two rows, their size determined by the content */\n    height: 100vh; /* Ensure the body takes up the full viewport height */\n}\n\nbody.no-editor {\n    display:flex;\n    /* reverse the order of the flex items */\n    flex-direction: row-reverse;\n}\nbody.no-editor #save-and-publish, body.no-editor #monaco-editor{\n   display: none;\n}\nbody.present #feature-editor {\n  display:none;\n}\n#feature-editor {\n    grid-column: 1; /* Places it in the first column */\n    grid-row: 1; /* Places it in the first row */\n}\n\n#save-and-publish {\n    grid-column:2;\n    grid-row: 1;\n    display: flex;\n}\n#save-and-publish > button {\n    flex: 1;\n    cursor:pointer;\n    margin: 1em;\n\n}\n#save-and-publish > button > a {\n    /* clear the default styles */\n    text-decoration: none;\n    color: inherit;\n}\n#monaco-editor {\n    grid-column: 2; /* Places it in the second column */\n    grid-row: 2; /* Places it in the first row */\n    /*span 2 rows*/\n}\n#visualizer {\n    grid-column: 1; /* Also in the first column */\n    grid-row: 2; /* But in the second row, under #feature-editor */\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".cursorrules",
            "startLine": 21,
            "endLine": 59,
            "text": "\n```glsl\n#version 300 es\nprecision mediump float;\nout vec4 fragColor;\nuniform vec4 iMouse;\nuniform float iTime;\nuniform vec3 iResolution;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\nuniform int iFrame;\n\nuniform float spectralCentroidNormalized;\nuniform float spectralCentroidMean;\nuniform float spectralCentroidMedian;\nuniform float spectralCentroidStandardDeviation;\nuniform float spectralCentroidZScore;\nuniform float spectralCentroidMin;\nuniform float spectralCentroidMax;\nuniform float spectralCentroid;\nuniform float spectralFluxNormalized;\nuniform float spectralFluxMean;\nuniform float spectralFluxMedian;\nuniform float spectralFluxStandardDeviation;\nuniform float spectralFluxZScore;\nuniform float spectralFluxMin;\nuniform float spectralFluxMax;\nuniform float spectralFlux;\nuniform float spectralSpreadNormalized;\nuniform float spectralSpreadMean;\nuniform float spectralSpreadMedian;\nuniform float spectralSpreadStandardDeviation;\nuniform float spectralSpreadZScore;\nuniform float spectralSpreadMin;\nuniform float spectralSpreadMax;\nuniform float spectralSpread;\nuniform float spectralRolloffNormalized;",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/README.md",
            "startLine": 38,
            "endLine": 40,
            "text": "\nMIT License - see LICENSE file for details.\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/shader-transformers/shader-wrapper.js",
            "startLine": 1,
            "endLine": 53,
            "text": "import { getFlatAudioFeatures } from '../audio/AudioProcessor'\n\nexport const shaderWrapper = (shader) => {\n    const [firstLine, ...lines] = shader.split('\\n')\n    if (firstLine.includes('#version')) {\n        lines.unshift('#define PAPER_CRANES 1')\n        lines.unshift(firstLine)\n        return lines.join('\\n')\n    }\n    if (shader.includes('mainImage')) {\n        return /* glsl */ `\n#version 300 es\nprecision mediump float;\n\nout vec4 fragColor;\n${shaderToyCompatibilityUniforms()}\n${getAudioUniforms()}\n\n${paperCranes()}\nvec4 getLastFrameColor(vec2 uv){\n    return texture(prevFrame, uv);\n}\nvec4 getInitialFrameColor(vec2 uv){\n    return texture(initialFrame, uv);\n}\n${shader}\n\nvoid main(void){\n    mainImage(fragColor, gl_FragCoord.xy);\n}\n`\n    }\n    throw new Error('Shader does not contain mainImage function. It should look like this: void mainImage( out vec4 fragColor, in vec2 fragCoord ) { ... }')\n}\n\nconst shaderToyCompatibilityUniforms = () => /* glsl */ `\nuniform vec4 iMouse;\nuniform float iTime;\nuniform vec3 iResolution;\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\nuniform int iFrame;\n`\nconst getAudioUniforms = () => {\n    const uniforms = []\n    for (const f in getFlatAudioFeatures()) {\n        uniforms.push(`uniform float ${f};`)\n    }\n    uniforms.push('uniform bool beat;') // yeah, this needs to go somewhere else\n    return uniforms.join('\\n')\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".github/workflows/submit-shader.yml",
            "startLine": 28,
            "endLine": 40,
            "text": "\n                      const isValidScope = filesChanged.data.every(file => {\n                        const inUserFolder = file.filename.startsWith(`shaders/${username}/`);\n                        const isFragmentShader = file.filename.endsWith('.frag');\n                        return inUserFolder && isFragmentShader;\n                      });\n\n                      core.setOutput('valid_scope', isValidScope.toString());\n                      if (!isValidScope) {\n                        console.log(\"PR contains changes outside the user's specific directory.\");\n                      } else {\n                        console.log(\"All changes are within the user's specific directory.\");\n                      }",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/PitchClass.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { makeCalculateStats, pitchClass } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = pitchClass(fft) // Compute spectral kurtosis\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/audio/analyzers/Mids.js",
            "startLine": 1,
            "endLine": 14,
            "text": "import { mids, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data // Extract FFT data from message\n        const value = mids(fft)\n        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "shaders/practice/wave.frag",
            "startLine": 1,
            "endLine": 37,
            "text": "\n// #pragma glslify: import(./includes/shadertoy-compat)\n/* \"Wired\" by @kishimisu (2024)\n\n   I wonder what it's powering...\n*/\n\n#define r(a)    mat2(cos(a + vec4(0,33,11,0)));\n#define R(p, T) p.yx *= r(round((atan(p.y, p.x) + T) * 1.91) / 1.91 - T)\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float i, t, d, k = iTime/8.;\n\n    for (O *= i; i < 35.; i++) {\n        vec3 R = iResolution,\n             p = t * normalize(vec3(F+F-R.xy, R.y));\n\n        p.z  -= spectralRoughnessZScore + 3.;\n        p.xz *= r(k+spectralEntropyZScore*2.)\n        p.zy *= r(k+k)\n        d = length(p) - sin(k+k)*spectralRolloffNormalized -spectralKurtosisNormalized;\n\n        p.y  += sin(p.x*3. * cos(k+k) + k*4.) * sin(k)*.3;\n        R(p, 0.)\n        R(p.xz, k)\n        p.x = mod(p.x + k*8., 2.) - 1.;\n\n        t += d = min(d, length(p.yz) - (energyZScore/2.))*spectralCentroid;\n        O += .01 * (1. + cos(t*.5 - k-k + vec4(0,1,2,0)))\n                 / (1. + length(p)*4. - .02) + (.03 + sin(k)*.01) / (1. + d*24.);\n    }\n    vec3 hslBg = vec3(spectralCentroid,1.,0.8);\n\n    O *= vec4(hsl2rgb(hslBg), 1.);\n}\n// #pragma glslify:import(./includes/shadertoy-compat-main)\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 91,
            "endLine": 146,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n        ...\n        // Paper Cranes Audio Analysis Uniforms\n        const audioUniforms = [\n          // Spectral Centroid\n          \"spectralCentroid\",\n          \"spectralCentroidNormalized\",\n          \"spectralCentroidMean\",\n          \"spectralCentroidMedian\",\n          \"spectralCentroidStandardDeviation\",\n          \"spectralCentroidZScore\",\n          \"spectralCentroidMin\",\n          \"spectralCentroidMax\",\n\n          // Spectral Flux\n          \"spectralFlux\",\n          \"spectralFluxNormalized\",\n          \"spectralFluxMean\",\n          \"spectralFluxMedian\",\n          \"spectralFluxStandardDeviation\",\n          \"spectralFluxZScore\",\n          \"spectralFluxMin\",\n          \"spectralFluxMax\",\n\n          // Spectral Spread\n          \"spectralSpread\",\n          \"spectralSpreadNormalized\",\n          \"spectralSpreadMean\",\n          \"spectralSpreadMedian\",\n          \"spectralSpreadStandardDeviation\",\n          \"spectralSpreadZScore\",\n          \"spectralSpreadMin\",\n          \"spectralSpreadMax\",\n\n          // Spectral Rolloff\n          \"spectralRolloff\",\n          \"spectralRolloffNormalized\",\n          \"spectralRolloffMean\",\n          \"spectralRolloffMedian\",\n          \"spectralRolloffStandardDeviation\",\n          \"spectralRolloffZScore\",\n          \"spectralRolloffMin\",\n          \"spectralRolloffMax\",\n\n          // Spectral Roughness\n          \"spectralRoughness\",\n          \"spectralRoughnessNormalized\",\n          \"spectralRoughnessMean\",\n          \"spectralRoughnessMedian\",\n          \"spectralRoughnessStandardDeviation\",\n          \"spectralRoughnessZScore\",\n          \"spectralRoughnessMin\",\n          \"spectralRoughnessMax\",\n\n          // Spectral Kurtosis\n          \"spectralKurtosis\",\n          \"spectralKurtosisNormalized\",\n          \"spectralKurtosisMean\"",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/Visualizer.js",
            "startLine": 162,
            "endLine": 163,
            "text": "export const makeVisualizer = async ({ canvas, initialImageUrl, fullscreen }) => {\n    ...\n    return render\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "edit.css",
            "startLine": 33,
            "endLine": 66,
            "text": "\n.save-load {\n    margin-top: 0.5em;\n    display: flex;\n    flex-direction: row;\n    justify-content: start;\n}\n:root {\n    --foreground-rgb: 0, 0, 0;\n    --background-start-rgb: 214, 219, 220;\n    --background-end-rgb: 255, 255, 255;\n    /* Cosmic Color Scheme */\n    --color-space-black: #000000;\n    --color-nebula-purple: #a365f2;\n    --color-asteroid-pink: #e16ce6;\n    --color-galaxy-blue: #a398f4;\n    --color-comet-tail: #e099e6;\n    --color-starlight-blue: #6195f9;\n    --color-deep-sky: #2198fb;\n    --color-twilight-purple: #6566f4;\n    --color-alien-green: #a22bec;\n    --color-rocket-metal: #2065f5;\n    --color-lunar-white: #e6e6e6;\n\n    --radius: 0.5rem;\n}\n\n/* Sparkly Class */\n.sparkly {\n    background: linear-gradient(\n        270deg,\n        var(--color-nebula-purple),\n        var(--color-asteroid-pink),\n        var(--color-comet-tail),",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.js",
            "startLine": 174,
            "endLine": 174,
            "text": "render(html`<${Analyzer} />`, document.body)",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 353,
            "endLine": 376,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      provideHover(document: vscode.TextDocument, position: vscode.Position) {\n          ...\n          spectralCrestNormalized: \"Normalized spectral crest (0-1).\",\n          spectralCrestMean: \"Average spectral crest over time.\",\n          spectralCrestMedian: \"Median spectral crest value.\",\n          spectralCrestStandardDeviation: \"How much the spectral crest varies.\",\n          spectralCrestZScore: \"How many standard deviations from mean (-1 to 1).\",\n          spectralCrestMin: \"Minimum spectral crest value observed.\",\n          spectralCrestMax: \"Maximum spectral crest value observed.\",\n\n          // Spectral Skew\n          spectralSkew: \"Measure of spectrum asymmetry. Higher values = more energy in high frequencies.\",\n          spectralSkewNormalized: \"Normalized spectral skew (0-1).\",\n          spectralSkewMean: \"Average spectral skew over time.\",\n          spectralSkewMedian: \"Median spectral skew value.\",\n          spectralSkewStandardDeviation: \"How much the spectral skew varies.\",\n          spectralSkewZScore: \"How many standard deviations from mean (-1 to 1).\",\n          spectralSkewMin: \"Minimum spectral skew value observed.\",\n          spectralSkewMax: \"Maximum spectral skew value observed.\",\n\n          // Pitch Class\n          pitchClass: \"Dominant pitch class (0-11, where 0=C, 1=C#, etc).\",\n          pitchClassNormalized: \"Normalized pitch class (0-1).\",\n          pitchClassMean: \"Average pitch class over time.\",\n          pitchClassMedian: \"Median pitch class value.\",\n          pitchClassStandardDeviation: \"How much the pitch class varies.\"",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/components/RadialGraph.js",
            "startLine": 1,
            "endLine": 7,
            "text": "import { html } from 'htm/preact'\nimport { useState } from 'preact/hooks'\nimport { AudioFeatures } from '../audio/AudioProcessor'\n\nconst FEATURE_SUFFIXES = ['Normalized', 'ZScore', 'Mean', 'StandardDeviation', 'Median', 'Min', 'Max']\n\nconst RadialGraph",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/index.ts",
            "startLine": 377,
            "endLine": 402,
            "text": "export function activate(context: vscode.ExtensionContext) {\n      ...\n      provideHover(document: vscode.TextDocument, position: vscode.Position) {\n          ...\n          pitchClassZScore: \"How many standard deviations from mean (-1 to 1).\",\n          pitchClassMin: \"Minimum pitch class value observed.\",\n          pitchClassMax: \"Maximum pitch class value observed.\",\n\n          // Frequency Bands\n          bass: \"Low frequency energy (20-250Hz).\",\n          bassNormalized: \"Normalized bass energy (0-1). Good for bass-driven effects.\",\n          bassMean: \"Average bass energy over time.\",\n          bassMedian: \"Median bass energy value.\",\n          bassStandardDeviation: \"How much the bass energy varies.\",\n          bassZScore: \"How many standard deviations from mean (-1 to 1). Good for detecting bass drops.\",\n          bassMin: \"Minimum bass energy observed.\",\n          bassMax: \"Maximum bass energy observed.\",\n\n          mids: \"Mid frequency energy (250-2000Hz).\",\n          midsNormalized: \"Normalized mids energy (0-1). Good for melody-driven effects.\",\n          midsMean: \"Average mids energy over time.\",\n          midsMedian: \"Median mids energy value.\",\n          midsStandardDeviation: \"How much the mids energy varies.\",\n          midsZScore: \"How many standard deviations from mean (-1 to 1).\",\n          midsMin: \"Minimum mids energy observed.\",\n          midsMax: \"Maximum mids energy observed.\",\n\n          treble: \"High frequency energy (2000-20000Hz).\",\n          trebleNormalized: \"Normalized treble energy (0-1). Good for cymbal/hi-hat driven effects.\",\n          trebleMean: \"Average treble energy over time.\"",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "scripts/normalize-analysis.js",
            "startLine": 1,
            "endLine": 66,
            "text": "#!/usr/bin/env node\n\nimport { parseArgs } from 'node:util'\nimport fs from 'fs/promises'\nimport { normalizeAnalysisData } from '../src/audio/normalizer.js'\n\nconst options = {\n    input: {\n        type: 'string',\n        short: 'i',\n        default: 'audio-analysis.json'\n    },\n    output: {\n        type: 'string',\n        short: 'o',\n        default: 'normalized-analysis.json'\n    },\n    help: {\n        type: 'boolean',\n        short: 'h'\n    }\n}\n\nconst {\n    values: { help, input, output }\n} = parseArgs({ options })\n\nif (help) {\n    console.log(`\nUsage: normalize-analysis [options]\n\nOptions:\n  -i, --input   Input JSON file (default: \"audio-analysis.json\")\n  -o, --output  Output JSON file (default: \"normalized-analysis.json\")\n  -h, --help    Show this help message\n\nDescription:\n  Normalizes all properties in an audio analysis file to values between 0 and 1,\n  where 0 represents the minimum value found for that property across all timestamps,\n  and 1 represents the maximum value.\n`)\n    process.exit(0)\n}\n\nasync function normalizeAnalysis() {\n    try {\n        // Read and parse the input file\n        const data = JSON.parse(await fs.readFile(input, 'utf8'))\n\n        // Use shared normalizer\n        const { normalized, ranges } = normalizeAnalysisData(data)\n\n        // Write the normalized data\n        await fs.writeFile(output, JSON.stringify(normalized))\n        console.log(`Normalized data written to ${output}`)\n\n        // Also save the ranges for reference\n        const rangesFile = output.replace('.json', '-ranges.json')\n        await fs.writeFile(rangesFile, JSON.stringify(ranges, null, 2))\n        console.log(`Range information written to ${rangesFile}`)\n\n    } catch (error) {\n        console.error('Error:', error.message)\n        process.exit(1)\n    }\n}",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 509,
            "endLine": 509,
            "text": "init()",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "src/monaco.js",
            "startLine": 308,
            "endLine": 362,
            "text": "function init() {\n        ...\n        'void',\n        'bool',\n    ]\n\n    const language = {\n        tokenPostfix: '.glsl',\n        // Set defaultToken to invalid to see what you do not tokenize yet\n        defaultToken: 'invalid',\n        keywords,\n        operators: [\n            '=',\n            '>',\n            '<',\n            '!',\n            '~',\n            '?',\n            ':',\n            '==',\n            '<=',\n            '>=',\n            '!=',\n            '&&',\n            '||',\n            '++',\n            '--',\n            '+',\n            '-',\n            '*',\n            '/',\n            '&',\n            '|',\n            '^',\n            '%',\n            '<<',\n            '>>',\n            '>>>',\n            '+=',\n            '-=',\n            '*=',\n            '/=',\n            '&=',\n            '|=',\n            '^=',\n            '%=',\n            '<<=',\n            '>>=',\n            '>>>=',\n        ],\n        symbols: /[=><!~?:&|+\\-*\\/\\^%]+/,\n        escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n        integersuffix: /([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,\n        floatsuffix: /[fFlL]?/,\n        encoding: /u|u8|U|L/,\n\n        tokenizer: {",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "vscode-extension/paper-cranes-fragment-shader.tmLanguage.json",
            "startLine": 1,
            "endLine": 35,
            "text": "{\n    \"name\": \"Paper Cranes Fragment Shader\",\n    \"scopeName\": \"source.paper-cranes-fragment-shader\",\n    \"patterns\": [\n      {\n        \"include\": \"source.glsl\"\n      },\n      {\n        \"include\": \"#paper-cranes-additions\"\n      }\n    ],\n    \"repository\": {\n      \"paper-cranes-additions\": {\n        \"patterns\": [\n          {\n            \"name\": \"support.variable.uniform.paper-cranes\",\n            \"match\": \"\\\\b(spectralCentroid|spectralCentroidNormalized|spectralFlux|energy|bass|mids|treble|beat|spectralRoughness|spectralKurtosis|spectralSpread|spectralRolloff|spectralCrest|spectralSkew|pitchClass|spectralEntropy)\\\\b\"\n          },\n          {\n            \"name\": \"support.variable.uniform.stats.paper-cranes\",\n            \"match\": \"\\\\b(\\\\w+)(Mean|Median|Min|Max|StandardDeviation|ZScore|Normalized)\\\\b\"\n          },\n          {\n            \"name\": \"support.function.paper-cranes\",\n            \"match\": \"\\\\b(rgb2hsl|hsl2rgb|getLastFrameColor|mapValue)\\\\b\"\n          },\n          {\n            \"name\": \"support.constant.paper-cranes\",\n            \"match\": \"\\\\b(PI|TAU|EPSILON)\\\\b\"\n          }\n        ]\n      }\n    }\n  }\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": ".cursorrules",
            "startLine": 1,
            "endLine": 20,
            "text": "# Music Visualization Shader Requirements\n\n## Overview\n\nThese shaders are used to create real-time music visualizations that control LED lights through screen scraping. The goal is to create engaging, psychedelic patterns that react meaningfully to music while avoiding too many visual dead zones (solid black or white areas).\n\n## Core Requirements\n\n### Visual Quality\n\n- Create intricate, evolving fractal-like patterns\n- Maintain constant visual interest across the entire screen\n- Avoid large areas of solid black or white\n- Make the movement aesthetic and artistic, like something you'd see in an interactive art museum\n\n### Audio Reactivity\n\nYou use webgl shaders to create the visuals. There are a variety of them in the shaders folder.\nThese shaders are snippits of a glsl fragment shader that have the initialization and uniform declarations added before rendering.\nThe uniforms have a large amount of audio features and other utility functions. After the compilation, the first part of the shader looks like this:",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "working-shaders.txt",
            "startLine": 1,
            "endLine": 9,
            "text": "beat-trip\ndance-hole\nmanda\nmoody-octopus\nshape-emitter\nslug\nstarfish\nstar\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        },
        {
          "chunkIdentity": {
            "fileName": "analyze.css",
            "startLine": 1,
            "endLine": 75,
            "text": ".container {\n    max-width: 600px;\n    margin: 50px auto;\n    padding: 20px;\n    background: #f5f5f5;\n    border-radius: 8px;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n    display: flex;\n    gap: 10px;\n}\n\n.progress-bar {\n    width: 100%;\n    height: 20px;\n    background: #ddd;\n    border-radius: 10px;\n    overflow: hidden;\n}\n\n.progress {\n    width: 0%;\n    height: 100%;\n    background: #4caf50;\n    transition: width 0.3s ease;\n}\n\n#status {\n    margin-top: 10px;\n    text-align: center;\n    color: #666;\n}\n\nbutton {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    background: #4caf50;\n    color: white;\n    cursor: pointer;\n}\n\nbutton:disabled {\n    background: #ccc;\n    cursor: not-allowed;\n}\n\n.progress-bar-container {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    width: 100%;\n}\n\n.progress-bar {\n    flex-grow: 1;\n}\n\n.time-label {\n    font-family: monospace;\n    font-size: 14px;\n    color: #666;\n    min-width: 45px;\n}\n\n.time-current {\n    font-family: monospace;\n    font-size: 16px;\n    color: #333;\n    text-align: center;\n    margin: 5px 0;\n}\n",
            "chunkType": "CHUNK_TYPE_CODEBASE"
          },
          "completeText": ""
        }
      ],
      "intermediateSectionType": "codebase",
      "statusUpdates": {
        "updates": []
      },
      "capabilityStatuses": {
        "mutate-request": [],
        "start-submit-chat": [],
        "before-submit-chat": [],
        "after-submit-chat": [],
        "after-apply": [],
        "composer-settled": [],
        "composer-done": [],
        "process-stream": [
          {
            "type": 15,
            "status": "completed"
          }
        ]
      }
    }
  ],
  "status": "completed",
  "context": {
    "editTrailContexts": [],
    "notepads": [],
    "quotes": [],
    "selectedCommits": [],
    "selectedPullRequests": [],
    "selectedImages": [],
    "folderSelections": [],
    "fileSelections": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
          "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
          "scheme": "file"
        },
        "addedWithoutMention": true,
        "autoContext": true
      }
    ],
    "selections": [],
    "terminalSelections": [],
    "selectedDocs": [],
    "externalLinks": [],
    "diffHistory": {
      "files": [
        {
          "$mid": 1,
          "path": "/esbuild.js",
          "scheme": "file"
        },
        {
          "$mid": 1,
          "path": "/service-worker.js",
          "scheme": "file"
        },
        {
          "$mid": 1,
          "path": "/index.js",
          "scheme": "file"
        }
      ],
      "diffHistories": [],
      "uniqueId": "b88b1316-7a85-498f-a1ab-aaea5528650e"
    },
    "mentions": {
      "editTrailContexts": {},
      "notepads": {},
      "quotes": {},
      "selectedCommits": {},
      "selectedPullRequests": {},
      "gitDiff": [],
      "gitDiffFromBranchToMain": [],
      "selectedImages": {},
      "usesCodebase": [],
      "useWeb": [],
      "folderSelections": {},
      "fileSelections": {},
      "terminalFiles": {},
      "selections": {},
      "terminalSelections": {},
      "selectedDocs": {},
      "externalLinks": {},
      "useLinterErrors": [],
      "useDiffReview": [],
      "useContextPicking": [],
      "useRememberThis": [],
      "diffHistory": []
    }
  },
  "gitGraphFileSuggestions": [],
  "userResponsesToSuggestedCodeBlocks": [
    {
      "userResponseType": 1,
      "filePath": "src/audio/WorkerRPC.js"
    },
    {
      "userResponseType": 1,
      "filePath": "webpack.config.js"
    },
    {
      "userResponseType": 1,
      "filePath": "esbuild.js"
    },
    {
      "userResponseType": 2,
      "filePath": "src/audio/analyzers/SpectralCentroid.js"
    }
  ],
  "generatingBubbleIds": [],
  "isReadingLongFile": false,
  "codeBlockData": {
    "file:///Users/redaphid/Projects/paper-cranes/service-worker.js": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/service-worker.js",
          "path": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
          "scheme": "file"
        },
        "version": 0,
        "content": "// Add this after the existing event listeners\n\nself.addEventListener('message', async (event) => {\n    if (event.data === 'clearCache') {\n        try {\n            const cacheNames = await caches.keys()\n            await Promise.all(\n                cacheNames.map(cacheName => caches.delete(cacheName))\n            )\n            console.log('Cache cleared successfully')\n        } catch (error) {\n            console.error('Error clearing cache:', error)\n        }\n    }\n})",
        "languageId": "javascript",
        "status": "rejected",
        "isNotApplied": false,
        "originalModelDiffWrtV0": [],
        "newModelDiffWrtV0": [
          {
            "original": {
              "startLineNumber": 52,
              "endLineNumberExclusive": 52
            },
            "modified": [
              "",
              "self.addEventListener('message', async (event) => {",
              "    if (event.data === 'clearCache') {",
              "        try {",
              "            const cacheNames = await caches.keys()",
              "            await Promise.all(",
              "                cacheNames.map(cacheName => caches.delete(cacheName))",
              "            )",
              "            console.log('Cache cleared successfully')",
              "        } catch (error) {",
              "            console.error('Error clearing cache:', error)",
              "        }",
              "    }",
              "})"
            ]
          }
        ],
        "isNoOp": false
      }
    ],
    "file:///Users/redaphid/Projects/paper-cranes/index.js": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/index.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/index.js",
          "path": "/Users/redaphid/Projects/paper-cranes/index.js",
          "scheme": "file"
        },
        "version": 0,
        "content": "async function clearServiceWorkerCache() {\n    if ('serviceWorker' in navigator) {\n        try {\n            // Get all service worker registrations\n            const registrations = await navigator.serviceWorker.getRegistrations()\n            \n            // Unregister all service workers\n            await Promise.all(registrations.map(registration => registration.unregister()))\n            \n            // Clear all caches\n            const cacheNames = await caches.keys()\n            await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)))\n            \n            // Send message to service worker to clear cache\n            if (navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage('clearCache')\n            }\n            \n            console.log('Service worker cache cleared successfully')\n            // Optionally reload the page to ensure clean state\n            window.location.reload()\n        } catch (error) {\n            console.error('Error clearing service worker cache:', error)\n        }\n    }\n}\n\n// You can call this function when needed\nwindow.clearServiceWorkerCache = clearServiceWorkerCache",
        "languageId": "javascript",
        "status": "completed",
        "isNotApplied": false,
        "originalModelDiffWrtV0": [],
        "newModelDiffWrtV0": [
          {
            "original": {
              "startLineNumber": 161,
              "endLineNumberExclusive": 161
            },
            "modified": [
              "",
              "async function clearServiceWorkerCache() {",
              "    if ('serviceWorker' in navigator) {",
              "        try {",
              "            // Get all service worker registrations",
              "            const registrations = await navigator.serviceWorker.getRegistrations()",
              "            ",
              "            // Unregister all service workers",
              "            await Promise.all(registrations.map(registration => registration.unregister()))",
              "            ",
              "            // Clear all caches",
              "            const cacheNames = await caches.keys()",
              "            await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)))",
              "            ",
              "            // Send message to service worker to clear cache",
              "            if (navigator.serviceWorker.controller) {",
              "                navigator.serviceWorker.controller.postMessage('clearCache')",
              "            }",
              "            ",
              "            console.log('Service worker cache cleared successfully')",
              "            // Optionally reload the page to ensure clean state",
              "            window.location.reload()",
              "        } catch (error) {",
              "            console.error('Error clearing service worker cache:', error)",
              "        }",
              "    }",
              "}",
              "",
              "// You can call this function when needed",
              "window.clearServiceWorkerCache = clearServiceWorkerCache"
            ]
          }
        ],
        "isNoOp": false
      }
    ],
    "file:///Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
          "path": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
          "scheme": "file"
        },
        "version": 0,
        "content": "initialize = async () => {\n    const workerUrl = new URL(`./src/audio/analyzers/${this.workerName}.js`, import.meta.url)\n    const response = await fetch(workerUrl)\n    if (!response.ok) {\n        throw new Error(`Failed to fetch ${this.workerName} worker: ${response.statusText}`)\n    }\n\n    const code = await response.text()\n    // Create blob with module type\n    const blob = new Blob([code], { type: 'application/javascript' })\n    // Create worker with module support\n    this.worker = new Worker(URL.createObjectURL(blob), { type: 'module' })\n\n    this.worker.onmessage = this.handleMessage\n    this.worker.onerror = this.handleError\n\n    this.worker.postMessage({\n        type: 'config',\n        config: { historySize: this.historySize },\n    })\n}",
        "languageId": "javascript",
        "status": "accepted",
        "isNotApplied": false,
        "originalModelDiffWrtV0": [],
        "newModelDiffWrtV0": [
          {
            "original": {
              "startLineNumber": 97,
              "endLineNumberExclusive": 98
            },
            "modified": [
              "        this.worker = new Worker(URL.createObjectURL(blob), { type: 'module' })"
            ]
          }
        ],
        "isNoOp": false
      }
    ],
    "file:///Users/redaphid/Projects/paper-cranes/webpack.config.js": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/webpack.config.js",
          "path": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
          "scheme": "file"
        },
        "version": 0,
        "content": "module: {\n    rules: [\n        // ... other rules ...\n        {\n            test: /src\\/audio\\/analyzers\\/.+\\.js$/,\n            use: [\n                {\n                    loader: 'worker-loader',\n                    options: {\n                        filename: 'audio/analyzers/[name].[contenthash].js',\n                        esModule: true,\n                    },\n                },\n            ],\n            type: 'javascript/auto',\n        },\n    ],\n}",
        "languageId": "javascript",
        "status": "accepted",
        "isNotApplied": false,
        "originalModelDiffWrtV0": [],
        "newModelDiffWrtV0": [
          {
            "original": {
              "startLineNumber": 52,
              "endLineNumberExclusive": 53
            },
            "modified": [
              "                test: /src\\/audio\\/analyzers\\/.+\\.js$/,"
            ]
          },
          {
            "original": {
              "startLineNumber": 55,
              "endLineNumberExclusive": 56
            },
            "modified": [
              "                        loader: 'worker-loader',"
            ]
          },
          {
            "original": {
              "startLineNumber": 57,
              "endLineNumberExclusive": 59
            },
            "modified": [
              "                            filename: 'audio/analyzers/[name].[contenthash].js',",
              "                            esModule: true,"
            ]
          },
          {
            "original": {
              "startLineNumber": 62,
              "endLineNumberExclusive": 62
            },
            "modified": [
              "                type: 'javascript/auto',"
            ]
          }
        ],
        "isNoOp": false
      }
    ],
    "file:///Users/redaphid/Projects/paper-cranes/esbuild.js": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
          "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
          "scheme": "file"
        },
        "version": 0,
        "content": "await build({\n    entryPoints,\n    format: 'esm',\n    bundle: true,\n    minify: true,\n    sourcemap: !process.env.NODE_ENV,\n    outdir: join(process.cwd(), 'dist'),\n    treeShaking: true,\n    define: {\n        CACHE_NAME: '\"cranes-cache-v2\"',\n        'process.env.NODE_ENV': process.env.NODE_ENV ?? '\"development\"',\n    },\n    loader: {\n        '.ttf': 'file',\n        '.woff': 'file',\n        '.woff2': 'file',\n    },\n    // Add this section to handle workers\n    plugins: [{\n        name: 'worker-plugin',\n        setup(build) {\n            build.onResolve({ filter: /\\/analyzers\\/.+\\.js$/ }, args => ({\n                path: args.path,\n                namespace: 'worker'\n            }))\n            build.onLoad({ filter: /.*/, namespace: 'worker' }, async (args) => ({\n                contents: `\n                    import * as hypnosound from 'hypnosound';\n                    ${await readFile(args.path, 'utf8')}\n                `,\n                loader: 'js'\n            }))\n        }\n    }]\n})",
        "languageId": "javascript",
        "status": "accepted",
        "isNotApplied": false,
        "originalModelDiffWrtV0": [],
        "newModelDiffWrtV0": [
          {
            "original": {
              "startLineNumber": 94,
              "endLineNumberExclusive": 95
            },
            "modified": [
              "        },",
              "        plugins: [{",
              "            name: 'worker-plugin',",
              "            setup(build) {",
              "                build.onResolve({ filter: /\\/analyzers\\/.+\\.js$/ }, args => ({",
              "                    path: args.path,",
              "                    namespace: 'worker'",
              "                }))",
              "                build.onLoad({ filter: /.*/, namespace: 'worker' }, async (args) => ({",
              "                    contents: `",
              "                        import * as hypnosound from 'hypnosound';",
              "                        ${await readFile(args.path, 'utf8')}",
              "                    `,",
              "                    loader: 'js'",
              "                }))",
              "            }",
              "        }]"
            ]
          }
        ],
        "isNoOp": false
      }
    ],
    "file:///Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js": [
      {
        "uri": {
          "$mid": 1,
          "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
          "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
          "path": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
          "scheme": "file"
        },
        "version": 0,
        "content": "import { spectralCentroid, makeCalculateStats } from 'hypnosound'\n\nlet calculateStats = makeCalculateStats()\n\nself.addEventListener('message', ({ data: e }) => {\n    if (e.type === 'fftData') {\n        const { fft } = e.data\n        const value = spectralCentroid(fft)\n        self.postMessage({\n            id: e.id,\n            type: 'computedValue',\n            value,\n            stats: calculateStats(value)\n        })\n    }\n    if (e.type === 'config') {\n        calculateStats = makeCalculateStats(e.config.historySize)\n    }\n})",
        "languageId": "javascript",
        "status": "rejected",
        "isNotApplied": false,
        "originalModelDiffWrtV0": [],
        "newModelDiffWrtV0": [
          {
            "original": {
              "startLineNumber": 1,
              "endLineNumberExclusive": 2
            },
            "modified": [
              "import { spectralCentroid, makeCalculateStats } from 'hypnosound'"
            ]
          },
          {
            "original": {
              "startLineNumber": 7,
              "endLineNumberExclusive": 8
            },
            "modified": [
              "        const { fft } = e.data"
            ]
          },
          {
            "original": {
              "startLineNumber": 9,
              "endLineNumberExclusive": 10
            },
            "modified": [
              "        self.postMessage({",
              "            id: e.id,",
              "            type: 'computedValue',",
              "            value,",
              "            stats: calculateStats(value)",
              "        })"
            ]
          }
        ],
        "isNoOp": false
      }
    ]
  },
  "originalModelLines": {
    "file:///Users/redaphid/Projects/paper-cranes/service-worker.js": [
      "const wait = async (ms) => new Promise((resolve) => setTimeout(resolve, ms))",
      "",
      "self.addEventListener('install', function (event) {",
      "    // Perform install steps",
      "})",
      "",
      "async function fetchWithControlledRetry(request) {",
      "    const cache = await caches.open(CACHE_NAME)",
      "",
      "    async function attemptFetch() {",
      "        let cacheResponse = await caches.match(request)",
      "",
      "        const timeoutPromise = new Promise((resolve) =>",
      "            setTimeout(async () => {",
      "                if (cacheResponse) return resolve(cacheResponse)",
      "                await wait(500)",
      "                resolve(fetch(request))",
      "            }, 1000),",
      "        )",
      "",
      "        const networkPromise = fetch(request)",
      "            .then(async (response) => {",
      "                if (response.ok) {",
      "                    await cache.put(request, response.clone()) // Cache the successful response",
      "                    return response",
      "                }",
      "                throw new Error('Network response was not ok')",
      "            })",
      "            .catch(async (error) => {",
      "                // In case of network error (including being offline), return cached response if available",
      "                if (cacheResponse) {",
      "                    return cacheResponse",
      "                }",
      "                wait(500) // Wait 500ms before retrying",
      "                return fetch(request)",
      "            })",
      "",
      "        return Promise.race([networkPromise, timeoutPromise])",
      "    }",
      "",
      "    return attemptFetch()",
      "}",
      "",
      "self.addEventListener('fetch', function (event) {",
      "    // Guard clauses for GET requests, excluding 'edit' in URL, and ensuring same-origin",
      "    if (event.request.method !== 'GET' || event.request.url.includes('edit') || new URL(event.request.url).origin !== location.origin) {",
      "        return",
      "    }",
      "",
      "    event.respondWith(fetchWithControlledRetry(event.request))",
      "})",
      ""
    ],
    "file:///Users/redaphid/Projects/paper-cranes/index.js": [
      "import { AudioProcessor } from './src/audio/AudioProcessor.js'",
      "import { makeVisualizer } from './src/Visualizer.js'",
      "import './index.css'",
      "const events = ['touchstart', 'touchmove', 'touchstop', 'click', 'keydown', 'mousemove', 'mousedown', 'mouseup', 'resize']",
      "let ranMain = false",
      "let startTime = 0",
      "const params = new URLSearchParams(window.location.search)",
      "",
      "const getVisualizerDOMElement = () => {",
      "    if (!window.visualizer) {",
      "        window.visualizer = document.getElementById('visualizer')",
      "    }",
      "    return window.visualizer",
      "}",
      "",
      "// check if we have microphone access. If so, just run main immediately",
      "navigator.mediaDevices",
      "    .getUserMedia({",
      "        audio: {",
      "            echoCancellation: false,",
      "            noiseSuppression: false,",
      "            autoGainControl: false,",
      "        },",
      "    })",
      "    .then(() => main())",
      "    .catch(() => {",
      "        const body = document.querySelector('body')",
      "        body.classList.remove('ready')",
      "    })",
      "if ('serviceWorker' in navigator) {",
      "    window.addEventListener('load', () => {",
      "        navigator.serviceWorker.register(new URL('/service-worker.js', import.meta.url)).then(",
      "            (registration) => {",
      "                console.log('ServiceWorker registration successful with scope: ', registration.scope)",
      "            },",
      "            (err) => {",
      "                console.log('ServiceWorker registration failed: ', err)",
      "            },",
      "        )",
      "    })",
      "}",
      "window.cranes = window.cranes || {}",
      "window.cranes.manualFeatures = window.cranes.manualFeatures || {}",
      "const getRelativeOrAbsolute = async (url) => {",
      "    //if the url is not a full url, then it's a relative url",
      "    if (!url.includes('http')) {",
      "        url = `/shaders/${url}`",
      "    }",
      "    const res = await fetch(url)",
      "    const shader = await res.text()",
      "    return shader",
      "}",
      "",
      "const getFragmentShader = async () => {",
      "    const shaderUrl = params.get('shader')",
      "    let fragmentShader",
      "    if (shaderUrl) {",
      "        fragmentShader = await getRelativeOrAbsolute(`${shaderUrl}.frag`)",
      "    }",
      "",
      "    if (!fragmentShader) {",
      "        fragmentShader = localStorage.getItem('cranes-manual-code')",
      "    }",
      "",
      "    if (!fragmentShader) {",
      "        fragmentShader = await getRelativeOrAbsolute('default.frag')",
      "    }",
      "    return fragmentShader",
      "}",
      "",
      "const getVertexShader = async () => {",
      "    const shaderUrl = params.get('vertex_shader')",
      "    let vertexShader",
      "    if (shaderUrl) {",
      "        vertexShader = await getRelativeOrAbsolute(`${shaderUrl}.vert`)",
      "    }",
      "",
      "    if (!vertexShader) {",
      "        vertexShader = localStorage.getItem('cranes-manual-code-vertex')",
      "    }",
      "",
      "    if (!vertexShader) {",
      "        vertexShader = await getRelativeOrAbsolute('default.vert')",
      "    }",
      "    return vertexShader",
      "}",
      "",
      "const main = async () => {",
      "    try {",
      "        if (ranMain) return",
      "        ranMain = true",
      "        window.c = cranes",
      "        startTime = performance.now()",
      "        const audio = await setupAudio()",
      "",
      "        const fragmentShader = await getFragmentShader()",
      "        const vertexShader = await getVertexShader()",
      "",
      "        window.shader = fragmentShader",
      "        const initialImageUrl = params.get('image') ?? 'images/placeholder-image.png'",
      "        const fullscreen = (params.get('fullscreen') ?? false) === 'true'",
      "        const canvas = getVisualizerDOMElement()",
      "        const render = await makeVisualizer({ canvas, initialImageUrl, fullscreen })",
      "        requestAnimationFrame(() => animate({ render, audio, fragmentShader, vertexShader }))",
      "    } catch (e) {",
      "        console.error(`main error: ${e}`)",
      "    }",
      "}",
      "",
      "// if the url contains the string 'edit', don't do this.",
      "if (!window.location.href.includes('edit')) {",
      "    events.forEach((event) => {",
      "        // get the visualizer",
      "        const visualizer = getVisualizerDOMElement()",
      "        visualizer.addEventListener(event, main, { once: true })",
      "        visualizer.addEventListener(",
      "            event,",
      "            () => {",
      "                try {",
      "                    document.documentElement.requestFullscreen()",
      "                } catch (e) {",
      "                    console.error(`preventing a crash: ${e}`)",
      "                }",
      "            },",
      "            { once: true },",
      "        )",
      "    })",
      "}",
      "const setupAudio = async () => {",
      "    const audioContext = new AudioContext()",
      "    await audioContext.resume()",
      "    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })",
      "    const sourceNode = audioContext.createMediaStreamSource(stream)",
      "    const historySize = parseInt(params.get('history_size') ?? '500')",
      "    const audioProcessor = new AudioProcessor(audioContext, sourceNode, historySize)",
      "    await audioProcessor.start()",
      "    return audioProcessor",
      "}",
      "",
      "const animate = ({ render, audio, fragmentShader, vertexShader }) => {",
      "    requestAnimationFrame(() => animate({ render, audio, fragmentShader, vertexShader }))",
      "    fragmentShader = window.cranes?.shader ?? fragmentShader",
      "    const measuredAudioFeatures = audio.getFeatures()",
      "    const queryParamFeatures = {}",
      "",
      "    for (const [key, value] of params) {",
      "        queryParamFeatures[key] = value",
      "    }",
      "",
      "    const { manualFeatures } = window.cranes",
      "    window.cranes.measuredAudioFeatures = measuredAudioFeatures",
      "    const features = { ...measuredAudioFeatures, ...queryParamFeatures, ...manualFeatures }",
      "",
      "    try {",
      "        render({ time: (performance.now() - startTime) / 1000, features, fragmentShader, vertexShader })",
      "    } catch (e) {",
      "        console.error(e)",
      "    }",
      "",
      "}",
      ""
    ],
    "file:///Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js": [
      "export class WorkerRPC {",
      "    constructor(workerName, historySize, timeout = 50) {",
      "        this.workerName = workerName",
      "        this.historySize = historySize",
      "        this.timeout = timeout",
      "        this.currentMessageId = 0",
      "        this.resolveMessage = null",
      "        this.lastMessage = this.createDefaultMessage()",
      "    }",
      "",
      "    createDefaultMessage = () => ({",
      "        type: 'computedValue',",
      "        workerName: this.workerName,",
      "        value: 0,",
      "        stats: {",
      "            current: 0,",
      "            mean: 0,",
      "            median: 0,",
      "            min: 0,",
      "            max: 0,",
      "            variance: 0,",
      "            standardDeviation: 0,",
      "            zScore: 0,",
      "            normalized: 0,",
      "        },",
      "    })",
      "",
      "    validateStats = (stats = {}) => ({",
      "        current: isFinite(stats.current) ? stats.current : 0,",
      "        mean: isFinite(stats.mean) ? stats.mean : 0,",
      "        median: isFinite(stats.median) ? stats.median : 0,",
      "        min: isFinite(stats.min) ? stats.min : 0,",
      "        max: isFinite(stats.max) ? stats.max : 0,",
      "        variance: isFinite(stats.variance) ? stats.variance : 0,",
      "        standardDeviation: isFinite(stats.standardDeviation) ? stats.standardDeviation : 0,",
      "        zScore: isFinite(stats.zScore) ? stats.zScore : 0,",
      "        normalized: isFinite(stats.normalized) ? stats.normalized : 0,",
      "    })",
      "",
      "    validateMessage = (message) => ({",
      "        ...message,",
      "        workerName: this.workerName,",
      "        value: isFinite(message.value) ? message.value : 0,",
      "        stats: this.validateStats(message.stats),",
      "    })",
      "",
      "    handleMessage = (event) => {",
      "        if (event.data.type === 'computedValue') {",
      "            const validatedMessage = this.validateMessage(event.data)",
      "            this.lastMessage = validatedMessage",
      "",
      "            if (this.resolveMessage && event.data.id === this.currentMessageId) {",
      "                this.resolveMessage(validatedMessage)",
      "                this.resolveMessage = null",
      "            }",
      "        }",
      "    }",
      "",
      "    processData = async (fftData) => {",
      "        if (this.resolveMessage) {",
      "            console.log(`${this.workerName} abandoning message after ${performance.now() - this.currentMessageId}ms`)",
      "            this.resolveMessage()",
      "        }",
      "",
      "        const messageId = (this.currentMessageId = performance.now())",
      "",
      "        const messagePromise = Promise.race([",
      "            new Promise((resolve) => {",
      "                this.resolveMessage = resolve",
      "            }),",
      "            new Promise((_, reject) => setTimeout(() => reject(new Error(`Worker ${this.workerName} timed out`)), this.timeout)).catch(() => {",
      "                if (this.currentMessageId === messageId) {",
      "                    this.resolveMessage = null",
      "                }",
      "                return this.lastMessage",
      "            }),",
      "        ])",
      "",
      "        this.worker.postMessage({",
      "            type: 'fftData',",
      "            id: messageId,",
      "            data: { fft: fftData },",
      "        })",
      "",
      "        return messagePromise",
      "    }",
      "",
      "    initialize = async () => {",
      "        const workerUrl = new URL(`./src/audio/analyzers/${this.workerName}.js`, import.meta.url)",
      "        const response = await fetch(workerUrl)",
      "        if (!response.ok) {",
      "            throw new Error(`Failed to fetch ${this.workerName} worker: ${response.statusText}`)",
      "        }",
      "",
      "        const code = await response.text()",
      "        const blob = new Blob([code], { type: 'application/javascript' })",
      "        this.worker = new Worker(URL.createObjectURL(blob))",
      "",
      "        this.worker.onmessage = this.handleMessage",
      "        this.worker.onerror = this.handleError",
      "",
      "        this.worker.postMessage({",
      "            type: 'config',",
      "            config: { historySize: this.historySize },",
      "        })",
      "    }",
      "",
      "    handleError = (error) => {",
      "        console.error(`Error in worker ${this.workerName}:`, error)",
      "    }",
      "",
      "    terminate = () => {",
      "        this.worker?.terminate()",
      "    }",
      "}",
      ""
    ],
    "file:///Users/redaphid/Projects/paper-cranes/webpack.config.js": [
      "const path = require('path')",
      "const HtmlWebpackPlugin = require('html-webpack-plugin')",
      "const MiniCssExtractPlugin = require('mini-css-extract-plugin')",
      "const TerserPlugin = require('terser-webpack-plugin')",
      "const CopyWebpackPlugin = require('copy-webpack-plugin')",
      "const { DefinePlugin } = require('webpack')",
      "",
      "module.exports = {",
      "    mode: 'production',",
      "",
      "    // Your other webpack configurations go here",
      "    devServer: {",
      "        static: {",
      "            directory: path.join(__dirname, 'dist'), // Path to your built files",
      "        },",
      "        port: 6969, // Choose any port you prefer",
      "        hot: false, // Enable hot module replacement",
      "    },",
      "",
      "    entry: {",
      "        app: './index.js',",
      "        'service-worker': './service-worker.js',",
      "    },",
      "    output: {",
      "        path: path.resolve(__dirname, 'dist'),",
      "        filename: '[name].js',",
      "        publicPath: '/',",
      "    },",
      "    module: {",
      "        rules: [",
      "            {",
      "                test: /\\.css$/,",
      "                use: [MiniCssExtractPlugin.loader, 'css-loader'],",
      "            },",
      "            {",
      "                test: /\\.(png|jpe?g|gif|svg)$/i,",
      "                use: [",
      "                    {",
      "                        loader: 'file-loader',",
      "                        options: {",
      "                            outputPath: 'images',",
      "                            name: '[name].[ext]',",
      "                        },",
      "                    },",
      "                ],",
      "            },",
      "            {",
      "                test: /\\.html$/,",
      "                use: ['html-loader'],",
      "            },",
      "            {",
      "                test: /src\\/audio\\/analyzers\\/.+\\.js$/, // Regex to match JS files in the specific directory",
      "                use: [",
      "                    {",
      "                        loader: 'file-loader',",
      "                        options: {",
      "                            name: '[contenthash]/[name].js',",
      "                            outputPath: 'audio/analyzers',",
      "                        },",
      "                    },",
      "                ],",
      "            },",
      "        ],",
      "    },",
      "    plugins: [",
      "        new HtmlWebpackPlugin({",
      "            template: './index.html',",
      "            inject: true,",
      "        }),",
      "        new MiniCssExtractPlugin({",
      "            filename: '[name].[contenthash].css',",
      "        }),",
      "        new CopyWebpackPlugin({",
      "            patterns: [",
      "                { from: 'images', to: 'images' },",
      "                { from: 'shaders', to: 'shaders' },",
      "                { from: 'favicon.ico', to: 'favicon.ico' },",
      "                { from: 'index.css', to: 'index.css' },",
      "                { from: './src/utils', to: 'utils' },",
      "            ],",
      "        }),",
      "        new DefinePlugin({",
      "            WEBPACK_CACHE_NAME: JSON.stringify(new Date().toISOString()),",
      "        }),",
      "    ],",
      "    optimization: {",
      "        minimize: true,",
      "        minimizer: [",
      "            new TerserPlugin({",
      "                terserOptions: {",
      "                    format: {",
      "                        comments: false,",
      "                    },",
      "                },",
      "                extractComments: false,",
      "            }),",
      "        ],",
      "    },",
      "}",
      ""
    ],
    "file:///Users/redaphid/Projects/paper-cranes/esbuild.js": [
      "import { build } from 'esbuild'",
      "import { join, relative } from 'path'",
      "import { readdir, stat, mkdir, writeFile } from 'fs/promises'",
      "import ncp from 'ncp'",
      "import { promisify } from 'util'",
      "",
      "const ncpAsync = promisify(ncp)",
      "",
      "async function ensureDistDirectory() {",
      "    try {",
      "        await mkdir('dist', { recursive: true })",
      "    } catch (err) {",
      "        console.error('Error ensuring dist directory:', err)",
      "    }",
      "}",
      "",
      "async function getShaderFiles(dir) {",
      "    let fileList = []",
      "    const files = await readdir(dir)",
      "    await Promise.all(",
      "        files.map(async (file) => {",
      "            const filePath = join(dir, file)",
      "            const stats = await stat(filePath)",
      "            if (stats.isDirectory()) {",
      "                if (!['private', 'knobs', 'utils', 'practice'].includes(file)) {",
      "                    const subDirFiles = await getShaderFiles(filePath)",
      "                    fileList = fileList.concat(subDirFiles)",
      "                }",
      "            } else if (file.endsWith('.frag')) {",
      "                fileList.push(filePath)",
      "            }",
      "        }),",
      "    )",
      "    return fileList",
      "}",
      "",
      "async function getEntryPoints(dir) {",
      "    let entryPoints = []",
      "    const files = await readdir(dir, { withFileTypes: true })",
      "    await Promise.all(",
      "        files.map(async (file) => {",
      "            const filePath = join(dir, file.name)",
      "            if (file.isDirectory()) {",
      "                const subDirEntries = await getEntryPoints(filePath)",
      "                entryPoints = entryPoints.concat(subDirEntries)",
      "            } else if (file.isFile() && file.name.endsWith('.js')) {",
      "                entryPoints.push(filePath)",
      "            }",
      "        }),",
      "    )",
      "    return entryPoints",
      "}",
      "",
      "async function generateHTML(shaderFiles) {",
      "    let htmlContent = '<!DOCTYPE html>\\n<html>\\n<head>\\n<title>Shaders</title>\\n</head>\\n<body>\\n<ul>\\n'",
      "    shaderFiles.forEach((file) => {",
      "        const relativePath = relative('shaders', file)",
      "        const queryParam = relativePath.replace(/\\\\/g, '/').replace('.frag', '')",
      "        htmlContent += `<li><a href=\"/?shader=${queryParam}&fullscreen=true\">${queryParam}</a></li>\\n`",
      "    })",
      "    htmlContent += '</ul>\\n</body>\\n</html>'",
      "",
      "    await writeFile(join('dist', 'shaders.html'), htmlContent)",
      "}",
      "",
      "async function main() {",
      "    await ensureDistDirectory()",
      "",
      "    const entryPoints = ['index.js', 'edit.js', 'service-worker.js', 'analyze.js']",
      "    const srcEntryPoints = await getEntryPoints('./src')",
      "    entryPoints.push(...srcEntryPoints)",
      "",
      "    const shaderDir = 'shaders'",
      "    const shaderFiles = await getShaderFiles(shaderDir)",
      "",
      "    await generateHTML(shaderFiles)",
      "",
      "    await build({",
      "        entryPoints,",
      "        format: 'esm',",
      "        bundle: true,",
      "        minify: true,",
      "        sourcemap: !process.env.NODE_ENV,",
      "        outdir: join(process.cwd(), 'dist'),",
      "        treeShaking: true,",
      "        define: {",
      "            CACHE_NAME: '\"cranes-cache-v2\"',",
      "            'process.env.NODE_ENV': process.env.NODE_ENV ?? '\"development\"',",
      "        },",
      "        loader: {",
      "            '.ttf': 'file',",
      "            '.woff': 'file',",
      "            '.woff2': 'file',",
      "        }",
      "    })",
      "",
      "    // Copy Monaco's files separately",
      "    await ncpAsync(",
      "        'node_modules/monaco-editor/min/vs',",
      "        'dist/vs'",
      "    )",
      "",
      "    await Promise.all([",
      "        ncpAsync('index.html', 'dist/index.html'),",
      "        ncpAsync('index.css', 'dist/index.css'),",
      "        ncpAsync('edit.html', 'dist/edit.html'),",
      "        ncpAsync('edit.css', 'dist/edit.css'),",
      "        ncpAsync('BarGraph.css', 'dist/BarGraph.css'),",
      "        ncpAsync('favicon.ico', 'dist/favicon.ico'),",
      "        ncpAsync('images', 'dist/images'),",
      "        ncpAsync('shaders', 'dist/shaders'),",
      "        ncpAsync('codicon.ttf', 'dist/codicon.ttf'),",
      "        ncpAsync('analyze.html', 'dist/analyze.html'),",
      "        ncpAsync('analyze.css', 'dist/analyze.css'),",
      "    ])",
      "}",
      "",
      "main().catch(console.error)",
      ""
    ],
    "file:///Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js": [
      "import { makeCalculateStats, spectralCentroid } from 'hypnosound'",
      "",
      "let calculateStats = makeCalculateStats()",
      "",
      "self.addEventListener('message', ({ data: e }) => {",
      "    if (e.type === 'fftData') {",
      "        const { fft } = e.data // Extract FFT data from message",
      "        const value = spectralCentroid(fft)",
      "        self.postMessage({id: e.id, type: 'computedValue', value, stats: calculateStats(value) })",
      "    }",
      "    if (e.type === 'config') {",
      "        calculateStats = makeCalculateStats(e.config.historySize)",
      "    }",
      "})",
      ""
    ]
  },
  "newlyCreatedFiles": [],
  "newlyCreatedFolders": [],
  "tabs": [
    {
      "type": "composer"
    },
    {
      "type": "code",
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
        "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
        "path": "/Users/redaphid/Projects/paper-cranes/src/audio/analyzers/SpectralCentroid.js",
        "scheme": "file"
      },
      "version": 0
    },
    {
      "type": "code",
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
        "external": "file:///Users/redaphid/Projects/paper-cranes/esbuild.js",
        "path": "/Users/redaphid/Projects/paper-cranes/esbuild.js",
        "scheme": "file"
      },
      "version": 0
    },
    {
      "type": "code",
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
        "external": "file:///Users/redaphid/Projects/paper-cranes/webpack.config.js",
        "path": "/Users/redaphid/Projects/paper-cranes/webpack.config.js",
        "scheme": "file"
      },
      "version": 0
    },
    {
      "type": "code",
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
        "external": "file:///Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
        "path": "/Users/redaphid/Projects/paper-cranes/src/audio/WorkerRPC.js",
        "scheme": "file"
      },
      "version": 0
    },
    {
      "type": "code",
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/redaphid/Projects/paper-cranes/index.js",
        "external": "file:///Users/redaphid/Projects/paper-cranes/index.js",
        "path": "/Users/redaphid/Projects/paper-cranes/index.js",
        "scheme": "file"
      },
      "version": 0
    },
    {
      "type": "code",
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
        "external": "file:///Users/redaphid/Projects/paper-cranes/service-worker.js",
        "path": "/Users/redaphid/Projects/paper-cranes/service-worker.js",
        "scheme": "file"
      },
      "version": 0
    }
  ],
  "selectedTabIndex": 1,
  "lastUpdatedAt": 1737076330242,
  "createdAt": 1737076057653,
  "hasChangedContext": true,
  "capabilities": [
    {
      "type": 9,
      "data": {
        "customInstructions": ""
      }
    },
    {
      "type": 11,
      "data": {
        "customInstructions": ""
      }
    },
    {
      "type": 15,
      "data": {
        "customInstructions": "",
        "bubbleDataMap": "{}"
      }
    },
    {
      "type": 14,
      "data": {
        "customInstructions": ""
      }
    },
    {
      "type": 6,
      "data": {
        "customInstructions": ""
      }
    }
  ],
  "name": "Clearing Service Worker Cache Instructions",
  "forceMode": "edit",
  "codebaseSearchSettings": {},
  "isFileListExpanded": true,
  "isAgentic": false
}